//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------


namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the InnerTypeWithBoth type
[<AutoOpen>]
module InnerTypeWithBothJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type InnerTypeWithBoth with

        /// Serialize to a JSON node
        static member toJsonNode (input : InnerTypeWithBoth) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                node.Add (
                    ("it's-a-me"),
                    (input.Thing
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<Guid> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "map",
                    (input.Map
                     |> (fun field ->
                         let ret = System.Text.Json.Nodes.JsonObject ()

                         for (KeyValue (key, value)) in field do
                             let key = key.ToString ()

                             ret.Add (
                                 key,
                                 (fun field ->
                                     let field = System.Text.Json.Nodes.JsonValue.Create<Uri> field

                                     (match field with
                                      | null -> raise (System.ArgumentNullException ())
                                      | field -> field)
                                 )
                                     value
                             )

                         ret
                     ))
                )

                node.Add (
                    "readOnlyDict",
                    (input.ReadOnlyDict
                     |> (fun field ->
                         let ret = System.Text.Json.Nodes.JsonObject ()

                         for (KeyValue (key, value)) in field do
                             let key = key.ToString ()

                             ret.Add (
                                 key,
                                 (fun field ->
                                     let arr = System.Text.Json.Nodes.JsonArray ()

                                     for mem in field do
                                         arr.Add (
                                             (fun field ->
                                                 let field = System.Text.Json.Nodes.JsonValue.Create<char> field

                                                 (match field with
                                                  | null -> raise (System.ArgumentNullException ())
                                                  | field -> field)
                                             )
                                                 mem
                                         )

                                     arr
                                 )
                                     value
                             )

                         ret
                     ))
                )

                node.Add (
                    "dict",
                    (input.Dict
                     |> (fun field ->
                         let ret = System.Text.Json.Nodes.JsonObject ()

                         for (KeyValue (key, value)) in field do
                             let key = key.ToString ()

                             ret.Add (
                                 key,
                                 (fun field ->
                                     let field = System.Text.Json.Nodes.JsonValue.Create<bool> field

                                     (match field with
                                      | null -> raise (System.ArgumentNullException ())
                                      | field -> field)
                                 )
                                     value
                             )

                         ret
                     ))
                )

                node.Add (
                    "concreteDict",
                    (input.ConcreteDict
                     |> (fun field ->
                         let ret = System.Text.Json.Nodes.JsonObject ()

                         for (KeyValue (key, value)) in field do
                             let key = key.ToString ()
                             ret.Add (key, InnerTypeWithBoth.toJsonNode value)

                         ret
                     ))
                )

            node :> _
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the SomeEnum type
[<AutoOpen>]
module SomeEnumJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type SomeEnum with

        /// Serialize to a JSON node
        static member toJsonNode (input : SomeEnum) : System.Text.Json.Nodes.JsonNode =
            match input with
            | SomeEnum.Blah -> System.Text.Json.Nodes.JsonValue.Create 1
            | SomeEnum.Thing -> System.Text.Json.Nodes.JsonValue.Create 0
            | v -> failwith (sprintf "Unrecognised value for enum: %O" v)
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the JsonRecordTypeWithBoth type
[<AutoOpen>]
module JsonRecordTypeWithBothJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type JsonRecordTypeWithBoth with

        /// Serialize to a JSON node
        static member toJsonNode (input : JsonRecordTypeWithBoth) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                node.Add (
                    "a",
                    (input.A
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<int> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "b",
                    (input.B
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<string> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "c",
                    (input.C
                     |> (fun field ->
                         let arr = System.Text.Json.Nodes.JsonArray ()

                         for mem in field do
                             arr.Add (
                                 (fun field ->
                                     let field = System.Text.Json.Nodes.JsonValue.Create<int> field

                                     (match field with
                                      | null -> raise (System.ArgumentNullException ())
                                      | field -> field)
                                 )
                                     mem
                             )

                         arr
                     ))
                )

                node.Add ("d", (input.D |> InnerTypeWithBoth.toJsonNode))

                node.Add (
                    "e",
                    (input.E
                     |> (fun field ->
                         let arr = System.Text.Json.Nodes.JsonArray ()

                         for mem in field do
                             arr.Add (
                                 (fun field ->
                                     let field = System.Text.Json.Nodes.JsonValue.Create<string> field

                                     (match field with
                                      | null -> raise (System.ArgumentNullException ())
                                      | field -> field)
                                 )
                                     mem
                             )

                         arr
                     ))
                )

                node.Add (
                    "arr",
                    (input.Arr
                     |> (fun field ->
                         let arr = System.Text.Json.Nodes.JsonArray ()

                         for mem in field do
                             arr.Add (
                                 (fun field ->
                                     let field = System.Text.Json.Nodes.JsonValue.Create<int> field

                                     (match field with
                                      | null -> raise (System.ArgumentNullException ())
                                      | field -> field)
                                 )
                                     mem
                             )

                         arr
                     ))
                )

                node.Add (
                    "byte",
                    (input.Byte
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<byte<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "sbyte",
                    (input.Sbyte
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<sbyte<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "i",
                    (input.I
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<int<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "i32",
                    (input.I32
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<int32<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "i64",
                    (input.I64
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<int64<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "u",
                    (input.U
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<uint<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "u32",
                    (input.U32
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<uint32<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "u64",
                    (input.U64
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<uint64<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "f",
                    (input.F
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<float<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "f32",
                    (input.F32
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<float32<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "single",
                    (input.Single
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<single<measure>> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "intMeasureOption",
                    (input.IntMeasureOption
                     |> (fun field ->
                         match field with
                         | None -> None
                         | Some field ->
                             (field
                              |> (fun field ->
                                  let field = System.Text.Json.Nodes.JsonValue.Create<int<measure>> field

                                  (match field with
                                   | null -> raise (System.ArgumentNullException ())
                                   | field -> field)
                              ))
                             :> System.Text.Json.Nodes.JsonNode
                             |> Some
                     )
                     |> Option.toObj)
                )

                node.Add (
                    "intMeasureNullable",
                    (input.IntMeasureNullable
                     |> (fun field ->
                         if field.HasValue then
                             (fun field ->
                                 let field = System.Text.Json.Nodes.JsonValue.Create<int<measure>> field

                                 (match field with
                                  | null -> raise (System.ArgumentNullException ())
                                  | field -> field)
                             )
                                 field.Value
                             :> System.Text.Json.Nodes.JsonNode
                             |> Some
                         else
                             None
                     )
                     |> Option.toObj)
                )

                node.Add ("enum", (input.Enum |> SomeEnum.toJsonNode))

                node.Add (
                    "timestamp",
                    (input.Timestamp
                     |> (fun field -> field.ToString "o" |> System.Text.Json.Nodes.JsonValue.Create<string>))
                )

                node.Add ("unit", (input.Unit |> (fun value -> System.Text.Json.Nodes.JsonObject ())))

            node :> _
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the FirstDu type
[<AutoOpen>]
module FirstDuJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FirstDu with

        /// Serialize to a JSON node
        static member toJsonNode (input : FirstDu) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            match input with
            | FirstDu.EmptyCase -> node.Add ("type", System.Text.Json.Nodes.JsonValue.Create "emptyCase")
            | FirstDu.Case1 arg0 ->
                node.Add ("type", System.Text.Json.Nodes.JsonValue.Create "case1")
                let dataNode = System.Text.Json.Nodes.JsonObject ()

                dataNode.Add (
                    "data",
                    (fun field ->
                        let field = System.Text.Json.Nodes.JsonValue.Create<string> field

                        (match field with
                         | null -> raise (System.ArgumentNullException ())
                         | field -> field)
                    )
                        arg0
                )

                node.Add ("data", dataNode)
            | FirstDu.Case2 (arg0, arg1) ->
                node.Add ("type", System.Text.Json.Nodes.JsonValue.Create "case2")
                let dataNode = System.Text.Json.Nodes.JsonObject ()
                dataNode.Add ("record", JsonRecordTypeWithBoth.toJsonNode arg0)

                dataNode.Add (
                    "i",
                    (fun field ->
                        let field = System.Text.Json.Nodes.JsonValue.Create<int> field

                        (match field with
                         | null -> raise (System.ArgumentNullException ())
                         | field -> field)
                    )
                        arg1
                )

                node.Add ("data", dataNode)

            node :> _
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the HeaderAndValue type
[<AutoOpen>]
module HeaderAndValueJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type HeaderAndValue with

        /// Serialize to a JSON node
        static member toJsonNode (input : HeaderAndValue) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                node.Add (
                    "header",
                    (input.Header
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<string> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

                node.Add (
                    "value",
                    (input.Value
                     |> (fun field ->
                         let field = System.Text.Json.Nodes.JsonValue.Create<string> field

                         (match field with
                          | null -> raise (System.ArgumentNullException ())
                          | field -> field)
                     ))
                )

            node :> _
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the Foo type
[<AutoOpen>]
module FooJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Foo with

        /// Serialize to a JSON node
        static member toJsonNode (input : Foo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> None
                         | Some field -> field |> HeaderAndValue.toJsonNode |> Some
                     )
                     |> Option.toObj)
                )

            node :> _
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the CollectRemaining type
[<AutoOpen>]
module CollectRemainingJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CollectRemaining with

        /// Serialize to a JSON node
        static member toJsonNode (input : CollectRemaining) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> None
                         | Some field -> field |> HeaderAndValue.toJsonNode |> Some
                     )
                     |> Option.toObj)
                )

                for KeyValue (key, value) in input.Rest do
                    node.Add (key, id value)

            node :> _
namespace ConsumePlugin

open System
open System.Collections.Generic
open System.Text.Json.Serialization

/// Module containing JSON serializing extension members for the OuterCollectRemaining type
[<AutoOpen>]
module OuterCollectRemainingJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type OuterCollectRemaining with

        /// Serialize to a JSON node
        static member toJsonNode (input : OuterCollectRemaining) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.Others do
                    node.Add (
                        key,
                        (fun field ->
                            let field = System.Text.Json.Nodes.JsonValue.Create<int> field

                            (match field with
                             | null -> raise (System.ArgumentNullException ())
                             | field -> field)
                        )
                            value
                    )

                node.Add ("remaining", (input.Remaining |> CollectRemaining.toJsonNode))

            node :> _

namespace ConsumePlugin

/// Module containing JSON parsing extension members for the InnerTypeWithBoth type
[<AutoOpen>]
module InnerTypeWithBothJsonParseExtension =
    /// Extension methods for JSON parsing
    type InnerTypeWithBoth with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : InnerTypeWithBoth =
            let arg_4 =
                match node.["concreteDict"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("concreteDict")
                        )
                    )
                | Some node ->
                    node.AsObject ()
                    |> Seq.map (fun kvp ->
                        let key = (kvp.Key)
                        let value = kvp.Value

                        key,
                        (match value with
                         | null -> raise (System.ArgumentNullException ())
                         | value -> InnerTypeWithBoth.jsonParse value)
                    )
                    |> Seq.map System.Collections.Generic.KeyValuePair
                    |> System.Collections.Generic.Dictionary

            let arg_3 =
                match node.["dict"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("dict")
                        )
                    )
                | Some node ->
                    node.AsObject ()
                    |> Seq.map (fun kvp ->
                        let key = (kvp.Key) |> System.Uri
                        let value = kvp.Value

                        key,
                        (match value with
                         | null -> raise (System.ArgumentNullException ())
                         | value -> value.AsValue().GetValue<System.Boolean> ())
                    )
                    |> dict

            let arg_2 =
                match node.["readOnlyDict"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("readOnlyDict")
                        )
                    )
                | Some node ->
                    node.AsObject ()
                    |> Seq.map (fun kvp ->
                        let key = (kvp.Key)
                        let value = kvp.Value

                        key,
                        (match value with
                         | null -> raise (System.ArgumentNullException ())
                         | value ->
                             value.AsArray ()
                             |> Seq.map (fun elt ->
                                 (match elt with
                                  | null -> raise (System.ArgumentNullException ())
                                  | elt -> elt.AsValue().GetValue<System.Char> ())
                             )
                             |> List.ofSeq)
                    )
                    |> readOnlyDict

            let arg_1 =
                match node.["map"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("map")
                        )
                    )
                | Some node ->
                    node.AsObject ()
                    |> Seq.map (fun kvp ->
                        let key = (kvp.Key)
                        let value = kvp.Value

                        key,
                        (match value with
                         | null -> raise (System.ArgumentNullException ())
                         | value -> value.AsValue().GetValue<string> () |> System.Uri)
                    )
                    |> Map.ofSeq

            let arg_0 =
                match node.[("it's-a-me")] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" (("it's-a-me"))
                        )
                    )
                | Some node -> node.AsValue().GetValue<string> () |> System.Guid.Parse

            {
                Thing = arg_0
                Map = arg_1
                ReadOnlyDict = arg_2
                Dict = arg_3
                ConcreteDict = arg_4
            }
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the SomeEnum type
[<AutoOpen>]
module SomeEnumJsonParseExtension =
    /// Extension methods for JSON parsing
    type SomeEnum with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : SomeEnum =
            match node.GetValueKind () with
            | System.Text.Json.JsonValueKind.Number -> node.AsValue().GetValue<int> () |> enum<SomeEnum>
            | System.Text.Json.JsonValueKind.String ->
                match node.AsValue().GetValue<string>().ToLowerInvariant () with
                | "blah" -> SomeEnum.Blah
                | "thing" -> SomeEnum.Thing
                | v -> failwith ("Unrecognised value for enum: %i" + v)
            | _ -> failwith ("Unrecognised kind for enum of type: " + "SomeEnum")
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the JsonRecordTypeWithBoth type
[<AutoOpen>]
module JsonRecordTypeWithBothJsonParseExtension =
    /// Extension methods for JSON parsing
    type JsonRecordTypeWithBoth with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : JsonRecordTypeWithBoth =
            let arg_21 =
                match node.["unit"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("unit")
                        )
                    )
                | Some node -> ()

            let arg_20 =
                match node.["timestamp"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("timestamp")
                        )
                    )
                | Some node -> node.AsValue().GetValue<string> () |> System.DateTimeOffset.Parse

            let arg_19 =
                match node.["enum"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("enum")
                        )
                    )
                | Some node -> SomeEnum.jsonParse node

            let arg_18 =
                match node.["intMeasureNullable"] |> Option.ofObj with
                | None -> System.Nullable ()
                | Some v ->
                    v.AsValue().GetValue<System.Int32> ()
                    |> LanguagePrimitives.Int32WithMeasure
                    |> System.Nullable

            let arg_17 =
                match node.["intMeasureOption"] |> Option.ofObj with
                | None -> None
                | Some v ->
                    v.AsValue().GetValue<System.Int32> ()
                    |> LanguagePrimitives.Int32WithMeasure
                    |> Some

            let arg_16 =
                match node.["single"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("single")
                        )
                    )
                | Some node ->
                    node.AsValue().GetValue<System.Single> ()
                    |> LanguagePrimitives.Float32WithMeasure

            let arg_15 =
                match node.["f32"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("f32")
                        )
                    )
                | Some node ->
                    node.AsValue().GetValue<System.Single> ()
                    |> LanguagePrimitives.Float32WithMeasure

            let arg_14 =
                match node.["f"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("f")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.Double> () |> LanguagePrimitives.FloatWithMeasure

            let arg_13 =
                match node.["u64"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("u64")
                        )
                    )
                | Some node ->
                    node.AsValue().GetValue<System.UInt64> ()
                    |> LanguagePrimitives.UInt64WithMeasure

            let arg_12 =
                match node.["u32"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("u32")
                        )
                    )
                | Some node ->
                    node.AsValue().GetValue<System.UInt32> ()
                    |> LanguagePrimitives.UInt32WithMeasure

            let arg_11 =
                match node.["u"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("u")
                        )
                    )
                | Some node ->
                    node.AsValue().GetValue<System.UInt32> ()
                    |> LanguagePrimitives.UInt32WithMeasure

            let arg_10 =
                match node.["i64"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("i64")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.Int64> () |> LanguagePrimitives.Int64WithMeasure

            let arg_9 =
                match node.["i32"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("i32")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.Int32> () |> LanguagePrimitives.Int32WithMeasure

            let arg_8 =
                match node.["i"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("i")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.Int32> () |> LanguagePrimitives.Int32WithMeasure

            let arg_7 =
                match node.["sbyte"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("sbyte")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.SByte> () |> LanguagePrimitives.SByteWithMeasure

            let arg_6 =
                match node.["byte"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("byte")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.Byte> () |> LanguagePrimitives.ByteWithMeasure

            let arg_5 =
                match node.["arr"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("arr")
                        )
                    )
                | Some node ->
                    node.AsArray ()
                    |> Seq.map (fun elt ->
                        (match elt with
                         | null -> raise (System.ArgumentNullException ())
                         | elt -> elt.AsValue().GetValue<System.Int32> ())
                    )
                    |> Array.ofSeq

            let arg_4 =
                match node.["e"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("e")
                        )
                    )
                | Some node ->
                    node.AsArray ()
                    |> Seq.map (fun elt ->
                        (match elt with
                         | null -> raise (System.ArgumentNullException ())
                         | elt -> elt.AsValue().GetValue<System.String> ())
                    )
                    |> Array.ofSeq

            let arg_3 =
                match node.["d"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("d")
                        )
                    )
                | Some node -> InnerTypeWithBoth.jsonParse node

            let arg_2 =
                match node.["c"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("c")
                        )
                    )
                | Some node ->
                    node.AsArray ()
                    |> Seq.map (fun elt ->
                        (match elt with
                         | null -> raise (System.ArgumentNullException ())
                         | elt -> elt.AsValue().GetValue<System.Int32> ())
                    )
                    |> List.ofSeq

            let arg_1 =
                match node.["b"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("b")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.String> ()

            let arg_0 =
                match node.["a"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("a")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.Int32> ()

            {
                A = arg_0
                B = arg_1
                C = arg_2
                D = arg_3
                E = arg_4
                Arr = arg_5
                Byte = arg_6
                Sbyte = arg_7
                I = arg_8
                I32 = arg_9
                I64 = arg_10
                U = arg_11
                U32 = arg_12
                U64 = arg_13
                F = arg_14
                F32 = arg_15
                Single = arg_16
                IntMeasureOption = arg_17
                IntMeasureNullable = arg_18
                Enum = arg_19
                Timestamp = arg_20
                Unit = arg_21
            }
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the FirstDu type
[<AutoOpen>]
module FirstDuJsonParseExtension =
    /// Extension methods for JSON parsing
    type FirstDu with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FirstDu =
            let ty =
                (match node.["type"] |> Option.ofObj with
                 | None ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("type")
                         )
                     )
                 | Some v -> v)
                |> (fun v -> v.GetValue<string> ())

            match ty with
            | "emptyCase" -> FirstDu.EmptyCase
            | "case1" ->
                let node =
                    (match node.["data"] |> Option.ofObj with
                     | None ->
                         raise (
                             System.Collections.Generic.KeyNotFoundException (
                                 sprintf "Required key '%s' not found on JSON object" ("data")
                             )
                         )
                     | Some v -> v)

                FirstDu.Case1 (
                    match node.["data"] |> Option.ofObj with
                    | None ->
                        raise (
                            System.Collections.Generic.KeyNotFoundException (
                                sprintf "Required key '%s' not found on JSON object" ("data")
                            )
                        )
                    | Some node -> node.AsValue().GetValue<System.String> ()
                )
            | "case2" ->
                let node =
                    (match node.["data"] |> Option.ofObj with
                     | None ->
                         raise (
                             System.Collections.Generic.KeyNotFoundException (
                                 sprintf "Required key '%s' not found on JSON object" ("data")
                             )
                         )
                     | Some v -> v)

                FirstDu.Case2 (
                    match node.["record"] |> Option.ofObj with
                    | None ->
                        raise (
                            System.Collections.Generic.KeyNotFoundException (
                                sprintf "Required key '%s' not found on JSON object" ("record")
                            )
                        )
                    | Some node -> JsonRecordTypeWithBoth.jsonParse node
                    , match node.["i"] |> Option.ofObj with
                      | None ->
                          raise (
                              System.Collections.Generic.KeyNotFoundException (
                                  sprintf "Required key '%s' not found on JSON object" ("i")
                              )
                          )
                      | Some node -> node.AsValue().GetValue<System.Int32> ()
                )
            | v -> failwith ("Unrecognised 'type' field value: " + v)
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the HeaderAndValue type
[<AutoOpen>]
module HeaderAndValueJsonParseExtension =
    /// Extension methods for JSON parsing
    type HeaderAndValue with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : HeaderAndValue =
            let arg_1 =
                match node.["value"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("value")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.String> ()

            let arg_0 =
                match node.["header"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("header")
                        )
                    )
                | Some node -> node.AsValue().GetValue<System.String> ()

            {
                Header = arg_0
                Value = arg_1
            }
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the Foo type
[<AutoOpen>]
module FooJsonParseExtension =
    /// Extension methods for JSON parsing
    type Foo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Foo =
            let arg_0 =
                match node.["message"] |> Option.ofObj with
                | None -> None
                | Some v -> HeaderAndValue.jsonParse v |> Some

            {
                Message = arg_0
            }
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the CollectRemaining type
[<AutoOpen>]
module CollectRemainingJsonParseExtension =
    /// Extension methods for JSON parsing
    type CollectRemaining with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CollectRemaining =
            let arg_1 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" then
                        ()
                    else
                        result.Add (
                            key,
                            match node.[key] |> Option.ofObj with
                            | None ->
                                raise (
                                    System.Collections.Generic.KeyNotFoundException (
                                        sprintf "Required key '%s' not found on JSON object" (key)
                                    )
                                )
                            | Some node -> node
                        )

                result

            let arg_0 =
                match node.["message"] |> Option.ofObj with
                | None -> None
                | Some v -> HeaderAndValue.jsonParse v |> Some

            {
                Message = arg_0
                Rest = arg_1
            }
namespace ConsumePlugin

/// Module containing JSON parsing extension members for the OuterCollectRemaining type
[<AutoOpen>]
module OuterCollectRemainingJsonParseExtension =
    /// Extension methods for JSON parsing
    type OuterCollectRemaining with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : OuterCollectRemaining =
            let arg_1 =
                match node.["remaining"] |> Option.ofObj with
                | None ->
                    raise (
                        System.Collections.Generic.KeyNotFoundException (
                            sprintf "Required key '%s' not found on JSON object" ("remaining")
                        )
                    )
                | Some node -> CollectRemaining.jsonParse node

            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, int> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "remaining" then
                        ()
                    else
                        result.Add (
                            key,
                            match node.[key] |> Option.ofObj with
                            | None ->
                                raise (
                                    System.Collections.Generic.KeyNotFoundException (
                                        sprintf "Required key '%s' not found on JSON object" (key)
                                    )
                                )
                            | Some node -> node.AsValue().GetValue<System.Int32> ()
                        )

                result

            {
                Others = arg_0
                Remaining = arg_1
            }
