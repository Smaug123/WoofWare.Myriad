//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------





namespace ConsumePlugin

open WoofWare.Myriad.Plugins

/// Description of how to combine cases during a fold
type FileSystemItemCataCase<'FileSystemItem> =
    /// How to operate on the Directory case
    abstract Directory : name : string -> dirSize : int -> contents : 'FileSystemItem list -> 'FileSystemItem
    /// How to operate on the File case
    abstract File : File -> 'FileSystemItem

/// Specifies how to perform a fold (catamorphism) over the type FileSystemItem and its friends.
type FileSystemCata<'FileSystemItem> =
    {
        /// How to perform a fold (catamorphism) over the type FileSystemItem
        FileSystemItem : FileSystemItemCataCase<'FileSystemItem>
    }

/// Methods to perform a catamorphism over the type FileSystemItem
[<RequireQualifiedAccess>]
module FileSystemItemCata =
    [<RequireQualifiedAccess>]
    type private Instruction =
        | Process__FileSystemItem of FileSystemItem
        | FileSystemItem_Directory of string * int * int

    let private loop (cata : FileSystemCata<_>) (instructions : ResizeArray<Instruction>) =
        let fileSystemItemStack = ResizeArray ()

        while instructions.Count > 0 do
            let currentInstruction = instructions.[instructions.Count - 1]
            instructions.RemoveAt (instructions.Count - 1)

            match currentInstruction with
            | Instruction.Process__FileSystemItem x ->
                match x with
                | FileSystemItem.Directory ({
                                                Name = name
                                                DirSize = dirSize
                                                Contents = contents
                                            }) ->
                    instructions.Add (Instruction.FileSystemItem_Directory (name, dirSize, (List.length contents)))

                    for elt in contents do
                        instructions.Add (Instruction.Process__FileSystemItem elt)
                | FileSystemItem.File (arg0_0) -> cata.FileSystemItem.File arg0_0 |> fileSystemItemStack.Add
            | Instruction.FileSystemItem_Directory (name, dirSize, contents) ->
                let contents_len = contents

                let contents =
                    seq {
                        for i = fileSystemItemStack.Count - 1 downto fileSystemItemStack.Count - contents do
                            yield fileSystemItemStack.[i]
                    }
                    |> Seq.toList

                fileSystemItemStack.RemoveRange (fileSystemItemStack.Count - contents_len, contents_len)
                cata.FileSystemItem.Directory name dirSize contents |> fileSystemItemStack.Add

        fileSystemItemStack

    /// Execute the catamorphism.
    let runFileSystemItem (cata : FileSystemCata<'FileSystemItemRet>) (x : FileSystemItem) : 'FileSystemItemRet =
        let instructions = ResizeArray ()
        instructions.Add (Instruction.Process__FileSystemItem x)
        let fileSystemItemRetStack = loop cata instructions
        Seq.exactlyOne fileSystemItemRetStack
namespace ConsumePlugin

open WoofWare.Myriad.Plugins

/// Description of how to combine cases during a fold
type GiftCataCase<'Gift> =
    /// How to operate on the Book case
    abstract Book : Book -> 'Gift
    /// How to operate on the Chocolate case
    abstract Chocolate : Chocolate -> 'Gift
    /// How to operate on the Wrapped case
    abstract Wrapped : 'Gift -> WrappingPaperStyle -> 'Gift
    /// How to operate on the Boxed case
    abstract Boxed : 'Gift -> 'Gift
    /// How to operate on the WithACard case
    abstract WithACard : 'Gift -> message : string -> 'Gift

/// Specifies how to perform a fold (catamorphism) over the type Gift and its friends.
type GiftCata<'Gift> =
    {
        /// How to perform a fold (catamorphism) over the type Gift
        Gift : GiftCataCase<'Gift>
    }

/// Methods to perform a catamorphism over the type Gift
[<RequireQualifiedAccess>]
module GiftCata =
    [<RequireQualifiedAccess>]
    type private Instruction =
        | Process__Gift of Gift
        | Gift_Wrapped of WrappingPaperStyle
        | Gift_Boxed
        | Gift_WithACard of string

    let private loop (cata : GiftCata<_>) (instructions : ResizeArray<Instruction>) =
        let giftStack = ResizeArray ()

        while instructions.Count > 0 do
            let currentInstruction = instructions.[instructions.Count - 1]
            instructions.RemoveAt (instructions.Count - 1)

            match currentInstruction with
            | Instruction.Process__Gift x ->
                match x with
                | Gift.Book (arg0_0) -> cata.Gift.Book arg0_0 |> giftStack.Add
                | Gift.Chocolate (arg0_0) -> cata.Gift.Chocolate arg0_0 |> giftStack.Add
                | Gift.Wrapped (arg0_0, arg1_0) ->
                    instructions.Add (Instruction.Gift_Wrapped (arg1_0))
                    instructions.Add (Instruction.Process__Gift arg0_0)
                | Gift.Boxed (arg0_0) ->
                    instructions.Add Instruction.Gift_Boxed
                    instructions.Add (Instruction.Process__Gift arg0_0)
                | Gift.WithACard (arg0_0, message) ->
                    instructions.Add (Instruction.Gift_WithACard (message))
                    instructions.Add (Instruction.Process__Gift arg0_0)
            | Instruction.Gift_Wrapped (arg1_0) ->
                let arg0_0 = giftStack.[giftStack.Count - 1]
                giftStack.RemoveAt (giftStack.Count - 1)
                cata.Gift.Wrapped arg0_0 arg1_0 |> giftStack.Add
            | Instruction.Gift_Boxed ->
                let arg0_0 = giftStack.[giftStack.Count - 1]
                giftStack.RemoveAt (giftStack.Count - 1)
                cata.Gift.Boxed arg0_0 |> giftStack.Add
            | Instruction.Gift_WithACard (message) ->
                let arg0_0 = giftStack.[giftStack.Count - 1]
                giftStack.RemoveAt (giftStack.Count - 1)
                cata.Gift.WithACard arg0_0 message |> giftStack.Add

        giftStack

    /// Execute the catamorphism.
    let runGift (cata : GiftCata<'GiftRet>) (x : Gift) : 'GiftRet =
        let instructions = ResizeArray ()
        instructions.Add (Instruction.Process__Gift x)
        let giftRetStack = loop cata instructions
        Seq.exactlyOne giftRetStack
namespace ConsumePlugin

open WoofWare.Myriad.Plugins

/// Description of how to combine cases during a fold
type MyListCataCase<'MyList> =
    /// How to operate on the Nil case
    abstract Nil : 'MyList
    /// How to operate on the Cons case
    abstract Cons : head : int -> tail : 'MyList -> 'MyList

/// Specifies how to perform a fold (catamorphism) over the type MyList and its friends.
type MyListCata<'MyList> =
    {
        /// How to perform a fold (catamorphism) over the type MyList
        MyList : MyListCataCase<'MyList>
    }

/// Methods to perform a catamorphism over the type MyList
[<RequireQualifiedAccess>]
module MyListCata =
    [<RequireQualifiedAccess>]
    type private Instruction =
        | Process__MyList of MyList
        | MyList_Cons of int

    let private loop (cata : MyListCata<_>) (instructions : ResizeArray<Instruction>) =
        let myListStack = ResizeArray ()

        while instructions.Count > 0 do
            let currentInstruction = instructions.[instructions.Count - 1]
            instructions.RemoveAt (instructions.Count - 1)

            match currentInstruction with
            | Instruction.Process__MyList x ->
                match x with
                | MyList.Nil -> cata.MyList.Nil |> myListStack.Add
                | MyList.Cons ({
                                   Head = head
                                   Tail = tail
                               }) ->
                    instructions.Add (Instruction.MyList_Cons (head))
                    instructions.Add (Instruction.Process__MyList tail)
            | Instruction.MyList_Cons (head) ->
                let tail = myListStack.[myListStack.Count - 1]
                myListStack.RemoveAt (myListStack.Count - 1)
                cata.MyList.Cons head tail |> myListStack.Add

        myListStack

    /// Execute the catamorphism.
    let runMyList (cata : MyListCata<'MyListRet>) (x : MyList) : 'MyListRet =
        let instructions = ResizeArray ()
        instructions.Add (Instruction.Process__MyList x)
        let myListRetStack = loop cata instructions
        Seq.exactlyOne myListRetStack
namespace ConsumePlugin

open WoofWare.Myriad.Plugins

/// Description of how to combine cases during a fold
type MyList2CataCase<'MyList2> =
    /// How to operate on the Nil case
    abstract Nil : 'MyList2
    /// How to operate on the Cons case
    abstract Cons : int -> 'MyList2 -> 'MyList2

/// Specifies how to perform a fold (catamorphism) over the type MyList2 and its friends.
type MyList2Cata<'MyList2> =
    {
        /// How to perform a fold (catamorphism) over the type MyList2
        MyList2 : MyList2CataCase<'MyList2>
    }

/// Methods to perform a catamorphism over the type MyList2
[<RequireQualifiedAccess>]
module MyList2Cata =
    [<RequireQualifiedAccess>]
    type private Instruction =
        | Process__MyList2 of MyList2
        | MyList2_Cons of int

    let private loop (cata : MyList2Cata<_>) (instructions : ResizeArray<Instruction>) =
        let myList2Stack = ResizeArray ()

        while instructions.Count > 0 do
            let currentInstruction = instructions.[instructions.Count - 1]
            instructions.RemoveAt (instructions.Count - 1)

            match currentInstruction with
            | Instruction.Process__MyList2 x ->
                match x with
                | MyList2.Nil -> cata.MyList2.Nil |> myList2Stack.Add
                | MyList2.Cons (arg0_0, arg1_0) ->
                    instructions.Add (Instruction.MyList2_Cons (arg0_0))
                    instructions.Add (Instruction.Process__MyList2 arg1_0)
            | Instruction.MyList2_Cons (arg0_0) ->
                let arg1_0 = myList2Stack.[myList2Stack.Count - 1]
                myList2Stack.RemoveAt (myList2Stack.Count - 1)
                cata.MyList2.Cons arg0_0 arg1_0 |> myList2Stack.Add

        myList2Stack

    /// Execute the catamorphism.
    let runMyList2 (cata : MyList2Cata<'MyList2Ret>) (x : MyList2) : 'MyList2Ret =
        let instructions = ResizeArray ()
        instructions.Add (Instruction.Process__MyList2 x)
        let myList2RetStack = loop cata instructions
        Seq.exactlyOne myList2RetStack
