//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------


namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the APIError type
[<AutoOpen>]
module APIErrorJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type APIError with

        /// Serialize to a JSON node
        static member toJsonNode (input : APIError) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AccessToken type
[<AutoOpen>]
module AccessTokenJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AccessToken with

        /// Serialize to a JSON node
        static member toJsonNode (input : AccessToken) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "scopes",
                    (input.Scopes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha1",
                    (input.Sha1
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "token_last_eight",
                    (input.TokenLastEight
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ActivityPub type
[<AutoOpen>]
module ActivityPubJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ActivityPub with

        /// Serialize to a JSON node
        static member toJsonNode (input : ActivityPub) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "@context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AddCollaboratorOption type
[<AutoOpen>]
module AddCollaboratorOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AddCollaboratorOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : AddCollaboratorOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AddTimeOption type
[<AutoOpen>]
module AddTimeOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AddTimeOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : AddTimeOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("time", (input.Time |> System.Text.Json.Nodes.JsonValue.Create<int>))

                node.Add (
                    "user_name",
                    (input.UserName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AnnotatedTagObject type
[<AutoOpen>]
module AnnotatedTagObjectJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTagObject with

        /// Serialize to a JSON node
        static member toJsonNode (input : AnnotatedTagObject) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Attachment type
[<AutoOpen>]
module AttachmentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Attachment with

        /// Serialize to a JSON node
        static member toJsonNode (input : Attachment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "browser_download_url",
                    (input.BrowserDownloadUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "download_count",
                    (input.DownloadCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "uuid",
                    (input.Uuid
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the BranchProtection type
[<AutoOpen>]
module BranchProtectionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type BranchProtection with

        /// Serialize to a JSON node
        static member toJsonNode (input : BranchProtection) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "approvals_whitelist_teams",
                    (input.ApprovalsWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "approvals_whitelist_username",
                    (input.ApprovalsWhitelistUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_official_review_requests",
                    (input.BlockOnOfficialReviewRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_outdated_branch",
                    (input.BlockOnOutdatedBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_rejected_reviews",
                    (input.BlockOnRejectedReviews
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branch_name",
                    (input.BranchName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismiss_stale_approvals",
                    (input.DismissStaleApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_approvals_whitelist",
                    (input.EnableApprovalsWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_merge_whitelist",
                    (input.EnableMergeWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_push",
                    (input.EnablePush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_push_whitelist",
                    (input.EnablePushWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_status_check",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_whitelist_teams",
                    (input.MergeWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_whitelist_usernames",
                    (input.MergeWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protected_file_patterns",
                    (input.ProtectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_deploy_keys",
                    (input.PushWhitelistDeployKeys
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_teams",
                    (input.PushWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_usernames",
                    (input.PushWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "require_signed_commits",
                    (input.RequireSignedCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "required_approvals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "rule_name",
                    (input.RuleName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status_check_contexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unprotected_file_patterns",
                    (input.UnprotectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ChangedFile type
[<AutoOpen>]
module ChangedFileJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ChangedFile with

        /// Serialize to a JSON node
        static member toJsonNode (input : ChangedFile) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "additions",
                    (input.Additions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "changes",
                    (input.Changes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "contents_url",
                    (input.ContentsUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "deletions",
                    (input.Deletions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "filename",
                    (input.Filename
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "previous_filename",
                    (input.PreviousFilename
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "raw_url",
                    (input.RawUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status",
                    (input.Status
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitAffectedFiles type
[<AutoOpen>]
module CommitAffectedFilesJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitAffectedFiles with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitAffectedFiles) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "filename",
                    (input.Filename
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitDateOptions type
[<AutoOpen>]
module CommitDateOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitDateOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitDateOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitMeta type
[<AutoOpen>]
module CommitMetaJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitMeta with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitMeta) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitStats type
[<AutoOpen>]
module CommitStatsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitStats with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitStats) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "additions",
                    (input.Additions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "deletions",
                    (input.Deletions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "total",
                    (input.Total
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitUser type
[<AutoOpen>]
module CommitUserJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitUser with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitUser) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "date",
                    (input.Date
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateAccessTokenOption type
[<AutoOpen>]
module CreateAccessTokenOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateAccessTokenOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateAccessTokenOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "scopes",
                    (input.Scopes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateBranchProtectionOption type
[<AutoOpen>]
module CreateBranchProtectionOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateBranchProtectionOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateBranchProtectionOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "approvals_whitelist_teams",
                    (input.ApprovalsWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "approvals_whitelist_username",
                    (input.ApprovalsWhitelistUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_official_review_requests",
                    (input.BlockOnOfficialReviewRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_outdated_branch",
                    (input.BlockOnOutdatedBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_rejected_reviews",
                    (input.BlockOnRejectedReviews
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branch_name",
                    (input.BranchName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismiss_stale_approvals",
                    (input.DismissStaleApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_approvals_whitelist",
                    (input.EnableApprovalsWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_merge_whitelist",
                    (input.EnableMergeWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_push",
                    (input.EnablePush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_push_whitelist",
                    (input.EnablePushWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_status_check",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_whitelist_teams",
                    (input.MergeWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_whitelist_usernames",
                    (input.MergeWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protected_file_patterns",
                    (input.ProtectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_deploy_keys",
                    (input.PushWhitelistDeployKeys
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_teams",
                    (input.PushWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_usernames",
                    (input.PushWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "require_signed_commits",
                    (input.RequireSignedCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "required_approvals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "rule_name",
                    (input.RuleName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status_check_contexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unprotected_file_patterns",
                    (input.UnprotectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateBranchRepoOption type
[<AutoOpen>]
module CreateBranchRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateBranchRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateBranchRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("new_branch_name", (input.NewBranchName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "old_branch_name",
                    (input.OldBranchName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateEmailOption type
[<AutoOpen>]
module CreateEmailOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateEmailOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateEmailOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "emails",
                    (input.Emails
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateForkOption type
[<AutoOpen>]
module CreateForkOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateForkOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateForkOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "organization",
                    (input.Organization
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateGPGKeyOption type
[<AutoOpen>]
module CreateGPGKeyOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateGPGKeyOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateGPGKeyOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "armored_public_key",
                    (input.ArmoredPublicKey |> System.Text.Json.Nodes.JsonValue.Create<string>)
                )

                node.Add (
                    "armored_signature",
                    (input.ArmoredSignature
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateHookOptionConfig type
[<AutoOpen>]
module CreateHookOptionConfigJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateHookOptionConfig with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateHookOptionConfig) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateIssueCommentOption type
[<AutoOpen>]
module CreateIssueCommentOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateIssueCommentOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateIssueCommentOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("body", (input.Body |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateIssueOption type
[<AutoOpen>]
module CreateIssueOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateIssueOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateIssueOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closed",
                    (input.Closed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("title", (input.Title |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateKeyOption type
[<AutoOpen>]
module CreateKeyOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateKeyOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateKeyOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("key", (input.Key |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "read_only",
                    (input.ReadOnly
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("title", (input.Title |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateLabelOption type
[<AutoOpen>]
module CreateLabelOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateLabelOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateLabelOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("color", (input.Color |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "exclusive",
                    (input.Exclusive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateMilestoneOption type
[<AutoOpen>]
module CreateMilestoneOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateMilestoneOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateMilestoneOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_on",
                    (input.DueOn
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateOAuth2ApplicationOptions type
[<AutoOpen>]
module CreateOAuth2ApplicationOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateOAuth2ApplicationOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateOAuth2ApplicationOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "confidential_client",
                    (input.ConfidentialClient
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "redirect_uris",
                    (input.RedirectUris
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateOrgOption type
[<AutoOpen>]
module CreateOrgOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateOrgOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateOrgOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_admin_change_team_access",
                    (input.RepoAdminChangeTeamAccess
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("username", (input.Username |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePullRequestOption type
[<AutoOpen>]
module CreatePullRequestOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePullRequestOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePullRequestOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "base",
                    (input.Base
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "head",
                    (input.Head
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePullReviewComment type
[<AutoOpen>]
module CreatePullReviewCommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewComment with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePullReviewComment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "new_position",
                    (input.NewPosition
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "old_position",
                    (input.OldPosition
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePushMirrorOption type
[<AutoOpen>]
module CreatePushMirrorOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePushMirrorOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePushMirrorOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "interval",
                    (input.Interval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remote_address",
                    (input.RemoteAddress
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remote_password",
                    (input.RemotePassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remote_username",
                    (input.RemoteUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sync_on_commit",
                    (input.SyncOnCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateReleaseOption type
[<AutoOpen>]
module CreateReleaseOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateReleaseOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateReleaseOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "draft",
                    (input.Draft
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prerelease",
                    (input.Prerelease
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("tag_name", (input.TagName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "target_commitish",
                    (input.TargetCommitish
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateRepoOption type
[<AutoOpen>]
module CreateRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "auto_init",
                    (input.AutoInit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_branch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "gitignores",
                    (input.Gitignores
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue_labels",
                    (input.IssueLabels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "license",
                    (input.License
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "readme",
                    (input.Readme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "template",
                    (input.Template
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "trust_model",
                    (input.TrustModel
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateStatusOption type
[<AutoOpen>]
module CreateStatusOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateStatusOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateStatusOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "target_url",
                    (input.TargetUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateTagOption type
[<AutoOpen>]
module CreateTagOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateTagOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateTagOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("tag_name", (input.TagName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "target",
                    (input.Target
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type1 type
[<AutoOpen>]
module Type1JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type1 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type1) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateTeamOption type
[<AutoOpen>]
module CreateTeamOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateTeamOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateTeamOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "can_create_org_repo",
                    (input.CanCreateOrgRepo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "includes_all_repositories",
                    (input.IncludesAllRepositories
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units",
                    (input.Units
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units_map",
                    (input.UnitsMap
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type1.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateUserOption type
[<AutoOpen>]
module CreateUserOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateUserOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateUserOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("email", (input.Email |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "login_name",
                    (input.LoginName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "must_change_password",
                    (input.MustChangePassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("password", (input.Password |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "restricted",
                    (input.Restricted
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "send_notify",
                    (input.SendNotify
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "source_id",
                    (input.SourceId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("username", (input.Username |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateWikiPageOptions type
[<AutoOpen>]
module CreateWikiPageOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateWikiPageOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateWikiPageOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content_base64",
                    (input.ContentBase64
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Cron type
[<AutoOpen>]
module CronJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Cron with

        /// Serialize to a JSON node
        static member toJsonNode (input : Cron) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "exec_times",
                    (input.ExecTimes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "next",
                    (input.Next
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prev",
                    (input.Prev
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "schedule",
                    (input.Schedule
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DeleteEmailOption type
[<AutoOpen>]
module DeleteEmailOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DeleteEmailOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : DeleteEmailOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "emails",
                    (input.Emails
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DismissPullReviewOptions type
[<AutoOpen>]
module DismissPullReviewOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DismissPullReviewOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : DismissPullReviewOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "priors",
                    (input.Priors
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditAttachmentOptions type
[<AutoOpen>]
module EditAttachmentOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditAttachmentOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditAttachmentOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditBranchProtectionOption type
[<AutoOpen>]
module EditBranchProtectionOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditBranchProtectionOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditBranchProtectionOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "approvals_whitelist_teams",
                    (input.ApprovalsWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "approvals_whitelist_username",
                    (input.ApprovalsWhitelistUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_official_review_requests",
                    (input.BlockOnOfficialReviewRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_outdated_branch",
                    (input.BlockOnOutdatedBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "block_on_rejected_reviews",
                    (input.BlockOnRejectedReviews
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismiss_stale_approvals",
                    (input.DismissStaleApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_approvals_whitelist",
                    (input.EnableApprovalsWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_merge_whitelist",
                    (input.EnableMergeWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_push",
                    (input.EnablePush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_push_whitelist",
                    (input.EnablePushWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_status_check",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_whitelist_teams",
                    (input.MergeWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_whitelist_usernames",
                    (input.MergeWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protected_file_patterns",
                    (input.ProtectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_deploy_keys",
                    (input.PushWhitelistDeployKeys
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_teams",
                    (input.PushWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push_whitelist_usernames",
                    (input.PushWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "require_signed_commits",
                    (input.RequireSignedCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "required_approvals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status_check_contexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unprotected_file_patterns",
                    (input.UnprotectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditDeadlineOption type
[<AutoOpen>]
module EditDeadlineOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditDeadlineOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditDeadlineOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("due_date", (input.DueDate |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditGitHookOption type
[<AutoOpen>]
module EditGitHookOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditGitHookOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditGitHookOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type2 type
[<AutoOpen>]
module Type2JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type2 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type2) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditHookOption type
[<AutoOpen>]
module EditHookOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditHookOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditHookOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authorization_header",
                    (input.AuthorizationHeader
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branch_filter",
                    (input.BranchFilter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "config",
                    (input.Config
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type2.toJsonNode field
                     ))
                )

                node.Add (
                    "events",
                    (input.Events
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditIssueCommentOption type
[<AutoOpen>]
module EditIssueCommentOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditIssueCommentOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditIssueCommentOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("body", (input.Body |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditIssueOption type
[<AutoOpen>]
module EditIssueOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditIssueOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditIssueOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unset_due_date",
                    (input.UnsetDueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditLabelOption type
[<AutoOpen>]
module EditLabelOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditLabelOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditLabelOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "color",
                    (input.Color
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "exclusive",
                    (input.Exclusive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditMilestoneOption type
[<AutoOpen>]
module EditMilestoneOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditMilestoneOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditMilestoneOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_on",
                    (input.DueOn
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditOrgOption type
[<AutoOpen>]
module EditOrgOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditOrgOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditOrgOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_admin_change_team_access",
                    (input.RepoAdminChangeTeamAccess
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditPullRequestOption type
[<AutoOpen>]
module EditPullRequestOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditPullRequestOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditPullRequestOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allow_maintainer_edit",
                    (input.AllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "base",
                    (input.Base
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unset_due_date",
                    (input.UnsetDueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditReactionOption type
[<AutoOpen>]
module EditReactionOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditReactionOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditReactionOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditReleaseOption type
[<AutoOpen>]
module EditReleaseOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditReleaseOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditReleaseOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "draft",
                    (input.Draft
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prerelease",
                    (input.Prerelease
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tag_name",
                    (input.TagName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "target_commitish",
                    (input.TargetCommitish
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type3 type
[<AutoOpen>]
module Type3JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type3 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type3) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditTeamOption type
[<AutoOpen>]
module EditTeamOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditTeamOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditTeamOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "can_create_org_repo",
                    (input.CanCreateOrgRepo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "includes_all_repositories",
                    (input.IncludesAllRepositories
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units",
                    (input.Units
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units_map",
                    (input.UnitsMap
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type3.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditUserOption type
[<AutoOpen>]
module EditUserOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditUserOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditUserOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "admin",
                    (input.Admin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_create_organization",
                    (input.AllowCreateOrganization
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_git_hook",
                    (input.AllowGitHook
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_import_local",
                    (input.AllowImportLocal
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("login_name", (input.LoginName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "max_repo_creation",
                    (input.MaxRepoCreation
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "must_change_password",
                    (input.MustChangePassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "password",
                    (input.Password
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prohibit_login",
                    (input.ProhibitLogin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "restricted",
                    (input.Restricted
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("source_id", (input.SourceId |> System.Text.Json.Nodes.JsonValue.Create<int>))

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Email type
[<AutoOpen>]
module EmailJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Email with

        /// Serialize to a JSON node
        static member toJsonNode (input : Email) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "primary",
                    (input.Primary
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verified",
                    (input.Verified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ExternalTracker type
[<AutoOpen>]
module ExternalTrackerJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ExternalTracker with

        /// Serialize to a JSON node
        static member toJsonNode (input : ExternalTracker) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "external_tracker_format",
                    (input.ExternalTrackerFormat
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "external_tracker_regexp_pattern",
                    (input.ExternalTrackerRegexpPattern
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "external_tracker_style",
                    (input.ExternalTrackerStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "external_tracker_url",
                    (input.ExternalTrackerUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ExternalWiki type
[<AutoOpen>]
module ExternalWikiJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ExternalWiki with

        /// Serialize to a JSON node
        static member toJsonNode (input : ExternalWiki) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "external_wiki_url",
                    (input.ExternalWikiUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileCommitResponse type
[<AutoOpen>]
module FileCommitResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileCommitResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileCommitResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "parents",
                    (input.Parents
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitMeta.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tree",
                    (input.Tree
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileLinksResponse type
[<AutoOpen>]
module FileLinksResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileLinksResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileLinksResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "git",
                    (input.Git
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html",
                    (input.Html
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "self",
                    (input.Self
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GPGKeyEmail type
[<AutoOpen>]
module GPGKeyEmailJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GPGKeyEmail with

        /// Serialize to a JSON node
        static member toJsonNode (input : GPGKeyEmail) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verified",
                    (input.Verified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralAPISettings type
[<AutoOpen>]
module GeneralAPISettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralAPISettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralAPISettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "default_git_trees_per_page",
                    (input.DefaultGitTreesPerPage
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_max_blob_size",
                    (input.DefaultMaxBlobSize
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_paging_num",
                    (input.DefaultPagingNum
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "max_response_items",
                    (input.MaxResponseItems
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralAttachmentSettings type
[<AutoOpen>]
module GeneralAttachmentSettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralAttachmentSettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralAttachmentSettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowed_types",
                    (input.AllowedTypes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enabled",
                    (input.Enabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "max_files",
                    (input.MaxFiles
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "max_size",
                    (input.MaxSize
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralRepoSettings type
[<AutoOpen>]
module GeneralRepoSettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralRepoSettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralRepoSettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "http_git_disabled",
                    (input.HttpGitDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lfs_disabled",
                    (input.LfsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "migrations_disabled",
                    (input.MigrationsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirrors_disabled",
                    (input.MirrorsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "stars_disabled",
                    (input.StarsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "time_tracking_disabled",
                    (input.TimeTrackingDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralUISettings type
[<AutoOpen>]
module GeneralUISettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralUISettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralUISettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowed_reactions",
                    (input.AllowedReactions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "custom_emojis",
                    (input.CustomEmojis
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_theme",
                    (input.DefaultTheme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GenerateRepoOption type
[<AutoOpen>]
module GenerateRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GenerateRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : GenerateRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "avatar",
                    (input.Avatar
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_branch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "git_content",
                    (input.GitContent
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "git_hooks",
                    (input.GitHooks
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))
                node.Add ("owner", (input.Owner |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "topics",
                    (input.Topics
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "webhooks",
                    (input.Webhooks
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitBlobResponse type
[<AutoOpen>]
module GitBlobResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitBlobResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitBlobResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "encoding",
                    (input.Encoding
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitEntry type
[<AutoOpen>]
module GitEntryJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitEntry with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitEntry) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "mode",
                    (input.Mode
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitHook type
[<AutoOpen>]
module GitHookJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitHook with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitHook) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "is_active",
                    (input.IsActive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitObject type
[<AutoOpen>]
module GitObjectJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitObject with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitObject) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitTreeResponse type
[<AutoOpen>]
module GitTreeResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitTreeResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitTreeResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "page",
                    (input.Page
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "total_count",
                    (input.TotalCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tree",
                    (input.Tree
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (GitEntry.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "truncated",
                    (input.Truncated
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type4 type
[<AutoOpen>]
module Type4JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type4 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type4) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Hook type
[<AutoOpen>]
module HookJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Hook with

        /// Serialize to a JSON node
        static member toJsonNode (input : Hook) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authorization_header",
                    (input.AuthorizationHeader
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "config",
                    (input.Config
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type4.toJsonNode field
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "events",
                    (input.Events
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Identity type
[<AutoOpen>]
module IdentityJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Identity with

        /// Serialize to a JSON node
        static member toJsonNode (input : Identity) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the InternalTracker type
[<AutoOpen>]
module InternalTrackerJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type InternalTracker with

        /// Serialize to a JSON node
        static member toJsonNode (input : InternalTracker) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allow_only_contributors_to_track_time",
                    (input.AllowOnlyContributorsToTrackTime
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_issue_dependencies",
                    (input.EnableIssueDependencies
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_time_tracker",
                    (input.EnableTimeTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueDeadline type
[<AutoOpen>]
module IssueDeadlineJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueDeadline with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueDeadline) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type5 type
[<AutoOpen>]
module Type5JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type5 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type5) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, (fun value -> System.Text.Json.Nodes.JsonObject ()) value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type6 type
[<AutoOpen>]
module Type6JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type6 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type6) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, (fun value -> System.Text.Json.Nodes.JsonObject ()) value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueLabelsOption type
[<AutoOpen>]
module IssueLabelsOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueLabelsOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueLabelsOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Label type
[<AutoOpen>]
module LabelJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Label with

        /// Serialize to a JSON node
        static member toJsonNode (input : Label) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "color",
                    (input.Color
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "exclusive",
                    (input.Exclusive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the MarkdownOption type
[<AutoOpen>]
module MarkdownOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type MarkdownOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : MarkdownOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "Context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "Mode",
                    (input.Mode
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "Text",
                    (input.Text
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "Wiki",
                    (input.Wiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the MergePullRequestOption type
[<AutoOpen>]
module MergePullRequestOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type MergePullRequestOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : MergePullRequestOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("Do", (input.Do |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "MergeCommitID",
                    (input.MergeCommitID
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "MergeMessageField",
                    (input.MergeMessageField
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "MergeTitleField",
                    (input.MergeTitleField
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "delete_branch_after_merge",
                    (input.DeleteBranchAfterMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "force_merge",
                    (input.ForceMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "head_commit_id",
                    (input.HeadCommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_when_checks_succeed",
                    (input.MergeWhenChecksSucceed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the MigrateRepoOptions type
[<AutoOpen>]
module MigrateRepoOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type MigrateRepoOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : MigrateRepoOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "auth_password",
                    (input.AuthPassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "auth_token",
                    (input.AuthToken
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "auth_username",
                    (input.AuthUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("clone_addr", (input.CloneAddr |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issues",
                    (input.Issues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lfs",
                    (input.Lfs
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lfs_endpoint",
                    (input.LfsEndpoint
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestones",
                    (input.Milestones
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror",
                    (input.Mirror
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror_interval",
                    (input.MirrorInterval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_requests",
                    (input.PullRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "releases",
                    (input.Releases
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("repo_name", (input.RepoName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "repo_owner",
                    (input.RepoOwner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "service",
                    (input.Service
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "uid",
                    (input.Uid
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "wiki",
                    (input.Wiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type7 type
[<AutoOpen>]
module Type7JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type7 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type7) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoServices type
[<AutoOpen>]
module NodeInfoServicesJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoServices with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoServices) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "inbound",
                    (input.Inbound
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "outbound",
                    (input.Outbound
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoSoftware type
[<AutoOpen>]
module NodeInfoSoftwareJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoSoftware with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoSoftware) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "homepage",
                    (input.Homepage
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoUsageUsers type
[<AutoOpen>]
module NodeInfoUsageUsersJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsageUsers with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoUsageUsers) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "activeHalfyear",
                    (input.ActiveHalfyear
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "activeMonth",
                    (input.ActiveMonth
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "total",
                    (input.Total
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NotificationCount type
[<AutoOpen>]
module NotificationCountJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NotificationCount with

        /// Serialize to a JSON node
        static member toJsonNode (input : NotificationCount) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "new",
                    (input.New
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the OAuth2Application type
[<AutoOpen>]
module OAuth2ApplicationJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type OAuth2Application with

        /// Serialize to a JSON node
        static member toJsonNode (input : OAuth2Application) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "client_id",
                    (input.ClientId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "client_secret",
                    (input.ClientSecret
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "confidential_client",
                    (input.ConfidentialClient
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "redirect_uris",
                    (input.RedirectUris
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Organization type
[<AutoOpen>]
module OrganizationJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Organization with

        /// Serialize to a JSON node
        static member toJsonNode (input : Organization) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "avatar_url",
                    (input.AvatarUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_admin_change_team_access",
                    (input.RepoAdminChangeTeamAccess
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "username",
                    (input.Username
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the OrganizationPermissions type
[<AutoOpen>]
module OrganizationPermissionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type OrganizationPermissions with

        /// Serialize to a JSON node
        static member toJsonNode (input : OrganizationPermissions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "can_create_repository",
                    (input.CanCreateRepository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "can_read",
                    (input.CanRead
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "can_write",
                    (input.CanWrite
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "is_admin",
                    (input.IsAdmin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "is_owner",
                    (input.IsOwner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PackageFile type
[<AutoOpen>]
module PackageFileJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PackageFile with

        /// Serialize to a JSON node
        static member toJsonNode (input : PackageFile) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "Size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "md5",
                    (input.Md5
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha1",
                    (input.Sha1
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha256",
                    (input.Sha256
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha512",
                    (input.Sha512
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PayloadUser type
[<AutoOpen>]
module PayloadUserJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PayloadUser with

        /// Serialize to a JSON node
        static member toJsonNode (input : PayloadUser) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "username",
                    (input.Username
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Permission type
[<AutoOpen>]
module PermissionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Permission with

        /// Serialize to a JSON node
        static member toJsonNode (input : Permission) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "admin",
                    (input.Admin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull",
                    (input.Pull
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push",
                    (input.Push
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullRequestMeta type
[<AutoOpen>]
module PullRequestMetaJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullRequestMeta with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullRequestMeta) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "merged",
                    (input.Merged
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merged_at",
                    (input.MergedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullReviewRequestOptions type
[<AutoOpen>]
module PullReviewRequestOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullReviewRequestOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullReviewRequestOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "reviewers",
                    (input.Reviewers
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "team_reviewers",
                    (input.TeamReviewers
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PushMirror type
[<AutoOpen>]
module PushMirrorJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PushMirror with

        /// Serialize to a JSON node
        static member toJsonNode (input : PushMirror) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "interval",
                    (input.Interval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "last_error",
                    (input.LastError
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "last_update",
                    (input.LastUpdate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remote_address",
                    (input.RemoteAddress
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remote_name",
                    (input.RemoteName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_name",
                    (input.RepoName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sync_on_commit",
                    (input.SyncOnCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Reference type
[<AutoOpen>]
module ReferenceJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Reference with

        /// Serialize to a JSON node
        static member toJsonNode (input : Reference) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "object",
                    (input.Object
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> GitObject.toJsonNode field
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoTopicOptions type
[<AutoOpen>]
module RepoTopicOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoTopicOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoTopicOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "topics",
                    (input.Topics
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepositoryMeta type
[<AutoOpen>]
module RepositoryMetaJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepositoryMeta with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepositoryMeta) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "owner",
                    (input.Owner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ServerVersion type
[<AutoOpen>]
module ServerVersionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ServerVersion with

        /// Serialize to a JSON node
        static member toJsonNode (input : ServerVersion) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the StopWatch type
[<AutoOpen>]
module StopWatchJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type StopWatch with

        /// Serialize to a JSON node
        static member toJsonNode (input : StopWatch) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "duration",
                    (input.Duration
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue_index",
                    (input.IssueIndex
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue_title",
                    (input.IssueTitle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_name",
                    (input.RepoName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_owner_name",
                    (input.RepoOwnerName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "seconds",
                    (input.Seconds
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the SubmitPullReviewOptions type
[<AutoOpen>]
module SubmitPullReviewOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type SubmitPullReviewOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : SubmitPullReviewOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "event",
                    (input.Event
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Tag type
[<AutoOpen>]
module TagJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Tag with

        /// Serialize to a JSON node
        static member toJsonNode (input : Tag) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tarball_url",
                    (input.TarballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "zipball_url",
                    (input.ZipballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type8 type
[<AutoOpen>]
module Type8JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type8 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type8) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Team type
[<AutoOpen>]
module TeamJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Team with

        /// Serialize to a JSON node
        static member toJsonNode (input : Team) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "can_create_org_repo",
                    (input.CanCreateOrgRepo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "includes_all_repositories",
                    (input.IncludesAllRepositories
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "organization",
                    (input.Organization
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Organization.toJsonNode field
                     ))
                )

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units",
                    (input.Units
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units_map",
                    (input.UnitsMap
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type8.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TopicName type
[<AutoOpen>]
module TopicNameJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TopicName with

        /// Serialize to a JSON node
        static member toJsonNode (input : TopicName) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "topics",
                    (input.Topics
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TopicResponse type
[<AutoOpen>]
module TopicResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TopicResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : TopicResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_count",
                    (input.RepoCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "topic_name",
                    (input.TopicName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated",
                    (input.Updated
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TransferRepoOption type
[<AutoOpen>]
module TransferRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TransferRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : TransferRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("new_owner", (input.NewOwner |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "team_ids",
                    (input.TeamIds
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UpdateFileOptions type
[<AutoOpen>]
module UpdateFileOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UpdateFileOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : UpdateFileOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "branch",
                    (input.Branch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add ("content", (input.Content |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "dates",
                    (input.Dates
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitDateOptions.toJsonNode field
                     ))
                )

                node.Add (
                    "from_path",
                    (input.FromPath
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "new_branch",
                    (input.NewBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("sha", (input.Sha |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "signoff",
                    (input.Signoff
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the User type
[<AutoOpen>]
module UserJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type User with

        /// Serialize to a JSON node
        static member toJsonNode (input : User) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "avatar_url",
                    (input.AvatarUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "followers_count",
                    (input.FollowersCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "following_count",
                    (input.FollowingCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "is_admin",
                    (input.IsAdmin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "last_login",
                    (input.LastLogin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "login",
                    (input.Login
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "login_name",
                    (input.LoginName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prohibit_login",
                    (input.ProhibitLogin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "restricted",
                    (input.Restricted
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "starred_repos_count",
                    (input.StarredReposCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UserHeatmapData type
[<AutoOpen>]
module UserHeatmapDataJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UserHeatmapData with

        /// Serialize to a JSON node
        static member toJsonNode (input : UserHeatmapData) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "contributions",
                    (input.Contributions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "timestamp",
                    (input.Timestamp
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UserSettings type
[<AutoOpen>]
module UserSettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UserSettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : UserSettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "diff_view_style",
                    (input.DiffViewStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hide_activity",
                    (input.HideActivity
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hide_email",
                    (input.HideEmail
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "theme",
                    (input.Theme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UserSettingsOptions type
[<AutoOpen>]
module UserSettingsOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UserSettingsOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : UserSettingsOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "diff_view_style",
                    (input.DiffViewStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hide_activity",
                    (input.HideActivity
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hide_email",
                    (input.HideEmail
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "theme",
                    (input.Theme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WatchInfo type
[<AutoOpen>]
module WatchInfoJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WatchInfo with

        /// Serialize to a JSON node
        static member toJsonNode (input : WatchInfo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ignored",
                    (input.Ignored
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "reason",
                    (input.Reason
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun value -> System.Text.Json.Nodes.JsonObject ()) field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository_url",
                    (input.RepositoryUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "subscribed",
                    (input.Subscribed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiCommit type
[<AutoOpen>]
module WikiCommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiCommit with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiCommit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "commiter",
                    (input.Commiter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiCommitList type
[<AutoOpen>]
module WikiCommitListJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiCommitList with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiCommitList) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commits",
                    (input.Commits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (WikiCommit.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "count",
                    (input.Count
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiPage type
[<AutoOpen>]
module WikiPageJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiPage with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiPage) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit_count",
                    (input.CommitCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "content_base64",
                    (input.ContentBase64
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "footer",
                    (input.Footer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "last_commit",
                    (input.LastCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> WikiCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "sidebar",
                    (input.Sidebar
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sub_url",
                    (input.SubUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiPageMetaData type
[<AutoOpen>]
module WikiPageMetaDataJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiPageMetaData with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiPageMetaData) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "last_commit",
                    (input.LastCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> WikiCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "sub_url",
                    (input.SubUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Comment type
[<AutoOpen>]
module CommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Comment with

        /// Serialize to a JSON node
        static member toJsonNode (input : Comment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assets",
                    (input.Assets
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Attachment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue_url",
                    (input.IssueUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_author",
                    (input.OriginalAuthor
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_author_id",
                    (input.OriginalAuthorId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_request_url",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitStatus type
[<AutoOpen>]
module CommitStatusJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitStatus with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitStatus) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "creator",
                    (input.Creator
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status",
                    (input.Status
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "target_url",
                    (input.TargetUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ContentsResponse type
[<AutoOpen>]
module ContentsResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ContentsResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : ContentsResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "_links",
                    (input.Links
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> FileLinksResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "download_url",
                    (input.DownloadUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "encoding",
                    (input.Encoding
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "git_url",
                    (input.GitUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "last_commit_sha",
                    (input.LastCommitSha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "submodule_git_url",
                    (input.SubmoduleGitUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "target",
                    (input.Target
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateFileOptions type
[<AutoOpen>]
module CreateFileOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateFileOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateFileOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "branch",
                    (input.Branch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add ("content", (input.Content |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "dates",
                    (input.Dates
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitDateOptions.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "new_branch",
                    (input.NewBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "signoff",
                    (input.Signoff
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateHookOption type
[<AutoOpen>]
module CreateHookOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateHookOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateHookOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authorization_header",
                    (input.AuthorizationHeader
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branch_filter",
                    (input.BranchFilter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("config", (input.Config |> CreateHookOptionConfig.toJsonNode))

                node.Add (
                    "events",
                    (input.Events
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("type", (input.Type |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePullReviewOptions type
[<AutoOpen>]
module CreatePullReviewOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePullReviewOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments",
                    (input.Comments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CreatePullReviewComment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commit_id",
                    (input.CommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "event",
                    (input.Event
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DeleteFileOptions type
[<AutoOpen>]
module DeleteFileOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DeleteFileOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : DeleteFileOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "branch",
                    (input.Branch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "dates",
                    (input.Dates
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitDateOptions.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "new_branch",
                    (input.NewBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("sha", (input.Sha |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "signoff",
                    (input.Signoff
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditRepoOption type
[<AutoOpen>]
module EditRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allow_manual_merge",
                    (input.AllowManualMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_merge_commits",
                    (input.AllowMergeCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_rebase",
                    (input.AllowRebase
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_rebase_explicit",
                    (input.AllowRebaseExplicit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_rebase_update",
                    (input.AllowRebaseUpdate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_squash_merge",
                    (input.AllowSquashMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "archived",
                    (input.Archived
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "autodetect_manual_merge",
                    (input.AutodetectManualMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_allow_maintainer_edit",
                    (input.DefaultAllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_branch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_delete_branch_after_merge",
                    (input.DefaultDeleteBranchAfterMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_merge_style",
                    (input.DefaultMergeStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_prune",
                    (input.EnablePrune
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "external_tracker",
                    (input.ExternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "external_wiki",
                    (input.ExternalWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalWiki.toJsonNode field
                     ))
                )

                node.Add (
                    "has_issues",
                    (input.HasIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_projects",
                    (input.HasProjects
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_pull_requests",
                    (input.HasPullRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_wiki",
                    (input.HasWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ignore_whitespace_conflicts",
                    (input.IgnoreWhitespaceConflicts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "internal_tracker",
                    (input.InternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> InternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "mirror_interval",
                    (input.MirrorInterval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "template",
                    (input.Template
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueFormField type
[<AutoOpen>]
module IssueFormFieldJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueFormField with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueFormField) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "attributes",
                    (input.Attributes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type5.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "validations",
                    (input.Validations
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type6.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueTemplate type
[<AutoOpen>]
module IssueTemplateJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueTemplate with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueTemplate) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "about",
                    (input.About
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (IssueFormField.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "file_name",
                    (input.FileName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Milestone type
[<AutoOpen>]
module MilestoneJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Milestone with

        /// Serialize to a JSON node
        static member toJsonNode (input : Milestone) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "closed_at",
                    (input.ClosedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closed_issues",
                    (input.ClosedIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_on",
                    (input.DueOn
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "open_issues",
                    (input.OpenIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoUsage type
[<AutoOpen>]
module NodeInfoUsageJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsage with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoUsage) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "localComments",
                    (input.LocalComments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "localPosts",
                    (input.LocalPosts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "users",
                    (input.Users
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoUsageUsers.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NotificationSubject type
[<AutoOpen>]
module NotificationSubjectJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NotificationSubject with

        /// Serialize to a JSON node
        static member toJsonNode (input : NotificationSubject) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "latest_comment_html_url",
                    (input.LatestCommentHtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "latest_comment_url",
                    (input.LatestCommentUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PayloadCommitVerification type
[<AutoOpen>]
module PayloadCommitVerificationJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PayloadCommitVerification with

        /// Serialize to a JSON node
        static member toJsonNode (input : PayloadCommitVerification) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "payload",
                    (input.Payload
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "reason",
                    (input.Reason
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "signature",
                    (input.Signature
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "signer",
                    (input.Signer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadUser.toJsonNode field
                     ))
                )

                node.Add (
                    "verified",
                    (input.Verified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PublicKey type
[<AutoOpen>]
module PublicKeyJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PublicKey with

        /// Serialize to a JSON node
        static member toJsonNode (input : PublicKey) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fingerprint",
                    (input.Fingerprint
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "key",
                    (input.Key
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "key_type",
                    (input.KeyType
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "read_only",
                    (input.ReadOnly
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullReview type
[<AutoOpen>]
module PullReviewJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullReview with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullReview) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments_count",
                    (input.CommentsCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commit_id",
                    (input.CommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismissed",
                    (input.Dismissed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "official",
                    (input.Official
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_request_url",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "stale",
                    (input.Stale
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "submitted_at",
                    (input.SubmittedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "team",
                    (input.Team
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Team.toJsonNode field
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullReviewComment type
[<AutoOpen>]
module PullReviewCommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullReviewComment with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullReviewComment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commit_id",
                    (input.CommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "diff_hunk",
                    (input.DiffHunk
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_commit_id",
                    (input.OriginalCommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_position",
                    (input.OriginalPosition
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "position",
                    (input.Position
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_request_review_id",
                    (input.PullRequestReviewId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_request_url",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "resolver",
                    (input.Resolver
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Reaction type
[<AutoOpen>]
module ReactionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Reaction with

        /// Serialize to a JSON node
        static member toJsonNode (input : Reaction) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Release type
[<AutoOpen>]
module ReleaseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Release with

        /// Serialize to a JSON node
        static member toJsonNode (input : Release) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assets",
                    (input.Assets
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Attachment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "draft",
                    (input.Draft
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prerelease",
                    (input.Prerelease
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "published_at",
                    (input.PublishedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tag_name",
                    (input.TagName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tarball_url",
                    (input.TarballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "target_commitish",
                    (input.TargetCommitish
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "zipball_url",
                    (input.ZipballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoCollaboratorPermission type
[<AutoOpen>]
module RepoCollaboratorPermissionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoCollaboratorPermission with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoCollaboratorPermission) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "role_name",
                    (input.RoleName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoCommit type
[<AutoOpen>]
module RepoCommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoCommit with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoCommit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tree",
                    (input.Tree
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoTransfer type
[<AutoOpen>]
module RepoTransferJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoTransfer with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoTransfer) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "doer",
                    (input.Doer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "recipient",
                    (input.Recipient
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "teams",
                    (input.Teams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Team.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Repository type
[<AutoOpen>]
module RepositoryJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Repository with

        /// Serialize to a JSON node
        static member toJsonNode (input : Repository) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allow_merge_commits",
                    (input.AllowMergeCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_rebase",
                    (input.AllowRebase
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_rebase_explicit",
                    (input.AllowRebaseExplicit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_rebase_update",
                    (input.AllowRebaseUpdate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allow_squash_merge",
                    (input.AllowSquashMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "archived",
                    (input.Archived
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "avatar_url",
                    (input.AvatarUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "clone_url",
                    (input.CloneUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_allow_maintainer_edit",
                    (input.DefaultAllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_branch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_delete_branch_after_merge",
                    (input.DefaultDeleteBranchAfterMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "default_merge_style",
                    (input.DefaultMergeStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "description",
                    (input.Description
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "empty",
                    (input.Empty
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "external_tracker",
                    (input.ExternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "external_wiki",
                    (input.ExternalWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalWiki.toJsonNode field
                     ))
                )

                node.Add (
                    "fork",
                    (input.Fork
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "forks_count",
                    (input.ForksCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "full_name",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_issues",
                    (input.HasIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_projects",
                    (input.HasProjects
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_pull_requests",
                    (input.HasPullRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "has_wiki",
                    (input.HasWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ignore_whitespace_conflicts",
                    (input.IgnoreWhitespaceConflicts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "internal",
                    (input.Internal
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "internal_tracker",
                    (input.InternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> InternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "languages_url",
                    (input.LanguagesUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "link",
                    (input.Link
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror",
                    (input.Mirror
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror_interval",
                    (input.MirrorInterval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror_updated",
                    (input.MirrorUpdated
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "open_issues_count",
                    (input.OpenIssuesCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "open_pr_counter",
                    (input.OpenPrCounter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_url",
                    (input.OriginalUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "owner",
                    (input.Owner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "parent",
                    (input.Parent
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "permissions",
                    (input.Permissions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Permission.toJsonNode field
                     ))
                )

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "release_counter",
                    (input.ReleaseCounter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo_transfer",
                    (input.RepoTransfer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> RepoTransfer.toJsonNode field
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ssh_url",
                    (input.SshUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "stars_count",
                    (input.StarsCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "template",
                    (input.Template
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "watchers_count",
                    (input.WatchersCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the SearchResults type
[<AutoOpen>]
module SearchResultsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type SearchResults with

        /// Serialize to a JSON node
        static member toJsonNode (input : SearchResults) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "data",
                    (input.Data
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Repository.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ok",
                    (input.Ok
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AnnotatedTag type
[<AutoOpen>]
module AnnotatedTagJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTag with

        /// Serialize to a JSON node
        static member toJsonNode (input : AnnotatedTag) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "object",
                    (input.Object
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> AnnotatedTagObject.toJsonNode field
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tag",
                    (input.Tag
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tagger",
                    (input.Tagger
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CombinedStatus type
[<AutoOpen>]
module CombinedStatusJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CombinedStatus with

        /// Serialize to a JSON node
        static member toJsonNode (input : CombinedStatus) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit_url",
                    (input.CommitUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "statuses",
                    (input.Statuses
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitStatus.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "total_count",
                    (input.TotalCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Commit type
[<AutoOpen>]
module CommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Commit with

        /// Serialize to a JSON node
        static member toJsonNode (input : Commit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> RepoCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "files",
                    (input.Files
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitAffectedFiles.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "parents",
                    (input.Parents
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitMeta.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "stats",
                    (input.Stats
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitStats.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DeployKey type
[<AutoOpen>]
module DeployKeyJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DeployKey with

        /// Serialize to a JSON node
        static member toJsonNode (input : DeployKey) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fingerprint",
                    (input.Fingerprint
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "key",
                    (input.Key
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "key_id",
                    (input.KeyId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "read_only",
                    (input.ReadOnly
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileDeleteResponse type
[<AutoOpen>]
module FileDeleteResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileDeleteResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileDeleteResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> FileCommitResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun value -> System.Text.Json.Nodes.JsonObject ()) field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileResponse type
[<AutoOpen>]
module FileResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> FileCommitResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ContentsResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Issue type
[<AutoOpen>]
module IssueJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Issue with

        /// Serialize to a JSON node
        static member toJsonNode (input : Issue) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assets",
                    (input.Assets
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Attachment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (User.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closed_at",
                    (input.ClosedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments",
                    (input.Comments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "is_locked",
                    (input.IsLocked
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Label.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "number",
                    (input.Number
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_author",
                    (input.OriginalAuthor
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "original_author_id",
                    (input.OriginalAuthorId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_request",
                    (input.PullRequest
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PullRequestMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> RepositoryMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfo type
[<AutoOpen>]
module NodeInfoJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfo with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "metadata",
                    (input.Metadata
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type7.toJsonNode field
                     ))
                )

                node.Add (
                    "openRegistrations",
                    (input.OpenRegistrations
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protocols",
                    (input.Protocols
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "services",
                    (input.Services
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoServices.toJsonNode field
                     ))
                )

                node.Add (
                    "software",
                    (input.Software
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoSoftware.toJsonNode field
                     ))
                )

                node.Add (
                    "usage",
                    (input.Usage
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoUsage.toJsonNode field
                     ))
                )

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Note type
[<AutoOpen>]
module NoteJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Note with

        /// Serialize to a JSON node
        static member toJsonNode (input : Note) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Commit.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NotificationThread type
[<AutoOpen>]
module NotificationThreadJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NotificationThread with

        /// Serialize to a JSON node
        static member toJsonNode (input : NotificationThread) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pinned",
                    (input.Pinned
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "subject",
                    (input.Subject
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NotificationSubject.toJsonNode field
                     ))
                )

                node.Add (
                    "unread",
                    (input.Unread
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PRBranchInfo type
[<AutoOpen>]
module PRBranchInfoJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PRBranchInfo with

        /// Serialize to a JSON node
        static member toJsonNode (input : PRBranchInfo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "label",
                    (input.Label
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo",
                    (input.Repo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "repo_id",
                    (input.RepoId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Package type
[<AutoOpen>]
module PackageJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Package with

        /// Serialize to a JSON node
        static member toJsonNode (input : Package) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "creator",
                    (input.Creator
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "owner",
                    (input.Owner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PayloadCommit type
[<AutoOpen>]
module PayloadCommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PayloadCommit with

        /// Serialize to a JSON node
        static member toJsonNode (input : PayloadCommit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "added",
                    (input.Added
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadUser.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadUser.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "modified",
                    (input.Modified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "removed",
                    (input.Removed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "timestamp",
                    (input.Timestamp
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullRequest type
[<AutoOpen>]
module PullRequestJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullRequest with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullRequest) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allow_maintainer_edit",
                    (input.AllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (User.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "base",
                    (input.Base
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PRBranchInfo.toJsonNode field
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closed_at",
                    (input.ClosedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments",
                    (input.Comments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "diff_url",
                    (input.DiffUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "due_date",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "head",
                    (input.Head
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PRBranchInfo.toJsonNode field
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "is_locked",
                    (input.IsLocked
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Label.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_base",
                    (input.MergeBase
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merge_commit_sha",
                    (input.MergeCommitSha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeable",
                    (input.Mergeable
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merged",
                    (input.Merged
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merged_at",
                    (input.MergedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merged_by",
                    (input.MergedBy
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "number",
                    (input.Number
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "patch_url",
                    (input.PatchUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TrackedTime type
[<AutoOpen>]
module TrackedTimeJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TrackedTime with

        /// Serialize to a JSON node
        static member toJsonNode (input : TrackedTime) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue",
                    (input.Issue
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Issue.toJsonNode field
                     ))
                )

                node.Add (
                    "issue_id",
                    (input.IssueId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "time",
                    (input.Time
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user_id",
                    (input.UserId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user_name",
                    (input.UserName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Branch type
[<AutoOpen>]
module BranchJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Branch with

        /// Serialize to a JSON node
        static member toJsonNode (input : Branch) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "effective_branch_protection_name",
                    (input.EffectiveBranchProtectionName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enable_status_check",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protected",
                    (input.Protected
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "required_approvals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status_check_contexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user_can_merge",
                    (input.UserCanMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user_can_push",
                    (input.UserCanPush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TimelineComment type
[<AutoOpen>]
module TimelineCommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TimelineComment with

        /// Serialize to a JSON node
        static member toJsonNode (input : TimelineComment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "assignee_team",
                    (input.AssigneeTeam
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Team.toJsonNode field
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created_at",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dependent_issue",
                    (input.DependentIssue
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Issue.toJsonNode field
                     ))
                )

                node.Add (
                    "html_url",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue_url",
                    (input.IssueUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "label",
                    (input.Label
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Label.toJsonNode field
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "new_ref",
                    (input.NewRef
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "new_title",
                    (input.NewTitle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "old_milestone",
                    (input.OldMilestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "old_project_id",
                    (input.OldProjectId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "old_ref",
                    (input.OldRef
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "old_title",
                    (input.OldTitle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "project_id",
                    (input.ProjectId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull_request_url",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref_action",
                    (input.RefAction
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref_comment",
                    (input.RefComment
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Comment.toJsonNode field
                     ))
                )

                node.Add (
                    "ref_commit_sha",
                    (input.RefCommitSha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref_issue",
                    (input.RefIssue
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Issue.toJsonNode field
                     ))
                )

                node.Add (
                    "removed_assignee",
                    (input.RemovedAssignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "resolve_doer",
                    (input.ResolveDoer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "review_id",
                    (input.ReviewId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tracked_time",
                    (input.TrackedTime
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> TrackedTime.toJsonNode field
                     ))
                )

                node.Add (
                    "type",
                    (input.Type
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated_at",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the LanguageStatistics type
[<AutoOpen>]
module LanguageStatisticsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type LanguageStatistics with

        /// Serialize to a JSON node
        static member toJsonNode (input : LanguageStatistics) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<int> value)

            node :> _

namespace Gitea

/// Module containing JSON parsing extension members for the APIError type
[<AutoOpen>]
module APIErrorJsonParseExtension =
    /// Extension methods for JSON parsing
    type APIError with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : APIError =
            let arg_2 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                Url = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AccessToken type
[<AutoOpen>]
module AccessTokenJsonParseExtension =
    /// Extension methods for JSON parsing
    type AccessToken with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AccessToken =
            let arg_5 =
                match node.["token_last_eight"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["sha1"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["scopes"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "id"
                        || key = "name"
                        || key = "scopes"
                        || key = "sha1"
                        || key = "token_last_eight"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Id = arg_1
                Name = arg_2
                Scopes = arg_3
                Sha1 = arg_4
                TokenLastEight = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ActivityPub type
[<AutoOpen>]
module ActivityPubJsonParseExtension =
    /// Extension methods for JSON parsing
    type ActivityPub with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ActivityPub =
            let arg_1 =
                match node.["@context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "@context" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AddCollaboratorOption type
[<AutoOpen>]
module AddCollaboratorOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type AddCollaboratorOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AddCollaboratorOption =
            let arg_1 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "permission" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Permission = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AddTimeOption type
[<AutoOpen>]
module AddTimeOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type AddTimeOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AddTimeOption =
            let arg_3 =
                match node.["user_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                (match node.["time"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("time")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.Int32> ()

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "created" || key = "time" || key = "user_name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Time = arg_2
                UserName = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AnnotatedTagObject type
[<AutoOpen>]
module AnnotatedTagObjectJsonParseExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTagObject with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AnnotatedTagObject =
            let arg_3 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "sha" || key = "type" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Sha = arg_1
                Type = arg_2
                Url = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Attachment type
[<AutoOpen>]
module AttachmentJsonParseExtension =
    /// Extension methods for JSON parsing
    type Attachment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Attachment =
            let arg_7 =
                match node.["uuid"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["download_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["browser_download_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "browser_download_url"
                        || key = "created_at"
                        || key = "download_count"
                        || key = "id"
                        || key = "name"
                        || key = "size"
                        || key = "uuid"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                BrowserDownloadUrl = arg_1
                CreatedAt = arg_2
                DownloadCount = arg_3
                Id = arg_4
                Name = arg_5
                Size = arg_6
                Uuid = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the BranchProtection type
[<AutoOpen>]
module BranchProtectionJsonParseExtension =
    /// Extension methods for JSON parsing
    type BranchProtection with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : BranchProtection =
            let arg_25 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_24 =
                match node.["unprotected_file_patterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_23 =
                match node.["status_check_contexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_22 =
                match node.["rule_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_21 =
                match node.["required_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_20 =
                match node.["require_signed_commits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_19 =
                match node.["push_whitelist_usernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_18 =
                match node.["push_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_17 =
                match node.["push_whitelist_deploy_keys"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_16 =
                match node.["protected_file_patterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                match node.["merge_whitelist_usernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_14 =
                match node.["merge_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_13 =
                match node.["enable_status_check"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_12 =
                match node.["enable_push_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["enable_push"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["enable_merge_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["enable_approvals_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["dismiss_stale_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["branch_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["block_on_rejected_reviews"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["block_on_outdated_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["block_on_official_review_requests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["approvals_whitelist_username"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["approvals_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "approvals_whitelist_teams"
                        || key = "approvals_whitelist_username"
                        || key = "block_on_official_review_requests"
                        || key = "block_on_outdated_branch"
                        || key = "block_on_rejected_reviews"
                        || key = "branch_name"
                        || key = "created_at"
                        || key = "dismiss_stale_approvals"
                        || key = "enable_approvals_whitelist"
                        || key = "enable_merge_whitelist"
                        || key = "enable_push"
                        || key = "enable_push_whitelist"
                        || key = "enable_status_check"
                        || key = "merge_whitelist_teams"
                        || key = "merge_whitelist_usernames"
                        || key = "protected_file_patterns"
                        || key = "push_whitelist_deploy_keys"
                        || key = "push_whitelist_teams"
                        || key = "push_whitelist_usernames"
                        || key = "require_signed_commits"
                        || key = "required_approvals"
                        || key = "rule_name"
                        || key = "status_check_contexts"
                        || key = "unprotected_file_patterns"
                        || key = "updated_at"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ApprovalsWhitelistTeams = arg_1
                ApprovalsWhitelistUsername = arg_2
                BlockOnOfficialReviewRequests = arg_3
                BlockOnOutdatedBranch = arg_4
                BlockOnRejectedReviews = arg_5
                BranchName = arg_6
                CreatedAt = arg_7
                DismissStaleApprovals = arg_8
                EnableApprovalsWhitelist = arg_9
                EnableMergeWhitelist = arg_10
                EnablePush = arg_11
                EnablePushWhitelist = arg_12
                EnableStatusCheck = arg_13
                MergeWhitelistTeams = arg_14
                MergeWhitelistUsernames = arg_15
                ProtectedFilePatterns = arg_16
                PushWhitelistDeployKeys = arg_17
                PushWhitelistTeams = arg_18
                PushWhitelistUsernames = arg_19
                RequireSignedCommits = arg_20
                RequiredApprovals = arg_21
                RuleName = arg_22
                StatusCheckContexts = arg_23
                UnprotectedFilePatterns = arg_24
                UpdatedAt = arg_25
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ChangedFile type
[<AutoOpen>]
module ChangedFileJsonParseExtension =
    /// Extension methods for JSON parsing
    type ChangedFile with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ChangedFile =
            let arg_9 =
                match node.["status"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["raw_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["previous_filename"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["filename"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["deletions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["contents_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["changes"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["additions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "additions"
                        || key = "changes"
                        || key = "contents_url"
                        || key = "deletions"
                        || key = "filename"
                        || key = "html_url"
                        || key = "previous_filename"
                        || key = "raw_url"
                        || key = "status"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Additions = arg_1
                Changes = arg_2
                ContentsUrl = arg_3
                Deletions = arg_4
                Filename = arg_5
                HtmlUrl = arg_6
                PreviousFilename = arg_7
                RawUrl = arg_8
                Status = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitAffectedFiles type
[<AutoOpen>]
module CommitAffectedFilesJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitAffectedFiles with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitAffectedFiles =
            let arg_1 =
                match node.["filename"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "filename" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Filename = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitDateOptions type
[<AutoOpen>]
module CommitDateOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitDateOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitDateOptions =
            let arg_2 =
                match node.["committer"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "author" || key = "committer" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Committer = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitMeta type
[<AutoOpen>]
module CommitMetaJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitMeta with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitMeta =
            let arg_3 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "created" || key = "sha" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Sha = arg_2
                Url = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitStats type
[<AutoOpen>]
module CommitStatsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitStats with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitStats =
            let arg_3 =
                match node.["total"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["deletions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["additions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "additions" || key = "deletions" || key = "total" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Additions = arg_1
                Deletions = arg_2
                Total = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitUser type
[<AutoOpen>]
module CommitUserJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitUser with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitUser =
            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "date" || key = "email" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Date = arg_1
                Email = arg_2
                Name = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateAccessTokenOption type
[<AutoOpen>]
module CreateAccessTokenOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateAccessTokenOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateAccessTokenOption =
            let arg_2 =
                match node.["scopes"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "name" || key = "scopes" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Name = arg_1
                Scopes = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateBranchProtectionOption type
[<AutoOpen>]
module CreateBranchProtectionOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateBranchProtectionOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateBranchProtectionOption =
            let arg_23 =
                match node.["unprotected_file_patterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_22 =
                match node.["status_check_contexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_21 =
                match node.["rule_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["required_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_19 =
                match node.["require_signed_commits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["push_whitelist_usernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_17 =
                match node.["push_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_16 =
                match node.["push_whitelist_deploy_keys"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_15 =
                match node.["protected_file_patterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["merge_whitelist_usernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_13 =
                match node.["merge_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_12 =
                match node.["enable_status_check"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["enable_push_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["enable_push"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["enable_merge_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["enable_approvals_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["dismiss_stale_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["branch_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["block_on_rejected_reviews"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["block_on_outdated_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["block_on_official_review_requests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["approvals_whitelist_username"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["approvals_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "approvals_whitelist_teams"
                        || key = "approvals_whitelist_username"
                        || key = "block_on_official_review_requests"
                        || key = "block_on_outdated_branch"
                        || key = "block_on_rejected_reviews"
                        || key = "branch_name"
                        || key = "dismiss_stale_approvals"
                        || key = "enable_approvals_whitelist"
                        || key = "enable_merge_whitelist"
                        || key = "enable_push"
                        || key = "enable_push_whitelist"
                        || key = "enable_status_check"
                        || key = "merge_whitelist_teams"
                        || key = "merge_whitelist_usernames"
                        || key = "protected_file_patterns"
                        || key = "push_whitelist_deploy_keys"
                        || key = "push_whitelist_teams"
                        || key = "push_whitelist_usernames"
                        || key = "require_signed_commits"
                        || key = "required_approvals"
                        || key = "rule_name"
                        || key = "status_check_contexts"
                        || key = "unprotected_file_patterns"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ApprovalsWhitelistTeams = arg_1
                ApprovalsWhitelistUsername = arg_2
                BlockOnOfficialReviewRequests = arg_3
                BlockOnOutdatedBranch = arg_4
                BlockOnRejectedReviews = arg_5
                BranchName = arg_6
                DismissStaleApprovals = arg_7
                EnableApprovalsWhitelist = arg_8
                EnableMergeWhitelist = arg_9
                EnablePush = arg_10
                EnablePushWhitelist = arg_11
                EnableStatusCheck = arg_12
                MergeWhitelistTeams = arg_13
                MergeWhitelistUsernames = arg_14
                ProtectedFilePatterns = arg_15
                PushWhitelistDeployKeys = arg_16
                PushWhitelistTeams = arg_17
                PushWhitelistUsernames = arg_18
                RequireSignedCommits = arg_19
                RequiredApprovals = arg_20
                RuleName = arg_21
                StatusCheckContexts = arg_22
                UnprotectedFilePatterns = arg_23
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateBranchRepoOption type
[<AutoOpen>]
module CreateBranchRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateBranchRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateBranchRepoOption =
            let arg_2 =
                match node.["old_branch_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["new_branch_name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("new_branch_name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "new_branch_name" || key = "old_branch_name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                NewBranchName = arg_1
                OldBranchName = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateEmailOption type
[<AutoOpen>]
module CreateEmailOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateEmailOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateEmailOption =
            let arg_1 =
                match node.["emails"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "emails" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Emails = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateForkOption type
[<AutoOpen>]
module CreateForkOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateForkOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateForkOption =
            let arg_2 =
                match node.["organization"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "name" || key = "organization" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Name = arg_1
                Organization = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateGPGKeyOption type
[<AutoOpen>]
module CreateGPGKeyOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateGPGKeyOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateGPGKeyOption =
            let arg_2 =
                match node.["armored_signature"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["armored_public_key"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("armored_public_key")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "armored_public_key" || key = "armored_signature" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ArmoredPublicKey = arg_1
                ArmoredSignature = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateHookOptionConfig type
[<AutoOpen>]
module CreateHookOptionConfigJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateHookOptionConfig with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateHookOptionConfig =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateIssueCommentOption type
[<AutoOpen>]
module CreateIssueCommentOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateIssueCommentOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateIssueCommentOption =
            let arg_1 =
                (match node.["body"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("body")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateIssueOption type
[<AutoOpen>]
module CreateIssueOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateIssueOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateIssueOption =
            let arg_9 =
                (match node.["title"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("title")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_8 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["closed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignees"
                        || key = "body"
                        || key = "closed"
                        || key = "due_date"
                        || key = "labels"
                        || key = "milestone"
                        || key = "ref"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                Assignees = arg_2
                Body = arg_3
                Closed = arg_4
                DueDate = arg_5
                Labels = arg_6
                Milestone = arg_7
                Ref = arg_8
                Title = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateKeyOption type
[<AutoOpen>]
module CreateKeyOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateKeyOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateKeyOption =
            let arg_3 =
                (match node.["title"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("title")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_2 =
                match node.["read_only"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                (match node.["key"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("key")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "key" || key = "read_only" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Key = arg_1
                ReadOnly = arg_2
                Title = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateLabelOption type
[<AutoOpen>]
module CreateLabelOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateLabelOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateLabelOption =
            let arg_4 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["exclusive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["color"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("color")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "color" || key = "description" || key = "exclusive" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Color = arg_1
                Description = arg_2
                Exclusive = arg_3
                Name = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateMilestoneOption type
[<AutoOpen>]
module CreateMilestoneOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateMilestoneOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateMilestoneOption =
            let arg_4 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["due_on"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "description" || key = "due_on" || key = "state" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Description = arg_1
                DueOn = arg_2
                State = arg_3
                Title = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateOAuth2ApplicationOptions type
[<AutoOpen>]
module CreateOAuth2ApplicationOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateOAuth2ApplicationOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateOAuth2ApplicationOptions =
            let arg_3 =
                match node.["redirect_uris"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["confidential_client"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "confidential_client" || key = "name" || key = "redirect_uris" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ConfidentialClient = arg_1
                Name = arg_2
                RedirectUris = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateOrgOption type
[<AutoOpen>]
module CreateOrgOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateOrgOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateOrgOption =
            let arg_7 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                (match node.["username"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("username")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_4 =
                match node.["repo_admin_change_team_access"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "description"
                        || key = "full_name"
                        || key = "location"
                        || key = "repo_admin_change_team_access"
                        || key = "username"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Description = arg_1
                FullName = arg_2
                Location = arg_3
                RepoAdminChangeTeamAccess = arg_4
                Username = arg_5
                Visibility = arg_6
                Website = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePullRequestOption type
[<AutoOpen>]
module CreatePullRequestOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePullRequestOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePullRequestOption =
            let arg_9 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["head"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["base"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignees"
                        || key = "base"
                        || key = "body"
                        || key = "due_date"
                        || key = "head"
                        || key = "labels"
                        || key = "milestone"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                Assignees = arg_2
                Base = arg_3
                Body = arg_4
                DueDate = arg_5
                Head = arg_6
                Labels = arg_7
                Milestone = arg_8
                Title = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePullReviewComment type
[<AutoOpen>]
module CreatePullReviewCommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewComment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePullReviewComment =
            let arg_4 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["old_position"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["new_position"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" || key = "new_position" || key = "old_position" || key = "path" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                NewPosition = arg_2
                OldPosition = arg_3
                Path = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePushMirrorOption type
[<AutoOpen>]
module CreatePushMirrorOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePushMirrorOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePushMirrorOption =
            let arg_5 =
                match node.["sync_on_commit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["remote_username"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["remote_password"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["remote_address"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "interval"
                        || key = "remote_address"
                        || key = "remote_password"
                        || key = "remote_username"
                        || key = "sync_on_commit"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Interval = arg_1
                RemoteAddress = arg_2
                RemotePassword = arg_3
                RemoteUsername = arg_4
                SyncOnCommit = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateReleaseOption type
[<AutoOpen>]
module CreateReleaseOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateReleaseOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateReleaseOption =
            let arg_6 =
                match node.["target_commitish"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                (match node.["tag_name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("tag_name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_4 =
                match node.["prerelease"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["draft"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "draft"
                        || key = "name"
                        || key = "prerelease"
                        || key = "tag_name"
                        || key = "target_commitish"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Draft = arg_2
                Name = arg_3
                Prerelease = arg_4
                TagName = arg_5
                TargetCommitish = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateRepoOption type
[<AutoOpen>]
module CreateRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateRepoOption =
            let arg_11 =
                match node.["trust_model"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["template"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["readme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_6 =
                match node.["license"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["issue_labels"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["gitignores"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["default_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["auto_init"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "auto_init"
                        || key = "default_branch"
                        || key = "description"
                        || key = "gitignores"
                        || key = "issue_labels"
                        || key = "license"
                        || key = "name"
                        || key = "private"
                        || key = "readme"
                        || key = "template"
                        || key = "trust_model"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AutoInit = arg_1
                DefaultBranch = arg_2
                Description = arg_3
                Gitignores = arg_4
                IssueLabels = arg_5
                License = arg_6
                Name = arg_7
                Private = arg_8
                Readme = arg_9
                Template = arg_10
                TrustModel = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateStatusOption type
[<AutoOpen>]
module CreateStatusOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateStatusOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateStatusOption =
            let arg_4 =
                match node.["target_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "context" || key = "description" || key = "state" || key = "target_url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
                Description = arg_2
                State = arg_3
                TargetUrl = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateTagOption type
[<AutoOpen>]
module CreateTagOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateTagOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateTagOption =
            let arg_3 =
                match node.["target"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                (match node.["tag_name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("tag_name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" || key = "tag_name" || key = "target" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                TagName = arg_2
                Target = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type1 type
[<AutoOpen>]
module Type1JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type1 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type1 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateTeamOption type
[<AutoOpen>]
module CreateTeamOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateTeamOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateTeamOption =
            let arg_7 =
                match node.["units_map"] with
                | null -> None
                | v -> Type1.jsonParse v |> Some

            let arg_6 =
                match node.["units"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["includes_all_repositories"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["can_create_org_repo"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "can_create_org_repo"
                        || key = "description"
                        || key = "includes_all_repositories"
                        || key = "name"
                        || key = "permission"
                        || key = "units"
                        || key = "units_map"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateOrgRepo = arg_1
                Description = arg_2
                IncludesAllRepositories = arg_3
                Name = arg_4
                Permission = arg_5
                Units = arg_6
                UnitsMap = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateUserOption type
[<AutoOpen>]
module CreateUserOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateUserOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateUserOption =
            let arg_11 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                (match node.["username"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("username")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_9 =
                match node.["source_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_8 =
                match node.["send_notify"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["restricted"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                (match node.["password"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("password")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_5 =
                match node.["must_change_password"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["login_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                (match node.["email"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("email")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_1 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created_at"
                        || key = "email"
                        || key = "full_name"
                        || key = "login_name"
                        || key = "must_change_password"
                        || key = "password"
                        || key = "restricted"
                        || key = "send_notify"
                        || key = "source_id"
                        || key = "username"
                        || key = "visibility"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Email = arg_2
                FullName = arg_3
                LoginName = arg_4
                MustChangePassword = arg_5
                Password = arg_6
                Restricted = arg_7
                SendNotify = arg_8
                SourceId = arg_9
                Username = arg_10
                Visibility = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateWikiPageOptions type
[<AutoOpen>]
module CreateWikiPageOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateWikiPageOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateWikiPageOptions =
            let arg_3 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["content_base64"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content_base64" || key = "message" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ContentBase64 = arg_1
                Message = arg_2
                Title = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Cron type
[<AutoOpen>]
module CronJsonParseExtension =
    /// Extension methods for JSON parsing
    type Cron with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Cron =
            let arg_5 =
                match node.["schedule"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["prev"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["next"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["exec_times"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "exec_times"
                        || key = "name"
                        || key = "next"
                        || key = "prev"
                        || key = "schedule"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ExecTimes = arg_1
                Name = arg_2
                Next = arg_3
                Prev = arg_4
                Schedule = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DeleteEmailOption type
[<AutoOpen>]
module DeleteEmailOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type DeleteEmailOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DeleteEmailOption =
            let arg_1 =
                match node.["emails"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "emails" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Emails = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DismissPullReviewOptions type
[<AutoOpen>]
module DismissPullReviewOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type DismissPullReviewOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DismissPullReviewOptions =
            let arg_2 =
                match node.["priors"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" || key = "priors" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                Priors = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditAttachmentOptions type
[<AutoOpen>]
module EditAttachmentOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditAttachmentOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditAttachmentOptions =
            let arg_1 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "name" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Name = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditBranchProtectionOption type
[<AutoOpen>]
module EditBranchProtectionOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditBranchProtectionOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditBranchProtectionOption =
            let arg_21 =
                match node.["unprotected_file_patterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["status_check_contexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_19 =
                match node.["required_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_18 =
                match node.["require_signed_commits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["push_whitelist_usernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_16 =
                match node.["push_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_15 =
                match node.["push_whitelist_deploy_keys"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_14 =
                match node.["protected_file_patterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["merge_whitelist_usernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_12 =
                match node.["merge_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_11 =
                match node.["enable_status_check"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["enable_push_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["enable_push"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["enable_merge_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["enable_approvals_whitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["dismiss_stale_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["block_on_rejected_reviews"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["block_on_outdated_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["block_on_official_review_requests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["approvals_whitelist_username"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["approvals_whitelist_teams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "approvals_whitelist_teams"
                        || key = "approvals_whitelist_username"
                        || key = "block_on_official_review_requests"
                        || key = "block_on_outdated_branch"
                        || key = "block_on_rejected_reviews"
                        || key = "dismiss_stale_approvals"
                        || key = "enable_approvals_whitelist"
                        || key = "enable_merge_whitelist"
                        || key = "enable_push"
                        || key = "enable_push_whitelist"
                        || key = "enable_status_check"
                        || key = "merge_whitelist_teams"
                        || key = "merge_whitelist_usernames"
                        || key = "protected_file_patterns"
                        || key = "push_whitelist_deploy_keys"
                        || key = "push_whitelist_teams"
                        || key = "push_whitelist_usernames"
                        || key = "require_signed_commits"
                        || key = "required_approvals"
                        || key = "status_check_contexts"
                        || key = "unprotected_file_patterns"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ApprovalsWhitelistTeams = arg_1
                ApprovalsWhitelistUsername = arg_2
                BlockOnOfficialReviewRequests = arg_3
                BlockOnOutdatedBranch = arg_4
                BlockOnRejectedReviews = arg_5
                DismissStaleApprovals = arg_6
                EnableApprovalsWhitelist = arg_7
                EnableMergeWhitelist = arg_8
                EnablePush = arg_9
                EnablePushWhitelist = arg_10
                EnableStatusCheck = arg_11
                MergeWhitelistTeams = arg_12
                MergeWhitelistUsernames = arg_13
                ProtectedFilePatterns = arg_14
                PushWhitelistDeployKeys = arg_15
                PushWhitelistTeams = arg_16
                PushWhitelistUsernames = arg_17
                RequireSignedCommits = arg_18
                RequiredApprovals = arg_19
                StatusCheckContexts = arg_20
                UnprotectedFilePatterns = arg_21
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditDeadlineOption type
[<AutoOpen>]
module EditDeadlineOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditDeadlineOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditDeadlineOption =
            let arg_1 =
                (match node.["due_date"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("due_date")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "due_date" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DueDate = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditGitHookOption type
[<AutoOpen>]
module EditGitHookOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditGitHookOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditGitHookOption =
            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type2 type
[<AutoOpen>]
module Type2JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type2 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type2 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditHookOption type
[<AutoOpen>]
module EditHookOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditHookOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditHookOption =
            let arg_5 =
                match node.["events"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["config"] with
                | null -> None
                | v -> Type2.jsonParse v |> Some

            let arg_3 =
                match node.["branch_filter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["authorization_header"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "authorization_header"
                        || key = "branch_filter"
                        || key = "config"
                        || key = "events"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AuthorizationHeader = arg_2
                BranchFilter = arg_3
                Config = arg_4
                Events = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditIssueCommentOption type
[<AutoOpen>]
module EditIssueCommentOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditIssueCommentOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditIssueCommentOption =
            let arg_1 =
                (match node.["body"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("body")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditIssueOption type
[<AutoOpen>]
module EditIssueOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditIssueOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditIssueOption =
            let arg_9 =
                match node.["unset_due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignees"
                        || key = "body"
                        || key = "due_date"
                        || key = "milestone"
                        || key = "ref"
                        || key = "state"
                        || key = "title"
                        || key = "unset_due_date"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                Assignees = arg_2
                Body = arg_3
                DueDate = arg_4
                Milestone = arg_5
                Ref = arg_6
                State = arg_7
                Title = arg_8
                UnsetDueDate = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditLabelOption type
[<AutoOpen>]
module EditLabelOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditLabelOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditLabelOption =
            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["exclusive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["color"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "color" || key = "description" || key = "exclusive" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Color = arg_1
                Description = arg_2
                Exclusive = arg_3
                Name = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditMilestoneOption type
[<AutoOpen>]
module EditMilestoneOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditMilestoneOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditMilestoneOption =
            let arg_4 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["due_on"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "description" || key = "due_on" || key = "state" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Description = arg_1
                DueOn = arg_2
                State = arg_3
                Title = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditOrgOption type
[<AutoOpen>]
module EditOrgOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditOrgOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditOrgOption =
            let arg_6 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["repo_admin_change_team_access"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "description"
                        || key = "full_name"
                        || key = "location"
                        || key = "repo_admin_change_team_access"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Description = arg_1
                FullName = arg_2
                Location = arg_3
                RepoAdminChangeTeamAccess = arg_4
                Visibility = arg_5
                Website = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditPullRequestOption type
[<AutoOpen>]
module EditPullRequestOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditPullRequestOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditPullRequestOption =
            let arg_11 =
                match node.["unset_due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["base"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["allow_maintainer_edit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allow_maintainer_edit"
                        || key = "assignee"
                        || key = "assignees"
                        || key = "base"
                        || key = "body"
                        || key = "due_date"
                        || key = "labels"
                        || key = "milestone"
                        || key = "state"
                        || key = "title"
                        || key = "unset_due_date"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowMaintainerEdit = arg_1
                Assignee = arg_2
                Assignees = arg_3
                Base = arg_4
                Body = arg_5
                DueDate = arg_6
                Labels = arg_7
                Milestone = arg_8
                State = arg_9
                Title = arg_10
                UnsetDueDate = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditReactionOption type
[<AutoOpen>]
module EditReactionOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditReactionOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditReactionOption =
            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditReleaseOption type
[<AutoOpen>]
module EditReleaseOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditReleaseOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditReleaseOption =
            let arg_6 =
                match node.["target_commitish"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["tag_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["prerelease"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["draft"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "draft"
                        || key = "name"
                        || key = "prerelease"
                        || key = "tag_name"
                        || key = "target_commitish"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Draft = arg_2
                Name = arg_3
                Prerelease = arg_4
                TagName = arg_5
                TargetCommitish = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type3 type
[<AutoOpen>]
module Type3JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type3 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type3 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditTeamOption type
[<AutoOpen>]
module EditTeamOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditTeamOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditTeamOption =
            let arg_7 =
                match node.["units_map"] with
                | null -> None
                | v -> Type3.jsonParse v |> Some

            let arg_6 =
                match node.["units"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["includes_all_repositories"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["can_create_org_repo"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "can_create_org_repo"
                        || key = "description"
                        || key = "includes_all_repositories"
                        || key = "name"
                        || key = "permission"
                        || key = "units"
                        || key = "units_map"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateOrgRepo = arg_1
                Description = arg_2
                IncludesAllRepositories = arg_3
                Name = arg_4
                Permission = arg_5
                Units = arg_6
                UnitsMap = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditUserOption type
[<AutoOpen>]
module EditUserOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditUserOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditUserOption =
            let arg_18 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_16 =
                (match node.["source_id"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("source_id")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.Int32> ()

            let arg_15 =
                match node.["restricted"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_14 =
                match node.["prohibit_login"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["password"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["must_change_password"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["max_repo_creation"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_10 =
                (match node.["login_name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("login_name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_9 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["allow_import_local"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["allow_git_hook"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["allow_create_organization"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["admin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "admin"
                        || key = "allow_create_organization"
                        || key = "allow_git_hook"
                        || key = "allow_import_local"
                        || key = "description"
                        || key = "email"
                        || key = "full_name"
                        || key = "location"
                        || key = "login_name"
                        || key = "max_repo_creation"
                        || key = "must_change_password"
                        || key = "password"
                        || key = "prohibit_login"
                        || key = "restricted"
                        || key = "source_id"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                Admin = arg_2
                AllowCreateOrganization = arg_3
                AllowGitHook = arg_4
                AllowImportLocal = arg_5
                Description = arg_6
                Email = arg_7
                FullName = arg_8
                Location = arg_9
                LoginName = arg_10
                MaxRepoCreation = arg_11
                MustChangePassword = arg_12
                Password = arg_13
                ProhibitLogin = arg_14
                Restricted = arg_15
                SourceId = arg_16
                Visibility = arg_17
                Website = arg_18
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Email type
[<AutoOpen>]
module EmailJsonParseExtension =
    /// Extension methods for JSON parsing
    type Email with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Email =
            let arg_3 =
                match node.["verified"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["primary"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "primary" || key = "verified" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Primary = arg_2
                Verified = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ExternalTracker type
[<AutoOpen>]
module ExternalTrackerJsonParseExtension =
    /// Extension methods for JSON parsing
    type ExternalTracker with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ExternalTracker =
            let arg_4 =
                match node.["external_tracker_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["external_tracker_style"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["external_tracker_regexp_pattern"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["external_tracker_format"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "external_tracker_format"
                        || key = "external_tracker_regexp_pattern"
                        || key = "external_tracker_style"
                        || key = "external_tracker_url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ExternalTrackerFormat = arg_1
                ExternalTrackerRegexpPattern = arg_2
                ExternalTrackerStyle = arg_3
                ExternalTrackerUrl = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ExternalWiki type
[<AutoOpen>]
module ExternalWikiJsonParseExtension =
    /// Extension methods for JSON parsing
    type ExternalWiki with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ExternalWiki =
            let arg_1 =
                match node.["external_wiki_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "external_wiki_url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ExternalWikiUrl = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileCommitResponse type
[<AutoOpen>]
module FileCommitResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileCommitResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileCommitResponse =
            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["tree"] with
                | null -> None
                | v -> CommitMeta.jsonParse v |> Some

            let arg_7 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["parents"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitMeta.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["committer"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "committer"
                        || key = "created"
                        || key = "html_url"
                        || key = "message"
                        || key = "parents"
                        || key = "sha"
                        || key = "tree"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Committer = arg_2
                Created = arg_3
                HtmlUrl = arg_4
                Message = arg_5
                Parents = arg_6
                Sha = arg_7
                Tree = arg_8
                Url = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileLinksResponse type
[<AutoOpen>]
module FileLinksResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileLinksResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileLinksResponse =
            let arg_3 =
                match node.["self"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["html"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["git"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "git" || key = "html" || key = "self" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Git = arg_1
                Html = arg_2
                Self = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GPGKeyEmail type
[<AutoOpen>]
module GPGKeyEmailJsonParseExtension =
    /// Extension methods for JSON parsing
    type GPGKeyEmail with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GPGKeyEmail =
            let arg_2 =
                match node.["verified"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "verified" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Verified = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralAPISettings type
[<AutoOpen>]
module GeneralAPISettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralAPISettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralAPISettings =
            let arg_4 =
                match node.["max_response_items"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["default_paging_num"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["default_max_blob_size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["default_git_trees_per_page"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "default_git_trees_per_page"
                        || key = "default_max_blob_size"
                        || key = "default_paging_num"
                        || key = "max_response_items"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DefaultGitTreesPerPage = arg_1
                DefaultMaxBlobSize = arg_2
                DefaultPagingNum = arg_3
                MaxResponseItems = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralAttachmentSettings type
[<AutoOpen>]
module GeneralAttachmentSettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralAttachmentSettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralAttachmentSettings =
            let arg_4 =
                match node.["max_size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["max_files"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["enabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allowed_types"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allowed_types"
                        || key = "enabled"
                        || key = "max_files"
                        || key = "max_size"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowedTypes = arg_1
                Enabled = arg_2
                MaxFiles = arg_3
                MaxSize = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralRepoSettings type
[<AutoOpen>]
module GeneralRepoSettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralRepoSettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralRepoSettings =
            let arg_6 =
                match node.["time_tracking_disabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["stars_disabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["mirrors_disabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["migrations_disabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["lfs_disabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["http_git_disabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "http_git_disabled"
                        || key = "lfs_disabled"
                        || key = "migrations_disabled"
                        || key = "mirrors_disabled"
                        || key = "stars_disabled"
                        || key = "time_tracking_disabled"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                HttpGitDisabled = arg_1
                LfsDisabled = arg_2
                MigrationsDisabled = arg_3
                MirrorsDisabled = arg_4
                StarsDisabled = arg_5
                TimeTrackingDisabled = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralUISettings type
[<AutoOpen>]
module GeneralUISettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralUISettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralUISettings =
            let arg_3 =
                match node.["default_theme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["custom_emojis"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["allowed_reactions"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "allowed_reactions" || key = "custom_emojis" || key = "default_theme" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowedReactions = arg_1
                CustomEmojis = arg_2
                DefaultTheme = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GenerateRepoOption type
[<AutoOpen>]
module GenerateRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type GenerateRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GenerateRepoOption =
            let arg_11 =
                match node.["webhooks"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["topics"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                (match node.["owner"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("owner")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_7 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_6 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["git_hooks"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["git_content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["default_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["avatar"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "avatar"
                        || key = "default_branch"
                        || key = "description"
                        || key = "git_content"
                        || key = "git_hooks"
                        || key = "labels"
                        || key = "name"
                        || key = "owner"
                        || key = "private"
                        || key = "topics"
                        || key = "webhooks"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Avatar = arg_1
                DefaultBranch = arg_2
                Description = arg_3
                GitContent = arg_4
                GitHooks = arg_5
                Labels = arg_6
                Name = arg_7
                Owner = arg_8
                Private = arg_9
                Topics = arg_10
                Webhooks = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitBlobResponse type
[<AutoOpen>]
module GitBlobResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitBlobResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitBlobResponse =
            let arg_5 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["encoding"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "content"
                        || key = "encoding"
                        || key = "sha"
                        || key = "size"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
                Encoding = arg_2
                Sha = arg_3
                Size = arg_4
                Url = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitEntry type
[<AutoOpen>]
module GitEntryJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitEntry with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitEntry =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["mode"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "mode"
                        || key = "path"
                        || key = "sha"
                        || key = "size"
                        || key = "type"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Mode = arg_1
                Path = arg_2
                Sha = arg_3
                Size = arg_4
                Type = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitHook type
[<AutoOpen>]
module GitHookJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitHook with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitHook =
            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["is_active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" || key = "is_active" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
                IsActive = arg_2
                Name = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitObject type
[<AutoOpen>]
module GitObjectJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitObject with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitObject =
            let arg_3 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "sha" || key = "type" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Sha = arg_1
                Type = arg_2
                Url = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitTreeResponse type
[<AutoOpen>]
module GitTreeResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitTreeResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitTreeResponse =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["truncated"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["tree"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> GitEntry.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_3 =
                match node.["total_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["page"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "page"
                        || key = "sha"
                        || key = "total_count"
                        || key = "tree"
                        || key = "truncated"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Page = arg_1
                Sha = arg_2
                TotalCount = arg_3
                Tree = arg_4
                Truncated = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type4 type
[<AutoOpen>]
module Type4JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type4 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type4 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Hook type
[<AutoOpen>]
module HookJsonParseExtension =
    /// Extension methods for JSON parsing
    type Hook with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Hook =
            let arg_8 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["events"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["config"] with
                | null -> None
                | v -> Type4.jsonParse v |> Some

            let arg_2 =
                match node.["authorization_header"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "authorization_header"
                        || key = "config"
                        || key = "created_at"
                        || key = "events"
                        || key = "id"
                        || key = "type"
                        || key = "updated_at"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AuthorizationHeader = arg_2
                Config = arg_3
                CreatedAt = arg_4
                Events = arg_5
                Id = arg_6
                Type = arg_7
                UpdatedAt = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Identity type
[<AutoOpen>]
module IdentityJsonParseExtension =
    /// Extension methods for JSON parsing
    type Identity with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Identity =
            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Name = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the InternalTracker type
[<AutoOpen>]
module InternalTrackerJsonParseExtension =
    /// Extension methods for JSON parsing
    type InternalTracker with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : InternalTracker =
            let arg_3 =
                match node.["enable_time_tracker"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["enable_issue_dependencies"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allow_only_contributors_to_track_time"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allow_only_contributors_to_track_time"
                        || key = "enable_issue_dependencies"
                        || key = "enable_time_tracker"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowOnlyContributorsToTrackTime = arg_1
                EnableIssueDependencies = arg_2
                EnableTimeTracker = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueDeadline type
[<AutoOpen>]
module IssueDeadlineJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueDeadline with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueDeadline =
            let arg_1 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "due_date" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DueDate = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type5 type
[<AutoOpen>]
module Type5JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type5 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type5 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, unit> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then () else result.Add (key, ())

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type6 type
[<AutoOpen>]
module Type6JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type6 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type6 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, unit> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then () else result.Add (key, ())

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueLabelsOption type
[<AutoOpen>]
module IssueLabelsOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueLabelsOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueLabelsOption =
            let arg_1 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "labels" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Labels = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Label type
[<AutoOpen>]
module LabelJsonParseExtension =
    /// Extension methods for JSON parsing
    type Label with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Label =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["exclusive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["color"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "color"
                        || key = "description"
                        || key = "exclusive"
                        || key = "id"
                        || key = "name"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Color = arg_1
                Description = arg_2
                Exclusive = arg_3
                Id = arg_4
                Name = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the MarkdownOption type
[<AutoOpen>]
module MarkdownOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type MarkdownOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : MarkdownOption =
            let arg_4 =
                match node.["Wiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["Text"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["Mode"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["Context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "Context" || key = "Mode" || key = "Text" || key = "Wiki" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
                Mode = arg_2
                Text = arg_3
                Wiki = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the MergePullRequestOption type
[<AutoOpen>]
module MergePullRequestOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type MergePullRequestOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : MergePullRequestOption =
            let arg_8 =
                match node.["merge_when_checks_succeed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["head_commit_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["force_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["delete_branch_after_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["MergeTitleField"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["MergeMessageField"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["MergeCommitID"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["Do"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("Do")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "Do"
                        || key = "MergeCommitID"
                        || key = "MergeMessageField"
                        || key = "MergeTitleField"
                        || key = "delete_branch_after_merge"
                        || key = "force_merge"
                        || key = "head_commit_id"
                        || key = "merge_when_checks_succeed"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Do = arg_1
                MergeCommitID = arg_2
                MergeMessageField = arg_3
                MergeTitleField = arg_4
                DeleteBranchAfterMerge = arg_5
                ForceMerge = arg_6
                HeadCommitId = arg_7
                MergeWhenChecksSucceed = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the MigrateRepoOptions type
[<AutoOpen>]
module MigrateRepoOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type MigrateRepoOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : MigrateRepoOptions =
            let arg_20 =
                match node.["wiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_19 =
                match node.["uid"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_18 =
                match node.["service"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["repo_owner"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_16 =
                (match node.["repo_name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("repo_name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_15 =
                match node.["releases"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_14 =
                match node.["pull_requests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_12 =
                match node.["mirror_interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["mirror"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["milestones"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["lfs_endpoint"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["lfs"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["issues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                (match node.["clone_addr"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("clone_addr")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["auth_username"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["auth_token"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["auth_password"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "auth_password"
                        || key = "auth_token"
                        || key = "auth_username"
                        || key = "clone_addr"
                        || key = "description"
                        || key = "issues"
                        || key = "labels"
                        || key = "lfs"
                        || key = "lfs_endpoint"
                        || key = "milestones"
                        || key = "mirror"
                        || key = "mirror_interval"
                        || key = "private"
                        || key = "pull_requests"
                        || key = "releases"
                        || key = "repo_name"
                        || key = "repo_owner"
                        || key = "service"
                        || key = "uid"
                        || key = "wiki"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AuthPassword = arg_1
                AuthToken = arg_2
                AuthUsername = arg_3
                CloneAddr = arg_4
                Description = arg_5
                Issues = arg_6
                Labels = arg_7
                Lfs = arg_8
                LfsEndpoint = arg_9
                Milestones = arg_10
                Mirror = arg_11
                MirrorInterval = arg_12
                Private = arg_13
                PullRequests = arg_14
                Releases = arg_15
                RepoName = arg_16
                RepoOwner = arg_17
                Service = arg_18
                Uid = arg_19
                Wiki = arg_20
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type7 type
[<AutoOpen>]
module Type7JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type7 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type7 =
            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoServices type
[<AutoOpen>]
module NodeInfoServicesJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoServices with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoServices =
            let arg_2 =
                match node.["outbound"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["inbound"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "inbound" || key = "outbound" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Inbound = arg_1
                Outbound = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoSoftware type
[<AutoOpen>]
module NodeInfoSoftwareJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoSoftware with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoSoftware =
            let arg_4 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["repository"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["homepage"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "homepage" || key = "name" || key = "repository" || key = "version" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Homepage = arg_1
                Name = arg_2
                Repository = arg_3
                Version = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoUsageUsers type
[<AutoOpen>]
module NodeInfoUsageUsersJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsageUsers with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoUsageUsers =
            let arg_3 =
                match node.["total"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["activeMonth"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["activeHalfyear"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "activeHalfyear" || key = "activeMonth" || key = "total" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ActiveHalfyear = arg_1
                ActiveMonth = arg_2
                Total = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NotificationCount type
[<AutoOpen>]
module NotificationCountJsonParseExtension =
    /// Extension methods for JSON parsing
    type NotificationCount with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NotificationCount =
            let arg_1 =
                match node.["new"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "new" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                New = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the OAuth2Application type
[<AutoOpen>]
module OAuth2ApplicationJsonParseExtension =
    /// Extension methods for JSON parsing
    type OAuth2Application with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : OAuth2Application =
            let arg_7 =
                match node.["redirect_uris"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["confidential_client"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["client_secret"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["client_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "client_id"
                        || key = "client_secret"
                        || key = "confidential_client"
                        || key = "created"
                        || key = "id"
                        || key = "name"
                        || key = "redirect_uris"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ClientId = arg_1
                ClientSecret = arg_2
                ConfidentialClient = arg_3
                Created = arg_4
                Id = arg_5
                Name = arg_6
                RedirectUris = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Organization type
[<AutoOpen>]
module OrganizationJsonParseExtension =
    /// Extension methods for JSON parsing
    type Organization with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Organization =
            let arg_10 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["username"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["repo_admin_change_team_access"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["avatar_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "avatar_url"
                        || key = "description"
                        || key = "full_name"
                        || key = "id"
                        || key = "location"
                        || key = "name"
                        || key = "repo_admin_change_team_access"
                        || key = "username"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AvatarUrl = arg_1
                Description = arg_2
                FullName = arg_3
                Id = arg_4
                Location = arg_5
                Name = arg_6
                RepoAdminChangeTeamAccess = arg_7
                Username = arg_8
                Visibility = arg_9
                Website = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the OrganizationPermissions type
[<AutoOpen>]
module OrganizationPermissionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type OrganizationPermissions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : OrganizationPermissions =
            let arg_5 =
                match node.["is_owner"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["is_admin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["can_write"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["can_read"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["can_create_repository"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "can_create_repository"
                        || key = "can_read"
                        || key = "can_write"
                        || key = "is_admin"
                        || key = "is_owner"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateRepository = arg_1
                CanRead = arg_2
                CanWrite = arg_3
                IsAdmin = arg_4
                IsOwner = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PackageFile type
[<AutoOpen>]
module PackageFileJsonParseExtension =
    /// Extension methods for JSON parsing
    type PackageFile with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PackageFile =
            let arg_7 =
                match node.["sha512"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["sha256"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["sha1"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["md5"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["Size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "Size"
                        || key = "id"
                        || key = "md5"
                        || key = "name"
                        || key = "sha1"
                        || key = "sha256"
                        || key = "sha512"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Size = arg_1
                Id = arg_2
                Md5 = arg_3
                Name = arg_4
                Sha1 = arg_5
                Sha256 = arg_6
                Sha512 = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PayloadUser type
[<AutoOpen>]
module PayloadUserJsonParseExtension =
    /// Extension methods for JSON parsing
    type PayloadUser with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PayloadUser =
            let arg_3 =
                match node.["username"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "name" || key = "username" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Name = arg_2
                Username = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Permission type
[<AutoOpen>]
module PermissionJsonParseExtension =
    /// Extension methods for JSON parsing
    type Permission with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Permission =
            let arg_3 =
                match node.["push"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["pull"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["admin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "admin" || key = "pull" || key = "push" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Admin = arg_1
                Pull = arg_2
                Push = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullRequestMeta type
[<AutoOpen>]
module PullRequestMetaJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullRequestMeta with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullRequestMeta =
            let arg_2 =
                match node.["merged_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["merged"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "merged" || key = "merged_at" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Merged = arg_1
                MergedAt = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullReviewRequestOptions type
[<AutoOpen>]
module PullReviewRequestOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullReviewRequestOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullReviewRequestOptions =
            let arg_2 =
                match node.["team_reviewers"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["reviewers"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "reviewers" || key = "team_reviewers" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Reviewers = arg_1
                TeamReviewers = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PushMirror type
[<AutoOpen>]
module PushMirrorJsonParseExtension =
    /// Extension methods for JSON parsing
    type PushMirror with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PushMirror =
            let arg_8 =
                match node.["sync_on_commit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["repo_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["remote_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["remote_address"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["last_update"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["last_error"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "interval"
                        || key = "last_error"
                        || key = "last_update"
                        || key = "remote_address"
                        || key = "remote_name"
                        || key = "repo_name"
                        || key = "sync_on_commit"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Interval = arg_2
                LastError = arg_3
                LastUpdate = arg_4
                RemoteAddress = arg_5
                RemoteName = arg_6
                RepoName = arg_7
                SyncOnCommit = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Reference type
[<AutoOpen>]
module ReferenceJsonParseExtension =
    /// Extension methods for JSON parsing
    type Reference with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Reference =
            let arg_3 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["object"] with
                | null -> None
                | v -> GitObject.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "object" || key = "ref" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Object = arg_1
                Ref = arg_2
                Url = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoTopicOptions type
[<AutoOpen>]
module RepoTopicOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoTopicOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoTopicOptions =
            let arg_1 =
                match node.["topics"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "topics" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Topics = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepositoryMeta type
[<AutoOpen>]
module RepositoryMetaJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepositoryMeta with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepositoryMeta =
            let arg_4 =
                match node.["owner"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "full_name" || key = "id" || key = "name" || key = "owner" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                FullName = arg_1
                Id = arg_2
                Name = arg_3
                Owner = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ServerVersion type
[<AutoOpen>]
module ServerVersionJsonParseExtension =
    /// Extension methods for JSON parsing
    type ServerVersion with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ServerVersion =
            let arg_1 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "version" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Version = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the StopWatch type
[<AutoOpen>]
module StopWatchJsonParseExtension =
    /// Extension methods for JSON parsing
    type StopWatch with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : StopWatch =
            let arg_7 =
                match node.["seconds"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["repo_owner_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["repo_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["issue_title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["issue_index"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["duration"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "duration"
                        || key = "issue_index"
                        || key = "issue_title"
                        || key = "repo_name"
                        || key = "repo_owner_name"
                        || key = "seconds"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Duration = arg_2
                IssueIndex = arg_3
                IssueTitle = arg_4
                RepoName = arg_5
                RepoOwnerName = arg_6
                Seconds = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the SubmitPullReviewOptions type
[<AutoOpen>]
module SubmitPullReviewOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type SubmitPullReviewOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : SubmitPullReviewOptions =
            let arg_2 =
                match node.["event"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" || key = "event" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Event = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Tag type
[<AutoOpen>]
module TagJsonParseExtension =
    /// Extension methods for JSON parsing
    type Tag with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Tag =
            let arg_6 =
                match node.["zipball_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["tarball_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> CommitMeta.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commit"
                        || key = "id"
                        || key = "message"
                        || key = "name"
                        || key = "tarball_url"
                        || key = "zipball_url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Id = arg_2
                Message = arg_3
                Name = arg_4
                TarballUrl = arg_5
                ZipballUrl = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type8 type
[<AutoOpen>]
module Type8JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type8 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type8 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Team type
[<AutoOpen>]
module TeamJsonParseExtension =
    /// Extension methods for JSON parsing
    type Team with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Team =
            let arg_9 =
                match node.["units_map"] with
                | null -> None
                | v -> Type8.jsonParse v |> Some

            let arg_8 =
                match node.["units"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_7 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["organization"] with
                | null -> None
                | v -> Organization.jsonParse v |> Some

            let arg_5 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["includes_all_repositories"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["can_create_org_repo"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "can_create_org_repo"
                        || key = "description"
                        || key = "id"
                        || key = "includes_all_repositories"
                        || key = "name"
                        || key = "organization"
                        || key = "permission"
                        || key = "units"
                        || key = "units_map"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateOrgRepo = arg_1
                Description = arg_2
                Id = arg_3
                IncludesAllRepositories = arg_4
                Name = arg_5
                Organization = arg_6
                Permission = arg_7
                Units = arg_8
                UnitsMap = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TopicName type
[<AutoOpen>]
module TopicNameJsonParseExtension =
    /// Extension methods for JSON parsing
    type TopicName with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TopicName =
            let arg_1 =
                match node.["topics"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "topics" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Topics = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TopicResponse type
[<AutoOpen>]
module TopicResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type TopicResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TopicResponse =
            let arg_5 =
                match node.["updated"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["topic_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["repo_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "id"
                        || key = "repo_count"
                        || key = "topic_name"
                        || key = "updated"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Id = arg_2
                RepoCount = arg_3
                TopicName = arg_4
                Updated = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TransferRepoOption type
[<AutoOpen>]
module TransferRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type TransferRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TransferRepoOption =
            let arg_2 =
                match node.["team_ids"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                (match node.["new_owner"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("new_owner")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "new_owner" || key = "team_ids" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                NewOwner = arg_1
                TeamIds = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UpdateFileOptions type
[<AutoOpen>]
module UpdateFileOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type UpdateFileOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UpdateFileOptions =
            let arg_10 =
                match node.["signoff"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                (match node.["sha"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("sha")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_8 =
                match node.["new_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["from_path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dates"] with
                | null -> None
                | v -> CommitDateOptions.jsonParse v |> Some

            let arg_4 =
                (match node.["content"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("content")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_2 =
                match node.["branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "branch"
                        || key = "committer"
                        || key = "content"
                        || key = "dates"
                        || key = "from_path"
                        || key = "message"
                        || key = "new_branch"
                        || key = "sha"
                        || key = "signoff"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Branch = arg_2
                Committer = arg_3
                Content = arg_4
                Dates = arg_5
                FromPath = arg_6
                Message = arg_7
                NewBranch = arg_8
                Sha = arg_9
                Signoff = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the User type
[<AutoOpen>]
module UserJsonParseExtension =
    /// Extension methods for JSON parsing
    type User with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : User =
            let arg_20 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_19 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_18 =
                match node.["starred_repos_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_17 =
                match node.["restricted"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_16 =
                match node.["prohibit_login"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_15 =
                match node.["login_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["login"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["last_login"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["is_admin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_8 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["following_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["followers_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["avatar_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "avatar_url"
                        || key = "created"
                        || key = "description"
                        || key = "email"
                        || key = "followers_count"
                        || key = "following_count"
                        || key = "full_name"
                        || key = "id"
                        || key = "is_admin"
                        || key = "language"
                        || key = "last_login"
                        || key = "location"
                        || key = "login"
                        || key = "login_name"
                        || key = "prohibit_login"
                        || key = "restricted"
                        || key = "starred_repos_count"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AvatarUrl = arg_2
                Created = arg_3
                Description = arg_4
                Email = arg_5
                FollowersCount = arg_6
                FollowingCount = arg_7
                FullName = arg_8
                Id = arg_9
                IsAdmin = arg_10
                Language = arg_11
                LastLogin = arg_12
                Location = arg_13
                Login = arg_14
                LoginName = arg_15
                ProhibitLogin = arg_16
                Restricted = arg_17
                StarredReposCount = arg_18
                Visibility = arg_19
                Website = arg_20
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UserHeatmapData type
[<AutoOpen>]
module UserHeatmapDataJsonParseExtension =
    /// Extension methods for JSON parsing
    type UserHeatmapData with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UserHeatmapData =
            let arg_2 =
                match node.["timestamp"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["contributions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "contributions" || key = "timestamp" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Contributions = arg_1
                Timestamp = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UserSettings type
[<AutoOpen>]
module UserSettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type UserSettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UserSettings =
            let arg_9 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["theme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["hide_email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["hide_activity"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["diff_view_style"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "description"
                        || key = "diff_view_style"
                        || key = "full_name"
                        || key = "hide_activity"
                        || key = "hide_email"
                        || key = "language"
                        || key = "location"
                        || key = "theme"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Description = arg_1
                DiffViewStyle = arg_2
                FullName = arg_3
                HideActivity = arg_4
                HideEmail = arg_5
                Language = arg_6
                Location = arg_7
                Theme = arg_8
                Website = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UserSettingsOptions type
[<AutoOpen>]
module UserSettingsOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type UserSettingsOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UserSettingsOptions =
            let arg_9 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["theme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["hide_email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["hide_activity"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["diff_view_style"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "description"
                        || key = "diff_view_style"
                        || key = "full_name"
                        || key = "hide_activity"
                        || key = "hide_email"
                        || key = "language"
                        || key = "location"
                        || key = "theme"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Description = arg_1
                DiffViewStyle = arg_2
                FullName = arg_3
                HideActivity = arg_4
                HideEmail = arg_5
                Language = arg_6
                Location = arg_7
                Theme = arg_8
                Website = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WatchInfo type
[<AutoOpen>]
module WatchInfoJsonParseExtension =
    /// Extension methods for JSON parsing
    type WatchInfo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WatchInfo =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["subscribed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["repository_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["reason"] with
                | null -> None
                | v -> () |> Some

            let arg_2 =
                match node.["ignored"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created_at"
                        || key = "ignored"
                        || key = "reason"
                        || key = "repository_url"
                        || key = "subscribed"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Ignored = arg_2
                Reason = arg_3
                RepositoryUrl = arg_4
                Subscribed = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiCommit type
[<AutoOpen>]
module WikiCommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiCommit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiCommit =
            let arg_4 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["commiter"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "author" || key = "commiter" || key = "message" || key = "sha" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Commiter = arg_2
                Message = arg_3
                Sha = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiCommitList type
[<AutoOpen>]
module WikiCommitListJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiCommitList with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiCommitList =
            let arg_2 =
                match node.["count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["commits"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> WikiCommit.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commits" || key = "count" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commits = arg_1
                Count = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiPage type
[<AutoOpen>]
module WikiPageJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiPage with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiPage =
            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["sub_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["sidebar"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["last_commit"] with
                | null -> None
                | v -> WikiCommit.jsonParse v |> Some

            let arg_4 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["footer"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["content_base64"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commit_count"
                        || key = "content_base64"
                        || key = "footer"
                        || key = "html_url"
                        || key = "last_commit"
                        || key = "sidebar"
                        || key = "sub_url"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CommitCount = arg_1
                ContentBase64 = arg_2
                Footer = arg_3
                HtmlUrl = arg_4
                LastCommit = arg_5
                Sidebar = arg_6
                SubUrl = arg_7
                Title = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiPageMetaData type
[<AutoOpen>]
module WikiPageMetaDataJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiPageMetaData with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiPageMetaData =
            let arg_4 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["sub_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["last_commit"] with
                | null -> None
                | v -> WikiCommit.jsonParse v |> Some

            let arg_1 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "html_url" || key = "last_commit" || key = "sub_url" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                HtmlUrl = arg_1
                LastCommit = arg_2
                SubUrl = arg_3
                Title = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Comment type
[<AutoOpen>]
module CommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type Comment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Comment =
            let arg_11 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_10 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["pull_request_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["original_author_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["original_author"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["issue_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["assets"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Attachment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assets"
                        || key = "body"
                        || key = "created_at"
                        || key = "html_url"
                        || key = "id"
                        || key = "issue_url"
                        || key = "original_author"
                        || key = "original_author_id"
                        || key = "pull_request_url"
                        || key = "updated_at"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assets = arg_1
                Body = arg_2
                CreatedAt = arg_3
                HtmlUrl = arg_4
                Id = arg_5
                IssueUrl = arg_6
                OriginalAuthor = arg_7
                OriginalAuthorId = arg_8
                PullRequestUrl = arg_9
                UpdatedAt = arg_10
                User = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitStatus type
[<AutoOpen>]
module CommitStatusJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitStatus with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitStatus =
            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["target_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["status"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["creator"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "context"
                        || key = "created_at"
                        || key = "creator"
                        || key = "description"
                        || key = "id"
                        || key = "status"
                        || key = "target_url"
                        || key = "updated_at"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
                CreatedAt = arg_2
                Creator = arg_3
                Description = arg_4
                Id = arg_5
                Status = arg_6
                TargetUrl = arg_7
                UpdatedAt = arg_8
                Url = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ContentsResponse type
[<AutoOpen>]
module ContentsResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type ContentsResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ContentsResponse =
            let arg_15 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["target"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["submodule_git_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_10 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["last_commit_sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["git_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["encoding"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["download_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["_links"] with
                | null -> None
                | v -> FileLinksResponse.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "_links"
                        || key = "content"
                        || key = "download_url"
                        || key = "encoding"
                        || key = "git_url"
                        || key = "html_url"
                        || key = "last_commit_sha"
                        || key = "name"
                        || key = "path"
                        || key = "sha"
                        || key = "size"
                        || key = "submodule_git_url"
                        || key = "target"
                        || key = "type"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Links = arg_1
                Content = arg_2
                DownloadUrl = arg_3
                Encoding = arg_4
                GitUrl = arg_5
                HtmlUrl = arg_6
                LastCommitSha = arg_7
                Name = arg_8
                Path = arg_9
                Sha = arg_10
                Size = arg_11
                SubmoduleGitUrl = arg_12
                Target = arg_13
                Type = arg_14
                Url = arg_15
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateFileOptions type
[<AutoOpen>]
module CreateFileOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateFileOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateFileOptions =
            let arg_8 =
                match node.["signoff"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["new_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dates"] with
                | null -> None
                | v -> CommitDateOptions.jsonParse v |> Some

            let arg_4 =
                (match node.["content"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("content")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_2 =
                match node.["branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "branch"
                        || key = "committer"
                        || key = "content"
                        || key = "dates"
                        || key = "message"
                        || key = "new_branch"
                        || key = "signoff"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Branch = arg_2
                Committer = arg_3
                Content = arg_4
                Dates = arg_5
                Message = arg_6
                NewBranch = arg_7
                Signoff = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateHookOption type
[<AutoOpen>]
module CreateHookOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateHookOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateHookOption =
            let arg_6 =
                (match node.["type"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("type")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_5 =
                match node.["events"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                CreateHookOptionConfig.jsonParse (
                    match node.["config"] with
                    | null ->
                        raise (
                            System.Collections.Generic.KeyNotFoundException (
                                sprintf "Required key '%s' not found on JSON object" ("config")
                            )
                        )
                    | v -> v
                )

            let arg_3 =
                match node.["branch_filter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["authorization_header"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "authorization_header"
                        || key = "branch_filter"
                        || key = "config"
                        || key = "events"
                        || key = "type"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AuthorizationHeader = arg_2
                BranchFilter = arg_3
                Config = arg_4
                Events = arg_5
                Type = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePullReviewOptions type
[<AutoOpen>]
module CreatePullReviewOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePullReviewOptions =
            let arg_4 =
                match node.["event"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["commit_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["comments"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CreatePullReviewComment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" || key = "comments" || key = "commit_id" || key = "event" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Comments = arg_2
                CommitId = arg_3
                Event = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DeleteFileOptions type
[<AutoOpen>]
module DeleteFileOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type DeleteFileOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DeleteFileOptions =
            let arg_8 =
                match node.["signoff"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                (match node.["sha"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("sha")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_6 =
                match node.["new_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["dates"] with
                | null -> None
                | v -> CommitDateOptions.jsonParse v |> Some

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_2 =
                match node.["branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "branch"
                        || key = "committer"
                        || key = "dates"
                        || key = "message"
                        || key = "new_branch"
                        || key = "sha"
                        || key = "signoff"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Branch = arg_2
                Committer = arg_3
                Dates = arg_4
                Message = arg_5
                NewBranch = arg_6
                Sha = arg_7
                Signoff = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditRepoOption type
[<AutoOpen>]
module EditRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditRepoOption =
            let arg_27 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_26 =
                match node.["template"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_25 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_24 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_23 =
                match node.["mirror_interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_22 =
                match node.["internal_tracker"] with
                | null -> None
                | v -> InternalTracker.jsonParse v |> Some

            let arg_21 =
                match node.["ignore_whitespace_conflicts"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_20 =
                match node.["has_wiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_19 =
                match node.["has_pull_requests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["has_projects"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["has_issues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_16 =
                match node.["external_wiki"] with
                | null -> None
                | v -> ExternalWiki.jsonParse v |> Some

            let arg_15 =
                match node.["external_tracker"] with
                | null -> None
                | v -> ExternalTracker.jsonParse v |> Some

            let arg_14 =
                match node.["enable_prune"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["default_merge_style"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["default_delete_branch_after_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["default_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["default_allow_maintainer_edit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["autodetect_manual_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["archived"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["allow_squash_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["allow_rebase_update"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["allow_rebase_explicit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["allow_rebase"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["allow_merge_commits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allow_manual_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allow_manual_merge"
                        || key = "allow_merge_commits"
                        || key = "allow_rebase"
                        || key = "allow_rebase_explicit"
                        || key = "allow_rebase_update"
                        || key = "allow_squash_merge"
                        || key = "archived"
                        || key = "autodetect_manual_merge"
                        || key = "default_allow_maintainer_edit"
                        || key = "default_branch"
                        || key = "default_delete_branch_after_merge"
                        || key = "default_merge_style"
                        || key = "description"
                        || key = "enable_prune"
                        || key = "external_tracker"
                        || key = "external_wiki"
                        || key = "has_issues"
                        || key = "has_projects"
                        || key = "has_pull_requests"
                        || key = "has_wiki"
                        || key = "ignore_whitespace_conflicts"
                        || key = "internal_tracker"
                        || key = "mirror_interval"
                        || key = "name"
                        || key = "private"
                        || key = "template"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowManualMerge = arg_1
                AllowMergeCommits = arg_2
                AllowRebase = arg_3
                AllowRebaseExplicit = arg_4
                AllowRebaseUpdate = arg_5
                AllowSquashMerge = arg_6
                Archived = arg_7
                AutodetectManualMerge = arg_8
                DefaultAllowMaintainerEdit = arg_9
                DefaultBranch = arg_10
                DefaultDeleteBranchAfterMerge = arg_11
                DefaultMergeStyle = arg_12
                Description = arg_13
                EnablePrune = arg_14
                ExternalTracker = arg_15
                ExternalWiki = arg_16
                HasIssues = arg_17
                HasProjects = arg_18
                HasPullRequests = arg_19
                HasWiki = arg_20
                IgnoreWhitespaceConflicts = arg_21
                InternalTracker = arg_22
                MirrorInterval = arg_23
                Name = arg_24
                Private = arg_25
                Template = arg_26
                Website = arg_27
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueFormField type
[<AutoOpen>]
module IssueFormFieldJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueFormField with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueFormField =
            let arg_4 =
                match node.["validations"] with
                | null -> None
                | v -> Type6.jsonParse v |> Some

            let arg_3 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["attributes"] with
                | null -> None
                | v -> Type5.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "attributes" || key = "id" || key = "type" || key = "validations" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Attributes = arg_1
                Id = arg_2
                Type = arg_3
                Validations = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueTemplate type
[<AutoOpen>]
module IssueTemplateJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueTemplate with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueTemplate =
            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["file_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["body"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> IssueFormField.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["about"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "about"
                        || key = "body"
                        || key = "content"
                        || key = "file_name"
                        || key = "labels"
                        || key = "name"
                        || key = "ref"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                About = arg_1
                Body = arg_2
                Content = arg_3
                FileName = arg_4
                Labels = arg_5
                Name = arg_6
                Ref = arg_7
                Title = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Milestone type
[<AutoOpen>]
module MilestoneJsonParseExtension =
    /// Extension methods for JSON parsing
    type Milestone with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Milestone =
            let arg_10 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["open_issues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["due_on"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["closed_issues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["closed_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "closed_at"
                        || key = "closed_issues"
                        || key = "created_at"
                        || key = "description"
                        || key = "due_on"
                        || key = "id"
                        || key = "open_issues"
                        || key = "state"
                        || key = "title"
                        || key = "updated_at"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ClosedAt = arg_1
                ClosedIssues = arg_2
                CreatedAt = arg_3
                Description = arg_4
                DueOn = arg_5
                Id = arg_6
                OpenIssues = arg_7
                State = arg_8
                Title = arg_9
                UpdatedAt = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoUsage type
[<AutoOpen>]
module NodeInfoUsageJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsage with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoUsage =
            let arg_3 =
                match node.["users"] with
                | null -> None
                | v -> NodeInfoUsageUsers.jsonParse v |> Some

            let arg_2 =
                match node.["localPosts"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["localComments"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "localComments" || key = "localPosts" || key = "users" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                LocalComments = arg_1
                LocalPosts = arg_2
                Users = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NotificationSubject type
[<AutoOpen>]
module NotificationSubjectJsonParseExtension =
    /// Extension methods for JSON parsing
    type NotificationSubject with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NotificationSubject =
            let arg_7 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["latest_comment_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["latest_comment_html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "html_url"
                        || key = "latest_comment_html_url"
                        || key = "latest_comment_url"
                        || key = "state"
                        || key = "title"
                        || key = "type"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                HtmlUrl = arg_1
                LatestCommentHtmlUrl = arg_2
                LatestCommentUrl = arg_3
                State = arg_4
                Title = arg_5
                Type = arg_6
                Url = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PayloadCommitVerification type
[<AutoOpen>]
module PayloadCommitVerificationJsonParseExtension =
    /// Extension methods for JSON parsing
    type PayloadCommitVerification with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PayloadCommitVerification =
            let arg_5 =
                match node.["verified"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["signer"] with
                | null -> None
                | v -> PayloadUser.jsonParse v |> Some

            let arg_3 =
                match node.["signature"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["reason"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["payload"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "payload"
                        || key = "reason"
                        || key = "signature"
                        || key = "signer"
                        || key = "verified"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Payload = arg_1
                Reason = arg_2
                Signature = arg_3
                Signer = arg_4
                Verified = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PublicKey type
[<AutoOpen>]
module PublicKeyJsonParseExtension =
    /// Extension methods for JSON parsing
    type PublicKey with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PublicKey =
            let arg_9 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_8 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["read_only"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["key_type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["key"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["fingerprint"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created_at"
                        || key = "fingerprint"
                        || key = "id"
                        || key = "key"
                        || key = "key_type"
                        || key = "read_only"
                        || key = "title"
                        || key = "url"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Fingerprint = arg_2
                Id = arg_3
                Key = arg_4
                KeyType = arg_5
                ReadOnly = arg_6
                Title = arg_7
                Url = arg_8
                User = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullReview type
[<AutoOpen>]
module PullReviewJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullReview with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullReview =
            let arg_14 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_13 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["team"] with
                | null -> None
                | v -> Team.jsonParse v |> Some

            let arg_11 =
                match node.["submitted_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["stale"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["pull_request_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["official"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["dismissed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["commit_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["comments_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "comments_count"
                        || key = "commit_id"
                        || key = "dismissed"
                        || key = "html_url"
                        || key = "id"
                        || key = "official"
                        || key = "pull_request_url"
                        || key = "stale"
                        || key = "state"
                        || key = "submitted_at"
                        || key = "team"
                        || key = "updated_at"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                CommentsCount = arg_2
                CommitId = arg_3
                Dismissed = arg_4
                HtmlUrl = arg_5
                Id = arg_6
                Official = arg_7
                PullRequestUrl = arg_8
                Stale = arg_9
                State = arg_10
                SubmittedAt = arg_11
                Team = arg_12
                UpdatedAt = arg_13
                User = arg_14
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullReviewComment type
[<AutoOpen>]
module PullReviewCommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullReviewComment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullReviewComment =
            let arg_15 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_14 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["resolver"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_12 =
                match node.["pull_request_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["pull_request_review_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_10 =
                match node.["position"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_9 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["original_position"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["original_commit_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["diff_hunk"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["commit_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "commit_id"
                        || key = "created_at"
                        || key = "diff_hunk"
                        || key = "html_url"
                        || key = "id"
                        || key = "original_commit_id"
                        || key = "original_position"
                        || key = "path"
                        || key = "position"
                        || key = "pull_request_review_id"
                        || key = "pull_request_url"
                        || key = "resolver"
                        || key = "updated_at"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                CommitId = arg_2
                CreatedAt = arg_3
                DiffHunk = arg_4
                HtmlUrl = arg_5
                Id = arg_6
                OriginalCommitId = arg_7
                OriginalPosition = arg_8
                Path = arg_9
                Position = arg_10
                PullRequestReviewId = arg_11
                PullRequestUrl = arg_12
                Resolver = arg_13
                UpdatedAt = arg_14
                User = arg_15
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Reaction type
[<AutoOpen>]
module ReactionJsonParseExtension =
    /// Extension methods for JSON parsing
    type Reaction with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Reaction =
            let arg_3 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" || key = "created_at" || key = "user" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
                CreatedAt = arg_2
                User = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Release type
[<AutoOpen>]
module ReleaseJsonParseExtension =
    /// Extension methods for JSON parsing
    type Release with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Release =
            let arg_15 =
                match node.["zipball_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["target_commitish"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["tarball_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["tag_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["published_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["prerelease"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["draft"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["author"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["assets"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Attachment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assets"
                        || key = "author"
                        || key = "body"
                        || key = "created_at"
                        || key = "draft"
                        || key = "html_url"
                        || key = "id"
                        || key = "name"
                        || key = "prerelease"
                        || key = "published_at"
                        || key = "tag_name"
                        || key = "tarball_url"
                        || key = "target_commitish"
                        || key = "url"
                        || key = "zipball_url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assets = arg_1
                Author = arg_2
                Body = arg_3
                CreatedAt = arg_4
                Draft = arg_5
                HtmlUrl = arg_6
                Id = arg_7
                Name = arg_8
                Prerelease = arg_9
                PublishedAt = arg_10
                TagName = arg_11
                TarballUrl = arg_12
                TargetCommitish = arg_13
                Url = arg_14
                ZipballUrl = arg_15
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoCollaboratorPermission type
[<AutoOpen>]
module RepoCollaboratorPermissionJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoCollaboratorPermission with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoCollaboratorPermission =
            let arg_3 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["role_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "permission" || key = "role_name" || key = "user" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Permission = arg_1
                RoleName = arg_2
                User = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoCommit type
[<AutoOpen>]
module RepoCommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoCommit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoCommit =
            let arg_6 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_5 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["tree"] with
                | null -> None
                | v -> CommitMeta.jsonParse v |> Some

            let arg_3 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["committer"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "committer"
                        || key = "message"
                        || key = "tree"
                        || key = "url"
                        || key = "verification"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Committer = arg_2
                Message = arg_3
                Tree = arg_4
                Url = arg_5
                Verification = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoTransfer type
[<AutoOpen>]
module RepoTransferJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoTransfer with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoTransfer =
            let arg_3 =
                match node.["teams"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq |> Some

            let arg_2 =
                match node.["recipient"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["doer"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "doer" || key = "recipient" || key = "teams" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Doer = arg_1
                Recipient = arg_2
                Teams = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Repository type
[<AutoOpen>]
module RepositoryJsonParseExtension =
    /// Extension methods for JSON parsing
    type Repository with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Repository =
            let arg_52 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_51 =
                match node.["watchers_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_50 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_49 =
                match node.["template"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_48 =
                match node.["stars_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_47 =
                match node.["ssh_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_46 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_45 =
                match node.["repo_transfer"] with
                | null -> None
                | v -> RepoTransfer.jsonParse v |> Some

            let arg_44 =
                match node.["release_counter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_43 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_42 =
                match node.["permissions"] with
                | null -> None
                | v -> Permission.jsonParse v |> Some

            let arg_41 =
                match node.["parent"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_40 =
                match node.["owner"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_39 =
                match node.["original_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_38 =
                match node.["open_pr_counter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_37 =
                match node.["open_issues_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_36 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_35 =
                match node.["mirror_updated"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_34 =
                match node.["mirror_interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_33 =
                match node.["mirror"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_32 =
                match node.["link"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_31 =
                match node.["languages_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_30 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_29 =
                match node.["internal_tracker"] with
                | null -> None
                | v -> InternalTracker.jsonParse v |> Some

            let arg_28 =
                match node.["internal"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_27 =
                match node.["ignore_whitespace_conflicts"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_26 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_25 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_24 =
                match node.["has_wiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_23 =
                match node.["has_pull_requests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_22 =
                match node.["has_projects"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_21 =
                match node.["has_issues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_20 =
                match node.["full_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_19 =
                match node.["forks_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_18 =
                match node.["fork"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["external_wiki"] with
                | null -> None
                | v -> ExternalWiki.jsonParse v |> Some

            let arg_16 =
                match node.["external_tracker"] with
                | null -> None
                | v -> ExternalTracker.jsonParse v |> Some

            let arg_15 =
                match node.["empty"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_14 =
                match node.["description"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["default_merge_style"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["default_delete_branch_after_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["default_branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["default_allow_maintainer_edit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["clone_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["avatar_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["archived"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["allow_squash_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["allow_rebase_update"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["allow_rebase_explicit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["allow_rebase"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allow_merge_commits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allow_merge_commits"
                        || key = "allow_rebase"
                        || key = "allow_rebase_explicit"
                        || key = "allow_rebase_update"
                        || key = "allow_squash_merge"
                        || key = "archived"
                        || key = "avatar_url"
                        || key = "clone_url"
                        || key = "created_at"
                        || key = "default_allow_maintainer_edit"
                        || key = "default_branch"
                        || key = "default_delete_branch_after_merge"
                        || key = "default_merge_style"
                        || key = "description"
                        || key = "empty"
                        || key = "external_tracker"
                        || key = "external_wiki"
                        || key = "fork"
                        || key = "forks_count"
                        || key = "full_name"
                        || key = "has_issues"
                        || key = "has_projects"
                        || key = "has_pull_requests"
                        || key = "has_wiki"
                        || key = "html_url"
                        || key = "id"
                        || key = "ignore_whitespace_conflicts"
                        || key = "internal"
                        || key = "internal_tracker"
                        || key = "language"
                        || key = "languages_url"
                        || key = "link"
                        || key = "mirror"
                        || key = "mirror_interval"
                        || key = "mirror_updated"
                        || key = "name"
                        || key = "open_issues_count"
                        || key = "open_pr_counter"
                        || key = "original_url"
                        || key = "owner"
                        || key = "parent"
                        || key = "permissions"
                        || key = "private"
                        || key = "release_counter"
                        || key = "repo_transfer"
                        || key = "size"
                        || key = "ssh_url"
                        || key = "stars_count"
                        || key = "template"
                        || key = "updated_at"
                        || key = "watchers_count"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowMergeCommits = arg_1
                AllowRebase = arg_2
                AllowRebaseExplicit = arg_3
                AllowRebaseUpdate = arg_4
                AllowSquashMerge = arg_5
                Archived = arg_6
                AvatarUrl = arg_7
                CloneUrl = arg_8
                CreatedAt = arg_9
                DefaultAllowMaintainerEdit = arg_10
                DefaultBranch = arg_11
                DefaultDeleteBranchAfterMerge = arg_12
                DefaultMergeStyle = arg_13
                Description = arg_14
                Empty = arg_15
                ExternalTracker = arg_16
                ExternalWiki = arg_17
                Fork = arg_18
                ForksCount = arg_19
                FullName = arg_20
                HasIssues = arg_21
                HasProjects = arg_22
                HasPullRequests = arg_23
                HasWiki = arg_24
                HtmlUrl = arg_25
                Id = arg_26
                IgnoreWhitespaceConflicts = arg_27
                Internal = arg_28
                InternalTracker = arg_29
                Language = arg_30
                LanguagesUrl = arg_31
                Link = arg_32
                Mirror = arg_33
                MirrorInterval = arg_34
                MirrorUpdated = arg_35
                Name = arg_36
                OpenIssuesCount = arg_37
                OpenPrCounter = arg_38
                OriginalUrl = arg_39
                Owner = arg_40
                Parent = arg_41
                Permissions = arg_42
                Private = arg_43
                ReleaseCounter = arg_44
                RepoTransfer = arg_45
                Size = arg_46
                SshUrl = arg_47
                StarsCount = arg_48
                Template = arg_49
                UpdatedAt = arg_50
                WatchersCount = arg_51
                Website = arg_52
            }
namespace Gitea

/// Module containing JSON parsing extension members for the SearchResults type
[<AutoOpen>]
module SearchResultsJsonParseExtension =
    /// Extension methods for JSON parsing
    type SearchResults with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : SearchResults =
            let arg_2 =
                match node.["ok"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["data"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Repository.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "data" || key = "ok" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Data = arg_1
                Ok = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AnnotatedTag type
[<AutoOpen>]
module AnnotatedTagJsonParseExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTag with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AnnotatedTag =
            let arg_7 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["tagger"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_4 =
                match node.["tag"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["object"] with
                | null -> None
                | v -> AnnotatedTagObject.jsonParse v |> Some

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "message"
                        || key = "object"
                        || key = "sha"
                        || key = "tag"
                        || key = "tagger"
                        || key = "url"
                        || key = "verification"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                Object = arg_2
                Sha = arg_3
                Tag = arg_4
                Tagger = arg_5
                Url = arg_6
                Verification = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CombinedStatus type
[<AutoOpen>]
module CombinedStatusJsonParseExtension =
    /// Extension methods for JSON parsing
    type CombinedStatus with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CombinedStatus =
            let arg_7 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["total_count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["statuses"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitStatus.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_1 =
                match node.["commit_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commit_url"
                        || key = "repository"
                        || key = "sha"
                        || key = "state"
                        || key = "statuses"
                        || key = "total_count"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CommitUrl = arg_1
                Repository = arg_2
                Sha = arg_3
                State = arg_4
                Statuses = arg_5
                TotalCount = arg_6
                Url = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Commit type
[<AutoOpen>]
module CommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type Commit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Commit =
            let arg_10 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["stats"] with
                | null -> None
                | v -> CommitStats.jsonParse v |> Some

            let arg_8 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["parents"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitMeta.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["files"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitAffectedFiles.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["commit"] with
                | null -> None
                | v -> RepoCommit.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "commit"
                        || key = "committer"
                        || key = "created"
                        || key = "files"
                        || key = "html_url"
                        || key = "parents"
                        || key = "sha"
                        || key = "stats"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Commit = arg_2
                Committer = arg_3
                Created = arg_4
                Files = arg_5
                HtmlUrl = arg_6
                Parents = arg_7
                Sha = arg_8
                Stats = arg_9
                Url = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DeployKey type
[<AutoOpen>]
module DeployKeyJsonParseExtension =
    /// Extension methods for JSON parsing
    type DeployKey with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DeployKey =
            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_6 =
                match node.["read_only"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["key_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["key"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["fingerprint"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created_at"
                        || key = "fingerprint"
                        || key = "id"
                        || key = "key"
                        || key = "key_id"
                        || key = "read_only"
                        || key = "repository"
                        || key = "title"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Fingerprint = arg_2
                Id = arg_3
                Key = arg_4
                KeyId = arg_5
                ReadOnly = arg_6
                Repository = arg_7
                Title = arg_8
                Url = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileDeleteResponse type
[<AutoOpen>]
module FileDeleteResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileDeleteResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileDeleteResponse =
            let arg_3 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_2 =
                match node.["content"] with
                | null -> None
                | v -> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> FileCommitResponse.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commit" || key = "content" || key = "verification" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Content = arg_2
                Verification = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileResponse type
[<AutoOpen>]
module FileResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileResponse =
            let arg_3 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_2 =
                match node.["content"] with
                | null -> None
                | v -> ContentsResponse.jsonParse v |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> FileCommitResponse.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commit" || key = "content" || key = "verification" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Content = arg_2
                Verification = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Issue type
[<AutoOpen>]
module IssueJsonParseExtension =
    /// Extension methods for JSON parsing
    type Issue with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Issue =
            let arg_24 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_23 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_22 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_21 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_19 =
                match node.["repository"] with
                | null -> None
                | v -> RepositoryMeta.jsonParse v |> Some

            let arg_18 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["pull_request"] with
                | null -> None
                | v -> PullRequestMeta.jsonParse v |> Some

            let arg_16 =
                match node.["original_author_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_15 =
                match node.["original_author"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["number"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_13 =
                match node.["milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_12 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq |> Some

            let arg_11 =
                match node.["is_locked"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_9 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["comments"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["closed_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["assignees"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq |> Some

            let arg_2 =
                match node.["assignee"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["assets"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Attachment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assets"
                        || key = "assignee"
                        || key = "assignees"
                        || key = "body"
                        || key = "closed_at"
                        || key = "comments"
                        || key = "created_at"
                        || key = "due_date"
                        || key = "html_url"
                        || key = "id"
                        || key = "is_locked"
                        || key = "labels"
                        || key = "milestone"
                        || key = "number"
                        || key = "original_author"
                        || key = "original_author_id"
                        || key = "pull_request"
                        || key = "ref"
                        || key = "repository"
                        || key = "state"
                        || key = "title"
                        || key = "updated_at"
                        || key = "url"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assets = arg_1
                Assignee = arg_2
                Assignees = arg_3
                Body = arg_4
                ClosedAt = arg_5
                Comments = arg_6
                CreatedAt = arg_7
                DueDate = arg_8
                HtmlUrl = arg_9
                Id = arg_10
                IsLocked = arg_11
                Labels = arg_12
                Milestone = arg_13
                Number = arg_14
                OriginalAuthor = arg_15
                OriginalAuthorId = arg_16
                PullRequest = arg_17
                Ref = arg_18
                Repository = arg_19
                State = arg_20
                Title = arg_21
                UpdatedAt = arg_22
                Url = arg_23
                User = arg_24
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfo type
[<AutoOpen>]
module NodeInfoJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfo =
            let arg_7 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["usage"] with
                | null -> None
                | v -> NodeInfoUsage.jsonParse v |> Some

            let arg_5 =
                match node.["software"] with
                | null -> None
                | v -> NodeInfoSoftware.jsonParse v |> Some

            let arg_4 =
                match node.["services"] with
                | null -> None
                | v -> NodeInfoServices.jsonParse v |> Some

            let arg_3 =
                match node.["protocols"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["openRegistrations"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["metadata"] with
                | null -> None
                | v -> Type7.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "metadata"
                        || key = "openRegistrations"
                        || key = "protocols"
                        || key = "services"
                        || key = "software"
                        || key = "usage"
                        || key = "version"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Metadata = arg_1
                OpenRegistrations = arg_2
                Protocols = arg_3
                Services = arg_4
                Software = arg_5
                Usage = arg_6
                Version = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Note type
[<AutoOpen>]
module NoteJsonParseExtension =
    /// Extension methods for JSON parsing
    type Note with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Note =
            let arg_2 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> Commit.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commit" || key = "message" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Message = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NotificationThread type
[<AutoOpen>]
module NotificationThreadJsonParseExtension =
    /// Extension methods for JSON parsing
    type NotificationThread with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NotificationThread =
            let arg_7 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["unread"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["subject"] with
                | null -> None
                | v -> NotificationSubject.jsonParse v |> Some

            let arg_3 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_2 =
                match node.["pinned"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "id"
                        || key = "pinned"
                        || key = "repository"
                        || key = "subject"
                        || key = "unread"
                        || key = "updated_at"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Id = arg_1
                Pinned = arg_2
                Repository = arg_3
                Subject = arg_4
                Unread = arg_5
                UpdatedAt = arg_6
                Url = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PRBranchInfo type
[<AutoOpen>]
module PRBranchInfoJsonParseExtension =
    /// Extension methods for JSON parsing
    type PRBranchInfo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PRBranchInfo =
            let arg_5 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["repo_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["repo"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_2 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["label"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "label" || key = "ref" || key = "repo" || key = "repo_id" || key = "sha" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Label = arg_1
                Ref = arg_2
                Repo = arg_3
                RepoId = arg_4
                Sha = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Package type
[<AutoOpen>]
module PackageJsonParseExtension =
    /// Extension methods for JSON parsing
    type Package with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Package =
            let arg_8 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_5 =
                match node.["owner"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["creator"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created_at"
                        || key = "creator"
                        || key = "id"
                        || key = "name"
                        || key = "owner"
                        || key = "repository"
                        || key = "type"
                        || key = "version"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Creator = arg_2
                Id = arg_3
                Name = arg_4
                Owner = arg_5
                Repository = arg_6
                Type = arg_7
                Version = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PayloadCommit type
[<AutoOpen>]
module PayloadCommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type PayloadCommit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PayloadCommit =
            let arg_10 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["timestamp"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["removed"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["modified"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> PayloadUser.jsonParse v |> Some

            let arg_2 =
                match node.["author"] with
                | null -> None
                | v -> PayloadUser.jsonParse v |> Some

            let arg_1 =
                match node.["added"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "added"
                        || key = "author"
                        || key = "committer"
                        || key = "id"
                        || key = "message"
                        || key = "modified"
                        || key = "removed"
                        || key = "timestamp"
                        || key = "url"
                        || key = "verification"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Added = arg_1
                Author = arg_2
                Committer = arg_3
                Id = arg_4
                Message = arg_5
                Modified = arg_6
                Removed = arg_7
                Timestamp = arg_8
                Url = arg_9
                Verification = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullRequest type
[<AutoOpen>]
module PullRequestJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullRequest with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullRequest =
            let arg_29 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_28 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_27 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_26 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_25 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_24 =
                match node.["patch_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_23 =
                match node.["number"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_22 =
                match node.["milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_21 =
                match node.["merged_by"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_20 =
                match node.["merged_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_19 =
                match node.["merged"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["mergeable"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["merge_commit_sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_16 =
                match node.["merge_base"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq |> Some

            let arg_14 =
                match node.["is_locked"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_12 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["head"] with
                | null -> None
                | v -> PRBranchInfo.jsonParse v |> Some

            let arg_10 =
                match node.["due_date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["diff_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["comments"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["closed_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["base"] with
                | null -> None
                | v -> PRBranchInfo.jsonParse v |> Some

            let arg_3 =
                match node.["assignees"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq |> Some

            let arg_2 =
                match node.["assignee"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["allow_maintainer_edit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allow_maintainer_edit"
                        || key = "assignee"
                        || key = "assignees"
                        || key = "base"
                        || key = "body"
                        || key = "closed_at"
                        || key = "comments"
                        || key = "created_at"
                        || key = "diff_url"
                        || key = "due_date"
                        || key = "head"
                        || key = "html_url"
                        || key = "id"
                        || key = "is_locked"
                        || key = "labels"
                        || key = "merge_base"
                        || key = "merge_commit_sha"
                        || key = "mergeable"
                        || key = "merged"
                        || key = "merged_at"
                        || key = "merged_by"
                        || key = "milestone"
                        || key = "number"
                        || key = "patch_url"
                        || key = "state"
                        || key = "title"
                        || key = "updated_at"
                        || key = "url"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowMaintainerEdit = arg_1
                Assignee = arg_2
                Assignees = arg_3
                Base = arg_4
                Body = arg_5
                ClosedAt = arg_6
                Comments = arg_7
                CreatedAt = arg_8
                DiffUrl = arg_9
                DueDate = arg_10
                Head = arg_11
                HtmlUrl = arg_12
                Id = arg_13
                IsLocked = arg_14
                Labels = arg_15
                MergeBase = arg_16
                MergeCommitSha = arg_17
                Mergeable = arg_18
                Merged = arg_19
                MergedAt = arg_20
                MergedBy = arg_21
                Milestone = arg_22
                Number = arg_23
                PatchUrl = arg_24
                State = arg_25
                Title = arg_26
                UpdatedAt = arg_27
                Url = arg_28
                User = arg_29
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TrackedTime type
[<AutoOpen>]
module TrackedTimeJsonParseExtension =
    /// Extension methods for JSON parsing
    type TrackedTime with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TrackedTime =
            let arg_7 =
                match node.["user_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["user_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["time"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["issue_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["issue"] with
                | null -> None
                | v -> Issue.jsonParse v |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "id"
                        || key = "issue"
                        || key = "issue_id"
                        || key = "time"
                        || key = "user_id"
                        || key = "user_name"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Id = arg_2
                Issue = arg_3
                IssueId = arg_4
                Time = arg_5
                UserId = arg_6
                UserName = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Branch type
[<AutoOpen>]
module BranchJsonParseExtension =
    /// Extension methods for JSON parsing
    type Branch with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Branch =
            let arg_9 =
                match node.["user_can_push"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["user_can_merge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["status_check_contexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["required_approvals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["protected"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["enable_status_check"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["effective_branch_protection_name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> PayloadCommit.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commit"
                        || key = "effective_branch_protection_name"
                        || key = "enable_status_check"
                        || key = "name"
                        || key = "protected"
                        || key = "required_approvals"
                        || key = "status_check_contexts"
                        || key = "user_can_merge"
                        || key = "user_can_push"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                EffectiveBranchProtectionName = arg_2
                EnableStatusCheck = arg_3
                Name = arg_4
                Protected = arg_5
                RequiredApprovals = arg_6
                StatusCheckContexts = arg_7
                UserCanMerge = arg_8
                UserCanPush = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TimelineComment type
[<AutoOpen>]
module TimelineCommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type TimelineComment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TimelineComment =
            let arg_29 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_28 =
                match node.["updated_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_27 =
                match node.["type"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_26 =
                match node.["tracked_time"] with
                | null -> None
                | v -> TrackedTime.jsonParse v |> Some

            let arg_25 =
                match node.["review_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_24 =
                match node.["resolve_doer"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_23 =
                match node.["removed_assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_22 =
                match node.["ref_issue"] with
                | null -> None
                | v -> Issue.jsonParse v |> Some

            let arg_21 =
                match node.["ref_commit_sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["ref_comment"] with
                | null -> None
                | v -> Comment.jsonParse v |> Some

            let arg_19 =
                match node.["ref_action"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_18 =
                match node.["pull_request_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["project_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_16 =
                match node.["old_title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                match node.["old_ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["old_project_id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_13 =
                match node.["old_milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_12 =
                match node.["new_title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["new_ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_9 =
                match node.["label"] with
                | null -> None
                | v -> Label.jsonParse v |> Some

            let arg_8 =
                match node.["issue_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["html_url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dependent_issue"] with
                | null -> None
                | v -> Issue.jsonParse v |> Some

            let arg_4 =
                match node.["created_at"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignee_team"] with
                | null -> None
                | v -> Team.jsonParse v |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignee_team"
                        || key = "body"
                        || key = "created_at"
                        || key = "dependent_issue"
                        || key = "html_url"
                        || key = "id"
                        || key = "issue_url"
                        || key = "label"
                        || key = "milestone"
                        || key = "new_ref"
                        || key = "new_title"
                        || key = "old_milestone"
                        || key = "old_project_id"
                        || key = "old_ref"
                        || key = "old_title"
                        || key = "project_id"
                        || key = "pull_request_url"
                        || key = "ref_action"
                        || key = "ref_comment"
                        || key = "ref_commit_sha"
                        || key = "ref_issue"
                        || key = "removed_assignee"
                        || key = "resolve_doer"
                        || key = "review_id"
                        || key = "tracked_time"
                        || key = "type"
                        || key = "updated_at"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                AssigneeTeam = arg_2
                Body = arg_3
                CreatedAt = arg_4
                DependentIssue = arg_5
                HtmlUrl = arg_6
                Id = arg_7
                IssueUrl = arg_8
                Label = arg_9
                Milestone = arg_10
                NewRef = arg_11
                NewTitle = arg_12
                OldMilestone = arg_13
                OldProjectId = arg_14
                OldRef = arg_15
                OldTitle = arg_16
                ProjectId = arg_17
                PullRequestUrl = arg_18
                RefAction = arg_19
                RefComment = arg_20
                RefCommitSha = arg_21
                RefIssue = arg_22
                RemovedAssignee = arg_23
                ResolveDoer = arg_24
                ReviewId = arg_25
                TrackedTime = arg_26
                Type = arg_27
                UpdatedAt = arg_28
                User = arg_29
            }
namespace Gitea

/// Module containing JSON parsing extension members for the LanguageStatistics type
[<AutoOpen>]
module LanguageStatisticsJsonParseExtension =
    /// Extension methods for JSON parsing
    type LanguageStatistics with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : LanguageStatistics =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, int> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.Int32> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }

namespace Gitea

open WoofWare.Myriad.Plugins

/// Module for constructing a REST client.
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix) ; RequireQualifiedAccess>]
module Gitea =
    /// Create a REST client.
    let make (client : System.Net.Http.HttpClient) : IGitea =
        { new IGitea with
            member _.ActivitypubPerson (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "activitypub/user/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ActivityPub.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ActivitypubPersonInbox (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "activitypub/user/{username}/inbox"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCronList (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("admin/cron"
                                 + (if "admin/cron".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Cron.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCronRun (task : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/cron/{task}".Replace ("{task}", task.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminListHooks (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("admin/hooks"
                                 + (if "admin/hooks".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Hook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateHook (body : CreateHookOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("admin/hooks", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminGetHook (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/hooks/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminEditHook (id : int, body : EditHookOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/hooks/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminGetAllOrgs (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("admin/orgs"
                                 + (if "admin/orgs".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminUnadoptedList
                (page : int, limit : int, pattern : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("admin/unadopted"
                                 + (if "admin/unadopted".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&pattern="
                                 + ((pattern.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminAdoptRepository
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/unadopted/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteUnadoptedRepository
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/unadopted/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminGetAllUsers (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("admin/users"
                                 + (if "admin/users".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateUser (body : CreateUserOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("admin/users", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateUserOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteUser (username : string, purge : bool, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("admin/users/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "admin/users/{username}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "purge="
                                 + ((purge.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminEditUser
                (username : string, body : EditUserOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/users/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditUserOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreatePublicKey
                (username : string, key : CreateKeyOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/users/{username}/keys"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            key
                            |> CreateKeyOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PublicKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteUserPublicKey
                (username : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/users/{username}/keys/{id}"
                                    .Replace("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateOrg
                (username : string, organization : CreateOrgOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/users/{username}/orgs"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            organization
                            |> CreateOrgOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateRepo
                (username : string, repository : CreateRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "admin/users/{username}/repos"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            repository
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteHook (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "amdin/hooks/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RenderMarkdown (body : MarkdownOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("markdown", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> MarkdownOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "text/html"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RenderMarkdownRaw (body : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("markdown/raw", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams = new System.Net.Http.StringContent (body, null, "text/html")
                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetNodeInfo (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("nodeinfo", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NodeInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyGetList
                (
                    all : bool,
                    status_types : string list,
                    subject_type : string list,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("notifications"
                                 + (if "notifications".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "all="
                                 + ((all.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&subject-type="
                                 + ((subject_type.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyReadList
                (
                    last_read_at : string,
                    all : string,
                    status_types : string list,
                    to_status : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("notifications"
                                 + (if "notifications".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "last_read_at="
                                 + ((last_read_at.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&all="
                                 + ((all.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&to-status="
                                 + ((to_status.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyNewAvailable (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("notifications/new", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NotificationCount.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyGetThread (id : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "notifications/threads/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NotificationThread.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyReadThread
                (id : string, to_status : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("notifications/threads/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                 + (if "notifications/threads/{id}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "to-status="
                                 + ((to_status.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NotificationThread.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateOrgRepoDeprecated
                (org : string, body : CreateRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "org/{org}/repos".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetAll (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs"
                                 + (if "orgs".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreate (organization : CreateOrgOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("orgs", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            organization
                            |> CreateOrgOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGet (org : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDelete (org : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEdit (org : string, body : EditOrgOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditOrgOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListHooks
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/hooks".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/hooks".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Hook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreateHook
                (org : string, body : CreateHookOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/hooks".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetHook (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/hooks/{id}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteHook (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/hooks/{id}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEditHook
                (org : string, id : int, body : EditHookOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/hooks/{id}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListLabels
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/labels".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/labels".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreateLabel
                (org : string, body : CreateLabelOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/labels".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetLabel (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/labels/{id}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteLabel (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/labels/{id}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEditLabel
                (org : string, id : int, body : EditLabelOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/labels/{id}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListMembers
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/members".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/members".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgIsMember (org : string, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteMember (org : string, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListPublicMembers
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/public_members"
                                    .Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/public_members".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgIsPublicMember
                (org : string, username : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/public_members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgConcealMember
                (org : string, username : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/public_members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgPublicizeMember
                (org : string, username : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/public_members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListRepos
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/repos".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/repos".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateOrgRepo
                (org : string, body : CreateRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/repos".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeams
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/teams".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/teams".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreateTeam
                (org : string, body : CreateTeamOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "orgs/{org}/teams".Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateTeamOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.TeamSearch
                (
                    org : string,
                    q : string,
                    include_desc : bool,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("orgs/{org}/teams/search"
                                    .Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                 + (if "orgs/{org}/teams/search".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&include_desc="
                                 + ((include_desc.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ListPackages
                (
                    owner : string,
                    page : int,
                    limit : int,
                    type' : string,
                    q : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("packages/{owner}"
                                    .Replace ("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                 + (if "packages/{owner}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&type="
                                 + ((type'.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Package.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetPackage
                (
                    owner : string,
                    type' : string,
                    name : string,
                    version : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "packages/{owner}/{type}/{name}/{version}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{type}", type'.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{name}", name.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{version}", version.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Package.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.DeletePackage
                (
                    owner : string,
                    type' : string,
                    name : string,
                    version : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "packages/{owner}/{type}/{name}/{version}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{type}", type'.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{name}", name.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{version}", version.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ListPackageFiles
                (
                    owner : string,
                    type' : string,
                    name : string,
                    version : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "packages/{owner}/{type}/{name}/{version}/files"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{type}", type'.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{name}", name.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{version}", version.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PackageFile.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueSearchIssues
                (
                    state : string,
                    labels : string,
                    milestones : string,
                    q : string,
                    priority_repo_id : int,
                    type' : string,
                    since : string,
                    before : string,
                    assigned : bool,
                    created : bool,
                    mentioned : bool,
                    review_requested : bool,
                    owner : string,
                    team : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/issues/search"
                                 + (if "repos/issues/search".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&labels="
                                 + ((labels.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&milestones="
                                 + ((milestones.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&priority_repo_id="
                                 + ((priority_repo_id.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&type="
                                 + ((type'.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&assigned="
                                 + ((assigned.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&created="
                                 + ((created.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&mentioned="
                                 + ((mentioned.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&review_requested="
                                 + ((review_requested.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&owner="
                                 + ((owner.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&team="
                                 + ((team.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Issue.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoMigrate (body : MigrateRepoOptions, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("repos/migrate", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> MigrateRepoOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoSearch
                (
                    q : string,
                    topic : bool,
                    includeDesc : bool,
                    uid : int,
                    priority_owner_id : int,
                    team_id : int,
                    starredBy : int,
                    private' : bool,
                    is_private : bool,
                    template : bool,
                    archived : bool,
                    mode : string,
                    exclusive : bool,
                    sort : string,
                    order : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/search"
                                 + (if "repos/search".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&topic="
                                 + ((topic.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&includeDesc="
                                 + ((includeDesc.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&uid="
                                 + ((uid.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&priority_owner_id="
                                 + ((priority_owner_id.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&team_id="
                                 + ((team_id.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&starredBy="
                                 + ((starredBy.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&private="
                                 + ((private'.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&is_private="
                                 + ((is_private.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&template="
                                 + ((template.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&archived="
                                 + ((archived.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&mode="
                                 + ((mode.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&exclusive="
                                 + ((exclusive.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&sort="
                                 + ((sort.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&order="
                                 + ((order.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return SearchResults.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGet (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDelete (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEdit
                (owner : string, repo : string, body : EditRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetArchive
                (owner : string, repo : string, archive : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/archive/{archive}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{archive}", archive.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetAssignees (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/assignees"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListBranchProtection
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branch_protections"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> BranchProtection.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateBranchProtection
                (
                    owner : string,
                    repo : string,
                    body : CreateBranchProtectionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branch_protections"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateBranchProtectionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return BranchProtection.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetBranchProtection
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branch_protections/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{name}", name.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return BranchProtection.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteBranchProtection
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branch_protections/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{name}", name.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditBranchProtection
                (
                    owner : string,
                    repo : string,
                    name : string,
                    body : EditBranchProtectionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branch_protections/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{name}", name.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditBranchProtectionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return BranchProtection.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListBranches
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/branches"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/branches".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Branch.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateBranch
                (
                    owner : string,
                    repo : string,
                    body : CreateBranchRepoOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branches"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateBranchRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Branch.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetBranch
                (owner : string, repo : string, branch : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branches/{branch}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{branch}", branch.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Branch.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteBranch
                (owner : string, repo : string, branch : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/branches/{branch}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{branch}", branch.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListCollaborators
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/collaborators"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/collaborators".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCheckCollaborator
                (owner : string, repo : string, collaborator : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/collaborators/{collaborator}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{collaborator}", collaborator.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteCollaborator
                (owner : string, repo : string, collaborator : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/collaborators/{collaborator}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{collaborator}", collaborator.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddCollaborator
                (
                    owner : string,
                    repo : string,
                    collaborator : string,
                    body : AddCollaboratorOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/collaborators/{collaborator}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{collaborator}", collaborator.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> AddCollaboratorOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRepoPermissions
                (owner : string, repo : string, collaborator : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/collaborators/{collaborator}/permission"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{collaborator}", collaborator.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return RepoCollaboratorPermission.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetAllCommits
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    path : string,
                    stat : bool,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/commits"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/commits".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "sha="
                                 + ((sha.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&path="
                                 + ((path.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&stat="
                                 + ((stat.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Commit.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetCombinedStatusByRef
                (
                    owner : string,
                    repo : string,
                    ref : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/commits/{ref}/status"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{ref}", ref.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/commits/{ref}/status".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return CombinedStatus.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListStatusesByRef
                (
                    owner : string,
                    repo : string,
                    ref : string,
                    sort : string,
                    state : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/commits/{ref}/statuses"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{ref}", ref.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/commits/{ref}/statuses".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "sort="
                                 + ((sort.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&state="
                                 + ((state.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> CommitStatus.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetContentsList
                (owner : string, repo : string, ref : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/contents"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/contents".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> ContentsResponse.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetContents
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/contents/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ContentsResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    body : CreateFileOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    body : DeleteFileOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> DeleteFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileDeleteResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUpdateFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    body : UpdateFileOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> UpdateFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoApplyDiffPatch
                (owner : string, repo : string, body : UpdateFileOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/diffpatch"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> UpdateFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetEditorConfig
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/editorconfig/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/editorconfig/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ListForks
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/forks"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/forks".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateFork
                (owner : string, repo : string, body : CreateForkOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/forks"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateForkOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetBlob
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/blobs/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitBlobResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetSingleCommit
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/commits/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Commit.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDownloadCommitDiffOrPatch
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    diffType : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/commits/{sha}.{diffType}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{sha}", sha.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{diffType}", diffType.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetNote
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/notes/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Note.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListAllGitRefs
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/refs"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Reference.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListGitRefs
                (owner : string, repo : string, ref : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/refs/{ref}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{ref}", ref.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Reference.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetAnnotatedTag
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/git/tags/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return AnnotatedTag.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetTree
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    recursive : bool,
                    page : int,
                    per_page : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/git/trees/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/git/trees/{sha}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "recursive="
                                 + ((recursive.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&per_page="
                                 + ((per_page.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitTreeResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListHooks
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/hooks"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/hooks".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Hook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateHook
                (owner : string, repo : string, body : CreateHookOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListGitHooks (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/git"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> GitHook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetGitHook
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/git/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitHook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteGitHook
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/git/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditGitHook
                (
                    owner : string,
                    repo : string,
                    id : string,
                    body : EditGitHookOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/git/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditGitHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitHook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetHook
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteHook
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditHook
                (
                    owner : string,
                    repo : string,
                    id : int,
                    body : EditHookOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/hooks/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoTestHook
                (owner : string, repo : string, id : int, ref : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/hooks/{id}/tests"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/hooks/{id}/tests".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetIssueTemplates
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issue_templates"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> IssueTemplate.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListIssues
                (
                    owner : string,
                    repo : string,
                    state : string,
                    labels : string,
                    q : string,
                    type' : string,
                    milestones : string,
                    since : string,
                    before : string,
                    created_by : string,
                    assigned_by : string,
                    mentioned_by : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&labels="
                                 + ((labels.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&type="
                                 + ((type'.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&milestones="
                                 + ((milestones.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&created_by="
                                 + ((created_by.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&assigned_by="
                                 + ((assigned_by.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&mentioned_by="
                                 + ((mentioned_by.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Issue.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateIssue
                (owner : string, repo : string, body : CreateIssueOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateIssueOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Issue.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetRepoComments
                (
                    owner : string,
                    repo : string,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues/comments".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Comment.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteComment
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListIssueCommentAttachments
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}/assets"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Attachment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssueCommentAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteIssueCommentAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssueCommentAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    body : EditAttachmentOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditAttachmentOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetCommentReactions
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Reaction.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteCommentReaction
                (
                    owner : string,
                    repo : string,
                    id : int,
                    content : EditReactionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/comments/{id}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            content
                            |> EditReactionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssue
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Issue.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDelete
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssue
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : EditIssueOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditIssueOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Issue.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListIssueAttachments
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/assets"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Attachment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssueAttachment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteIssueAttachment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssueAttachment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    attachment_id : int,
                    body : EditAttachmentOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditAttachmentOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetComments
                (
                    owner : string,
                    repo : string,
                    index : int,
                    since : string,
                    before : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues/{index}/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues/{index}/comments".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Comment.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateComment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : CreateIssueCommentOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateIssueCommentOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Comment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteCommentDeprecated
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/comments/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssueDeadline
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : EditDeadlineOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/deadline"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditDeadlineOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return IssueDeadline.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetLabels
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueAddLabel
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : IssueLabelsOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> IssueLabelsOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueClearLabels
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueReplaceLabels
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : IssueLabelsOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> IssueLabelsOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueRemoveLabel
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssueReactions
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues/{index}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues/{index}/reactions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Reaction.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteIssueReaction
                (
                    owner : string,
                    repo : string,
                    index : int,
                    content : EditReactionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            content
                            |> EditReactionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteStopWatch
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/stopwatch/delete"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueStartStopWatch
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/stopwatch/start"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueStopStopWatch
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/stopwatch/stop"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueSubscriptions
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues/{index}/subscriptions"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues/{index}/subscriptions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCheckSubscription
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/subscriptions/check"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WatchInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetCommentsAndTimeline
                (
                    owner : string,
                    repo : string,
                    index : int,
                    since : string,
                    page : int,
                    limit : int,
                    before : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues/{index}/timeline"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues/{index}/timeline".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TimelineComment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueTrackedTimes
                (
                    owner : string,
                    repo : string,
                    index : int,
                    user : string,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/issues/{index}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/issues/{index}/times".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "user="
                                 + ((user.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueAddTime
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : AddTimeOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> AddTimeOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return TrackedTime.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueResetTime
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteTime
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/issues/{index}/times/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListKeys
                (
                    owner : string,
                    repo : string,
                    key_id : int,
                    fingerprint : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/keys"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/keys".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "key_id="
                                 + ((key_id.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&fingerprint="
                                 + ((fingerprint.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> DeployKey.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateKey
                (owner : string, repo : string, body : CreateKeyOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/keys"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateKeyOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return DeployKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetKey
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/keys/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return DeployKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteKey
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/keys/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListLabels
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/labels".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateLabel
                (owner : string, repo : string, body : CreateLabelOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetLabel
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteLabel
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditLabel
                (
                    owner : string,
                    repo : string,
                    id : int,
                    body : EditLabelOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetLanguages (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/languages"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return LanguageStatistics.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRawFileOrLFS
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/media/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/media/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetMilestonesList
                (
                    owner : string,
                    repo : string,
                    state : string,
                    name : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/milestones"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/milestones".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&name="
                                 + ((name.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Milestone.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateMilestone
                (
                    owner : string,
                    repo : string,
                    body : CreateMilestoneOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/milestones"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateMilestoneOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Milestone.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetMilestone
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/milestones/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Milestone.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteMilestone
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/milestones/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditMilestone
                (
                    owner : string,
                    repo : string,
                    id : string,
                    body : EditMilestoneOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/milestones/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditMilestoneOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Milestone.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoMirrorSync (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/mirror-sync"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyGetRepoList
                (
                    owner : string,
                    repo : string,
                    all : bool,
                    status_types : string list,
                    subject_type : string list,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/notifications"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/notifications".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "all="
                                 + ((all.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&subject-type="
                                 + ((subject_type.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyReadRepoList
                (
                    owner : string,
                    repo : string,
                    all : string,
                    status_types : string list,
                    to_status : string,
                    last_read_at : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/notifications"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/notifications".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "all="
                                 + ((all.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&to-status="
                                 + ((to_status.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&last_read_at="
                                 + ((last_read_at.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListPullRequests
                (
                    owner : string,
                    repo : string,
                    state : string,
                    sort : string,
                    milestone : int,
                    labels : int list,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/pulls"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/pulls".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&sort="
                                 + ((sort.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&milestone="
                                 + ((milestone.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&labels="
                                 + ((labels.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullRequest.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreatePullRequest
                (
                    owner : string,
                    repo : string,
                    body : CreatePullRequestOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreatePullRequestOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullRequest.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullRequest
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullRequest.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditPullRequest
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : EditPullRequestOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditPullRequestOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullRequest.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDownloadPullDiffOrPatch
                (
                    owner : string,
                    repo : string,
                    index : int,
                    diffType : string,
                    binary : bool,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/pulls/{index}.{diffType}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{diffType}", diffType.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/pulls/{index}.{diffType}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "binary="
                                 + ((binary.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullRequestCommits
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/pulls/{index}/commits"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/pulls/{index}/commits".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Commit.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullRequestFiles
                (
                    owner : string,
                    repo : string,
                    index : int,
                    skip_to : string,
                    whitespace : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/pulls/{index}/files"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/pulls/{index}/files".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "skip-to="
                                 + ((skip_to.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&whitespace="
                                 + ((whitespace.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> ChangedFile.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoPullRequestIsMerged
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/merge"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoMergePullRequest
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : MergePullRequestOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/merge"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> MergePullRequestOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCancelScheduledAutoMerge
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/merge"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreatePullReviewRequests
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : PullReviewRequestOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/requested_reviewers"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> PullReviewRequestOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullReview.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeletePullReviewRequests
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : PullReviewRequestOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/requested_reviewers"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> PullReviewRequestOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListPullReviews
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/pulls/{index}/reviews"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/pulls/{index}/reviews".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullReview.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreatePullReview
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : CreatePullReviewOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreatePullReviewOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullReview
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoSubmitPullReview
                (
                    owner : string,
                    repo : string,
                    index : int,
                    id : int,
                    body : SubmitPullReviewOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> SubmitPullReviewOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeletePullReview
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullReviewComments
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullReviewComment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDismissPullReview
                (
                    owner : string,
                    repo : string,
                    index : int,
                    id : int,
                    body : DismissPullReviewOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> DismissPullReviewOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUnDismissPullReview
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUpdatePullRequest
                (
                    owner : string,
                    repo : string,
                    index : int,
                    style : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/pulls/{index}/update"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{index}", index.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/pulls/{index}/update".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "style="
                                 + ((style.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListPushMirrors
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/push_mirrors"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/push_mirrors".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PushMirror.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddPushMirror
                (
                    owner : string,
                    repo : string,
                    body : CreatePushMirrorOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/push_mirrors"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreatePushMirrorOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PushMirror.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoPushMirrorSync
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/push_mirrors-sync"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPushMirrorByRemoteName
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/push_mirrors/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{name}", name.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PushMirror.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeletePushMirror
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/push_mirrors/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{name}", name.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRawFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/raw/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/raw/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListReleases
                (
                    owner : string,
                    repo : string,
                    draft : bool,
                    pre_release : bool,
                    per_page : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/releases"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/releases".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "draft="
                                 + ((draft.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&pre-release="
                                 + ((pre_release.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&per_page="
                                 + ((per_page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Release.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateRelease
                (
                    owner : string,
                    repo : string,
                    body : CreateReleaseOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateReleaseOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetLatestRelease
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/latest"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetReleaseByTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{tag}", tag.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteReleaseByTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{tag}", tag.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRelease
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteRelease
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditRelease
                (
                    owner : string,
                    repo : string,
                    id : int,
                    body : EditReleaseOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditReleaseOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListReleaseAttachments
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}/assets"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Attachment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetReleaseAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteReleaseAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditReleaseAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    body : EditAttachmentOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditAttachmentOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetReviewers (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/reviewers"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoSigningKey (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/signing-key.gpg"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListStargazers
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/stargazers"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/stargazers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListStatuses
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    sort : string,
                    state : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/statuses/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/statuses/{sha}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "sort="
                                 + ((sort.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&state="
                                 + ((state.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> CommitStatus.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateStatus
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    body : CreateStatusOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/statuses/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{sha}", sha.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateStatusOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return CommitStatus.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListSubscribers
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/subscribers"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/subscribers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentCheckSubscription
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/subscription"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WatchInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteSubscription
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/subscription"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPutSubscription
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/subscription"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WatchInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListTags
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/tags"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/tags".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Tag.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateTag
                (owner : string, repo : string, body : CreateTagOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/tags"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateTagOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Tag.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{tag}", tag.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Tag.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{tag}", tag.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListTeams (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/teams"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCheckTeam
                (owner : string, repo : string, team : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/teams/{team}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{team}", team.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteTeam
                (owner : string, repo : string, team : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/teams/{team}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{team}", team.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddTeam
                (owner : string, repo : string, team : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/teams/{team}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{team}", team.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoTrackedTimes
                (
                    owner : string,
                    repo : string,
                    user : string,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/times".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "user="
                                 + ((user.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserTrackedTimes
                (owner : string, repo : string, user : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/times/{user}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{user}", user.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListTopics
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/topics"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/topics".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return TopicName.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUpdateTopics
                (owner : string, repo : string, body : RepoTopicOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/topics"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> RepoTopicOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteTopic
                (owner : string, repo : string, topic : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/topics/{topic}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{topic}", topic.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddTopic
                (owner : string, repo : string, topic : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/topics/{topic}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{topic}", topic.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoTransfer
                (
                    owner : string,
                    repo : string,
                    body : TransferRepoOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/transfer"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> TransferRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AcceptRepoTransfer
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/transfer/accept"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RejectRepoTransfer
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/transfer/reject"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateWikiPage
                (
                    owner : string,
                    repo : string,
                    body : CreateWikiPageOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/wiki/new"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateWikiPageOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiPage.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetWikiPage
                (owner : string, repo : string, pageName : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/wiki/page/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiPage.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteWikiPage
                (owner : string, repo : string, pageName : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/wiki/page/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditWikiPage
                (
                    owner : string,
                    repo : string,
                    pageName : string,
                    body : CreateWikiPageOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{owner}/{repo}/wiki/page/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateWikiPageOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiPage.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetWikiPages
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/wiki/pages"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/wiki/pages".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> WikiPageMetaData.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetWikiPageRevisions
                (
                    owner : string,
                    repo : string,
                    pageName : string,
                    page : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("repos/{owner}/{repo}/wiki/revisions/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{repo}", repo.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Uri.EscapeDataString)
                                 + (if "repos/{owner}/{repo}/wiki/revisions/{pageName}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiCommitList.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GenerateRepo
                (
                    template_owner : string,
                    template_repo : string,
                    body : GenerateRepoOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repos/{template_owner}/{template_repo}/generate"
                                    .Replace(
                                        "{template_owner}",
                                        template_owner.ToString () |> System.Uri.EscapeDataString
                                    )
                                    .Replace (
                                        "{template_repo}",
                                        template_repo.ToString () |> System.Uri.EscapeDataString
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> GenerateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetByID (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "repositories/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralAPISettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("settings/api", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralAPISettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralAttachmentSettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("settings/attachment", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralAttachmentSettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralRepositorySettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("settings/repository", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralRepoSettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralUISettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("settings/ui", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralUISettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetSigningKey (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("signing-key.gpg", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetTeam (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteTeam (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEditTeam (id : int, body : EditTeamOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditTeamOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamMembers
                (id : int, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("teams/{id}/members".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                 + (if "teams/{id}/members".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamMember (id : int, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}/members/{username}"
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgRemoveTeamMember (id : int, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}/members/{username}"
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgAddTeamMember (id : int, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}/members/{username}"
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamRepos
                (id : int, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("teams/{id}/repos".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                 + (if "teams/{id}/repos".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamRepo
                (id : int, org : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}/repos/{org}/{repo}"
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgRemoveTeamRepository
                (id : int, org : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}/repos/{org}/{repo}"
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgAddTeamRepository
                (id : int, org : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "teams/{id}/repos/{org}/{repo}"
                                    .Replace("{id}", id.ToString () |> System.Uri.EscapeDataString)
                                    .Replace("{org}", org.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.TopicSearch (q : string, page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("topics/search"
                                 + (if "topics/search".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TopicResponse.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetCurrent (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetOauth2Application
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/applications/oauth2"
                                 + (if "user/applications/oauth2".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> OAuth2Application.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCreateOAuth2Application
                (body : CreateOAuth2ApplicationOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/applications/oauth2", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateOAuth2ApplicationOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OAuth2Application.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetOAuth2Application (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/applications/oauth2/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OAuth2Application.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserDeleteOAuth2Application (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/applications/oauth2/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserUpdateOAuth2Application
                (id : int, body : CreateOAuth2ApplicationOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/applications/oauth2/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateOAuth2ApplicationOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OAuth2Application.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListEmails (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/emails", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Email.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserAddEmail (body : CreateEmailOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/emails", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateEmailOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Email.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserDeleteEmail (body : DeleteEmailOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/emails", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> DeleteEmailOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListFollowers
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/followers"
                                 + (if "user/followers".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListFollowing
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/following"
                                 + (if "user/following".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentCheckFollowing (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/following/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteFollow (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/following/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPutFollow (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/following/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetVerificationToken (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/gpg_key_token", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteGPGKey (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/gpg_keys/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListKeys
                (fingerprint : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/keys"
                                 + (if "user/keys".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "fingerprint="
                                 + ((fingerprint.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PublicKey.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPostKey (body : CreateKeyOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/keys", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateKeyOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PublicKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentGetKey (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/keys/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PublicKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteKey (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/keys/{id}".Replace ("{id}", id.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListCurrentUserOrgs (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/orgs"
                                 + (if "user/orgs".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListRepos (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/repos"
                                 + (if "user/repos".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateCurrentUserRepo (body : CreateRepoOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/repos", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetUserSettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/settings", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> UserSettings.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UpdateUserSettings (body : UserSettingsOptions, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("user/settings", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> UserSettingsOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> UserSettings.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListStarred (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/starred"
                                 + (if "user/starred".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentCheckStarring
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/starred/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteStar
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/starred/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPutStar
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "user/starred/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{repo}", repo.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetStopWatches (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/stopwatches"
                                 + (if "user/stopwatches".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> StopWatch.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListSubscriptions
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/subscriptions"
                                 + (if "user/subscriptions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListTeams (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/teams"
                                 + (if "user/teams".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentTrackedTimes
                (
                    page : int,
                    limit : int,
                    since : string,
                    before : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("user/times"
                                 + (if "user/times".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserSearch
                (q : string, uid : int, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/search"
                                 + (if "users/search".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&uid="
                                 + ((uid.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGet (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "users/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListFollowers
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/followers"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/followers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListFollowing
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/following"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/following".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCheckFollowing
                (username : string, target : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "users/{username}/following/{target}"
                                    .Replace("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{target}", target.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetHeatmapData (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "users/{username}/heatmap"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> UserHeatmapData.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListKeys
                (
                    username : string,
                    fingerprint : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/keys"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/keys".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "fingerprint="
                                 + ((fingerprint.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PublicKey.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListUserOrgs
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/orgs"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/orgs".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetUserPermissions
                (username : string, org : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "users/{username}/orgs/{org}/permissions"
                                    .Replace("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{org}", org.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OrganizationPermissions.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListRepos
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/repos"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/repos".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListStarred
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/starred"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/starred".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListSubscriptions
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/subscriptions"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/subscriptions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetTokens
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("users/{username}/tokens"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                 + (if "users/{username}/tokens".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Uri.EscapeDataString)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Uri.EscapeDataString)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> AccessToken.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCreateToken
                (username : string, body : CreateAccessTokenOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "users/{username}/tokens"
                                    .Replace ("{username}", username.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateAccessTokenOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ()),
                            null,
                            "application/json"
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return AccessToken.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserDeleteAccessToken
                (username : string, token : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "users/{username}/tokens/{token}"
                                    .Replace("{username}", username.ToString () |> System.Uri.EscapeDataString)
                                    .Replace ("{token}", token.ToString () |> System.Uri.EscapeDataString),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetVersion (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("version", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ServerVersion.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))
        }
