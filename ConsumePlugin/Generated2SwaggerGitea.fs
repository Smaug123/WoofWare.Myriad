//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------

namespace Gitea

open WoofWare.Myriad.Plugins

/// Mock record type for an interface
type internal GiteaMock =
    {
        /// Returns the Person actor for a user
        ActivitypubPerson :
            string * option<System.Threading.CancellationToken> -> ActivityPub System.Threading.Tasks.Task
        /// Send to the inbox
        ActivitypubPersonInbox : string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List cron tasks
        AdminCronList : int * int * option<System.Threading.CancellationToken> -> Cron list System.Threading.Tasks.Task
        /// Run cron task
        AdminCronRun : string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List system's webhooks
        AdminListHooks : int * int * option<System.Threading.CancellationToken> -> Hook list System.Threading.Tasks.Task
        /// Create a hook
        AdminCreateHook :
            CreateHookOption * option<System.Threading.CancellationToken> -> Hook System.Threading.Tasks.Task
        /// Get a hook
        AdminGetHook : int * option<System.Threading.CancellationToken> -> Hook System.Threading.Tasks.Task
        /// Update a hook
        AdminEditHook :
            int * EditHookOption * option<System.Threading.CancellationToken> -> Hook System.Threading.Tasks.Task
        /// List all organizations
        AdminGetAllOrgs :
            int * int * option<System.Threading.CancellationToken> -> Organization list System.Threading.Tasks.Task
        /// List unadopted repositories
        AdminUnadoptedList :
            int * int * string * option<System.Threading.CancellationToken> -> string list System.Threading.Tasks.Task
        /// Adopt unadopted files as a repository
        AdminAdoptRepository :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Delete unadopted files
        AdminDeleteUnadoptedRepository :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List all users
        AdminGetAllUsers :
            int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// Create a user
        AdminCreateUser :
            CreateUserOption * option<System.Threading.CancellationToken> -> User System.Threading.Tasks.Task
        /// Delete a user
        AdminDeleteUser : string * bool * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit an existing user
        AdminEditUser :
            string * EditUserOption * option<System.Threading.CancellationToken> -> User System.Threading.Tasks.Task
        /// Add a public key on behalf of a user
        AdminCreatePublicKey :
            string * CreateKeyOption * option<System.Threading.CancellationToken>
                -> PublicKey System.Threading.Tasks.Task
        /// Delete a user's public key
        AdminDeleteUserPublicKey :
            string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Create an organization
        AdminCreateOrg :
            string * CreateOrgOption * option<System.Threading.CancellationToken>
                -> Organization System.Threading.Tasks.Task
        /// Create a repository on behalf of a user
        AdminCreateRepo :
            string * CreateRepoOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// Delete a hook
        AdminDeleteHook : int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Render a markdown document as HTML
        RenderMarkdown :
            MarkdownOption * option<System.Threading.CancellationToken> -> string System.Threading.Tasks.Task
        /// Render raw markdown as HTML
        RenderMarkdownRaw : string * option<System.Threading.CancellationToken> -> string System.Threading.Tasks.Task
        /// Returns the nodeinfo of the Gitea application
        GetNodeInfo : option<System.Threading.CancellationToken> -> NodeInfo System.Threading.Tasks.Task
        /// List users's notification threads
        NotifyGetList :
            bool * string list * string list * string * string * int * int * option<System.Threading.CancellationToken>
                -> NotificationThread list System.Threading.Tasks.Task
        /// Mark notification threads as read, pinned or unread
        NotifyReadList :
            string * string * string list * string * option<System.Threading.CancellationToken>
                -> NotificationThread list System.Threading.Tasks.Task
        /// Check if unread notifications exist
        NotifyNewAvailable : option<System.Threading.CancellationToken> -> NotificationCount System.Threading.Tasks.Task
        /// Get notification thread by ID
        NotifyGetThread :
            string * option<System.Threading.CancellationToken> -> NotificationThread System.Threading.Tasks.Task
        /// Mark notification thread as read by ID
        NotifyReadThread :
            string * string * option<System.Threading.CancellationToken>
                -> NotificationThread System.Threading.Tasks.Task
        /// Create a repository in an organization
        CreateOrgRepoDeprecated :
            string * CreateRepoOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// Get list of organizations
        OrgGetAll :
            int * int * option<System.Threading.CancellationToken> -> Organization list System.Threading.Tasks.Task
        /// Create an organization
        OrgCreate :
            CreateOrgOption * option<System.Threading.CancellationToken> -> Organization System.Threading.Tasks.Task
        /// Get an organization
        OrgGet : string * option<System.Threading.CancellationToken> -> Organization System.Threading.Tasks.Task
        /// Delete an organization
        OrgDelete : string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit an organization
        OrgEdit :
            string * EditOrgOption * option<System.Threading.CancellationToken>
                -> Organization System.Threading.Tasks.Task
        /// List an organization's webhooks
        OrgListHooks :
            string * int * int * option<System.Threading.CancellationToken> -> Hook list System.Threading.Tasks.Task
        /// Create a hook
        OrgCreateHook :
            string * CreateHookOption * option<System.Threading.CancellationToken> -> Hook System.Threading.Tasks.Task
        /// Get a hook
        OrgGetHook : string * int * option<System.Threading.CancellationToken> -> Hook System.Threading.Tasks.Task
        /// Delete a hook
        OrgDeleteHook : string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Update a hook
        OrgEditHook :
            string * int * EditHookOption * option<System.Threading.CancellationToken>
                -> Hook System.Threading.Tasks.Task
        /// List an organization's labels
        OrgListLabels :
            string * int * int * option<System.Threading.CancellationToken> -> Label list System.Threading.Tasks.Task
        /// Create a label for an organization
        OrgCreateLabel :
            string * CreateLabelOption * option<System.Threading.CancellationToken> -> Label System.Threading.Tasks.Task
        /// Get a single label
        OrgGetLabel : string * int * option<System.Threading.CancellationToken> -> Label System.Threading.Tasks.Task
        /// Delete a label
        OrgDeleteLabel : string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Update a label
        OrgEditLabel :
            string * int * EditLabelOption * option<System.Threading.CancellationToken>
                -> Label System.Threading.Tasks.Task
        /// List an organization's members
        OrgListMembers :
            string * int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// Check if a user is a member of an organization
        OrgIsMember : string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Remove a member from an organization
        OrgDeleteMember :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List an organization's public members
        OrgListPublicMembers :
            string * int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// Check if a user is a public member of an organization
        OrgIsPublicMember :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Conceal a user's membership
        OrgConcealMember :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Publicize a user's membership
        OrgPublicizeMember :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List an organization's repos
        OrgListRepos :
            string * int * int * option<System.Threading.CancellationToken>
                -> Repository list System.Threading.Tasks.Task
        /// Create a repository in an organization
        CreateOrgRepo :
            string * CreateRepoOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// List an organization's teams
        OrgListTeams :
            string * int * int * option<System.Threading.CancellationToken> -> Team list System.Threading.Tasks.Task
        /// Create a team
        OrgCreateTeam :
            string * CreateTeamOption * option<System.Threading.CancellationToken> -> Team System.Threading.Tasks.Task
        /// Search for teams within an organization
        TeamSearch :
            string * string * bool * int * int * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Gets all packages of an owner
        ListPackages :
            string * int * int * string * string * option<System.Threading.CancellationToken>
                -> Package list System.Threading.Tasks.Task
        /// Gets a package
        GetPackage :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> Package System.Threading.Tasks.Task
        /// Delete a package
        DeletePackage :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Gets all files of a package
        ListPackageFiles :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> PackageFile list System.Threading.Tasks.Task
        /// Search for issues across the repositories that the user has access to
        IssueSearchIssues :
            string *
            string *
            string *
            string *
            int *
            string *
            string *
            string *
            bool *
            bool *
            bool *
            bool *
            string *
            string *
            int *
            int *
            option<System.Threading.CancellationToken>
                -> Issue list System.Threading.Tasks.Task
        /// Migrate a remote git repository
        RepoMigrate :
            MigrateRepoOptions * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Search for repositories
        RepoSearch :
            string *
            bool *
            bool *
            int *
            int *
            int *
            int *
            bool *
            bool *
            bool *
            bool *
            string *
            bool *
            string *
            string *
            int *
            int *
            option<System.Threading.CancellationToken>
                -> SearchResults System.Threading.Tasks.Task
        /// Get a repository
        RepoGet : string * string * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Delete a repository
        RepoDelete : string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a repository's properties. Only fields that are set will be changed.
        RepoEdit :
            string * string * EditRepoOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// Get an archive of a repository
        RepoGetArchive :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Return all users that have write access and can be assigned to issues
        RepoGetAssignees :
            string * string * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// List branch protections for a repository
        RepoListBranchProtection :
            string * string * option<System.Threading.CancellationToken>
                -> BranchProtection list System.Threading.Tasks.Task
        /// Create a branch protections for a repository
        RepoCreateBranchProtection :
            string * string * CreateBranchProtectionOption * option<System.Threading.CancellationToken>
                -> BranchProtection System.Threading.Tasks.Task
        /// Get a specific branch protection for the repository
        RepoGetBranchProtection :
            string * string * string * option<System.Threading.CancellationToken>
                -> BranchProtection System.Threading.Tasks.Task
        /// Delete a specific branch protection for the repository
        RepoDeleteBranchProtection :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a branch protections for a repository. Only fields that are set will be changed
        RepoEditBranchProtection :
            string * string * string * EditBranchProtectionOption * option<System.Threading.CancellationToken>
                -> BranchProtection System.Threading.Tasks.Task
        /// List a repository's branches
        RepoListBranches :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Branch list System.Threading.Tasks.Task
        /// Create a branch
        RepoCreateBranch :
            string * string * CreateBranchRepoOption * option<System.Threading.CancellationToken>
                -> Branch System.Threading.Tasks.Task
        /// Retrieve a specific branch from a repository, including its effective branch protection
        RepoGetBranch :
            string * string * string * option<System.Threading.CancellationToken> -> Branch System.Threading.Tasks.Task
        /// Delete a specific branch from a repository
        RepoDeleteBranch :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List a repository's collaborators
        RepoListCollaborators :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> User list System.Threading.Tasks.Task
        /// Check if a user is a collaborator of a repository
        RepoCheckCollaborator :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Delete a collaborator from a repository
        RepoDeleteCollaborator :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Add a collaborator to a repository
        RepoAddCollaborator :
            string * string * string * AddCollaboratorOption * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Get repository permissions for a user
        RepoGetRepoPermissions :
            string * string * string * option<System.Threading.CancellationToken>
                -> RepoCollaboratorPermission System.Threading.Tasks.Task
        /// Get a list of all commits from a repository
        RepoGetAllCommits :
            string * string * string * string * bool * int * int * option<System.Threading.CancellationToken>
                -> Commit list System.Threading.Tasks.Task
        /// Get a commit's combined status, by branch/tag/commit reference
        RepoGetCombinedStatusByRef :
            string * string * string * int * int * option<System.Threading.CancellationToken>
                -> CombinedStatus System.Threading.Tasks.Task
        /// Get a commit's statuses, by branch/tag/commit reference
        RepoListStatusesByRef :
            string * string * string * string * string * int * int * option<System.Threading.CancellationToken>
                -> CommitStatus list System.Threading.Tasks.Task
        /// Gets the metadata of all the entries of the root dir
        RepoGetContentsList :
            string * string * string * option<System.Threading.CancellationToken>
                -> ContentsResponse list System.Threading.Tasks.Task
        /// Gets the metadata and contents (if a file) of an entry in a repository, or a list of entries if a dir
        RepoGetContents :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> ContentsResponse System.Threading.Tasks.Task
        /// Create a file in a repository
        RepoCreateFile :
            string * string * string * CreateFileOptions * option<System.Threading.CancellationToken>
                -> FileResponse System.Threading.Tasks.Task
        /// Delete a file in a repository
        RepoDeleteFile :
            string * string * string * DeleteFileOptions * option<System.Threading.CancellationToken>
                -> FileDeleteResponse System.Threading.Tasks.Task
        /// Update a file in a repository
        RepoUpdateFile :
            string * string * string * UpdateFileOptions * option<System.Threading.CancellationToken>
                -> FileResponse System.Threading.Tasks.Task
        /// Apply diff patch to repository
        RepoApplyDiffPatch :
            string * string * UpdateFileOptions * option<System.Threading.CancellationToken>
                -> FileResponse System.Threading.Tasks.Task
        /// Get the EditorConfig definitions of a file in a repository
        RepoGetEditorConfig :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// List a repository's forks
        ListForks :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Repository list System.Threading.Tasks.Task
        /// Fork a repository
        CreateFork :
            string * string * CreateForkOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// Gets the blob of a repository.
        GetBlob :
            string * string * string * option<System.Threading.CancellationToken>
                -> GitBlobResponse System.Threading.Tasks.Task
        /// Get a single commit from a repository
        RepoGetSingleCommit :
            string * string * string * option<System.Threading.CancellationToken> -> Commit System.Threading.Tasks.Task
        /// Get a commit's diff or patch
        RepoDownloadCommitDiffOrPatch :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> string System.Threading.Tasks.Task
        /// Get a note corresponding to a single commit from a repository
        RepoGetNote :
            string * string * string * option<System.Threading.CancellationToken> -> Note System.Threading.Tasks.Task
        /// Get specified ref or filtered repository's refs
        RepoListAllGitRefs :
            string * string * option<System.Threading.CancellationToken> -> Reference list System.Threading.Tasks.Task
        /// Get specified ref or filtered repository's refs
        RepoListGitRefs :
            string * string * string * option<System.Threading.CancellationToken>
                -> Reference list System.Threading.Tasks.Task
        /// Gets the tag object of an annotated tag (not lightweight tags)
        GetAnnotatedTag :
            string * string * string * option<System.Threading.CancellationToken>
                -> AnnotatedTag System.Threading.Tasks.Task
        /// Gets the tree of a repository.
        GetTree :
            string * string * string * bool * int * int * option<System.Threading.CancellationToken>
                -> GitTreeResponse System.Threading.Tasks.Task
        /// List the hooks in a repository
        RepoListHooks :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Hook list System.Threading.Tasks.Task
        /// Create a hook
        RepoCreateHook :
            string * string * CreateHookOption * option<System.Threading.CancellationToken>
                -> Hook System.Threading.Tasks.Task
        /// List the Git hooks in a repository
        RepoListGitHooks :
            string * string * option<System.Threading.CancellationToken> -> GitHook list System.Threading.Tasks.Task
        /// Get a Git hook
        RepoGetGitHook :
            string * string * string * option<System.Threading.CancellationToken> -> GitHook System.Threading.Tasks.Task
        /// Delete a Git hook in a repository
        RepoDeleteGitHook :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a Git hook in a repository
        RepoEditGitHook :
            string * string * string * EditGitHookOption * option<System.Threading.CancellationToken>
                -> GitHook System.Threading.Tasks.Task
        /// Get a hook
        RepoGetHook :
            string * string * int * option<System.Threading.CancellationToken> -> Hook System.Threading.Tasks.Task
        /// Delete a hook in a repository
        RepoDeleteHook :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a hook in a repository
        RepoEditHook :
            string * string * int * EditHookOption * option<System.Threading.CancellationToken>
                -> Hook System.Threading.Tasks.Task
        /// Test a push webhook
        RepoTestHook :
            string * string * int * string * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Get available issue templates for a repository
        RepoGetIssueTemplates :
            string * string * option<System.Threading.CancellationToken>
                -> IssueTemplate list System.Threading.Tasks.Task
        /// List a repository's issues
        IssueListIssues :
            string *
            string *
            string *
            string *
            string *
            string *
            string *
            string *
            string *
            string *
            string *
            string *
            int *
            int *
            option<System.Threading.CancellationToken>
                -> Issue list System.Threading.Tasks.Task
        /// Create an issue. If using deadline only the date will be taken into account, and time of day ignored.
        IssueCreateIssue :
            string * string * CreateIssueOption * option<System.Threading.CancellationToken>
                -> Issue System.Threading.Tasks.Task
        /// List all comments in a repository
        IssueGetRepoComments :
            string * string * string * string * int * int * option<System.Threading.CancellationToken>
                -> Comment list System.Threading.Tasks.Task
        /// Delete a comment
        IssueDeleteComment :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List comment's attachments
        IssueListIssueCommentAttachments :
            string * string * int * option<System.Threading.CancellationToken>
                -> Attachment list System.Threading.Tasks.Task
        /// Get a comment attachment
        IssueGetIssueCommentAttachment :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Attachment System.Threading.Tasks.Task
        /// Delete a comment attachment
        IssueDeleteIssueCommentAttachment :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a comment attachment
        IssueEditIssueCommentAttachment :
            string * string * int * int * EditAttachmentOptions * option<System.Threading.CancellationToken>
                -> Attachment System.Threading.Tasks.Task
        /// Get a list of reactions from a comment of an issue
        IssueGetCommentReactions :
            string * string * int * option<System.Threading.CancellationToken>
                -> Reaction list System.Threading.Tasks.Task
        /// Remove a reaction from a comment of an issue
        IssueDeleteCommentReaction :
            string * string * int * EditReactionOption * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Get an issue
        IssueGetIssue :
            string * string * int * option<System.Threading.CancellationToken> -> Issue System.Threading.Tasks.Task
        /// Delete an issue
        IssueDelete :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit an issue. If using deadline only the date will be taken into account, and time of day ignored.
        IssueEditIssue :
            string * string * int * EditIssueOption * option<System.Threading.CancellationToken>
                -> Issue System.Threading.Tasks.Task
        /// List issue's attachments
        IssueListIssueAttachments :
            string * string * int * option<System.Threading.CancellationToken>
                -> Attachment list System.Threading.Tasks.Task
        /// Get an issue attachment
        IssueGetIssueAttachment :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Attachment System.Threading.Tasks.Task
        /// Delete an issue attachment
        IssueDeleteIssueAttachment :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit an issue attachment
        IssueEditIssueAttachment :
            string * string * int * int * EditAttachmentOptions * option<System.Threading.CancellationToken>
                -> Attachment System.Threading.Tasks.Task
        /// List all comments on an issue
        IssueGetComments :
            string * string * int * string * string * option<System.Threading.CancellationToken>
                -> Comment list System.Threading.Tasks.Task
        /// Add a comment to an issue
        IssueCreateComment :
            string * string * int * CreateIssueCommentOption * option<System.Threading.CancellationToken>
                -> Comment System.Threading.Tasks.Task
        /// Delete a comment
        IssueDeleteCommentDeprecated :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Set an issue deadline. If set to null, the deadline is deleted. If using deadline only the date will be taken into account, and time of day ignored.
        IssueEditIssueDeadline :
            string * string * int * EditDeadlineOption * option<System.Threading.CancellationToken>
                -> IssueDeadline System.Threading.Tasks.Task
        /// Get an issue's labels
        IssueGetLabels :
            string * string * int * option<System.Threading.CancellationToken> -> Label list System.Threading.Tasks.Task
        /// Add a label to an issue
        IssueAddLabel :
            string * string * int * IssueLabelsOption * option<System.Threading.CancellationToken>
                -> Label list System.Threading.Tasks.Task
        /// Remove all labels from an issue
        IssueClearLabels :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Replace an issue's labels
        IssueReplaceLabels :
            string * string * int * IssueLabelsOption * option<System.Threading.CancellationToken>
                -> Label list System.Threading.Tasks.Task
        /// Remove a label from an issue
        IssueRemoveLabel :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a list reactions of an issue
        IssueGetIssueReactions :
            string * string * int * int * int * option<System.Threading.CancellationToken>
                -> Reaction list System.Threading.Tasks.Task
        /// Remove a reaction from an issue
        IssueDeleteIssueReaction :
            string * string * int * EditReactionOption * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Delete an issue's existing stopwatch.
        IssueDeleteStopWatch :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Start stopwatch on an issue.
        IssueStartStopWatch :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Stop an issue's existing stopwatch.
        IssueStopStopWatch :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get users who subscribed on an issue.
        IssueSubscriptions :
            string * string * int * int * int * option<System.Threading.CancellationToken>
                -> User list System.Threading.Tasks.Task
        /// Check if user is subscribed to an issue
        IssueCheckSubscription :
            string * string * int * option<System.Threading.CancellationToken> -> WatchInfo System.Threading.Tasks.Task
        /// List all comments and events on an issue
        IssueGetCommentsAndTimeline :
            string * string * int * string * int * int * string * option<System.Threading.CancellationToken>
                -> TimelineComment list System.Threading.Tasks.Task
        /// List an issue's tracked times
        IssueTrackedTimes :
            string * string * int * string * string * string * int * int * option<System.Threading.CancellationToken>
                -> TrackedTime list System.Threading.Tasks.Task
        /// Add tracked time to a issue
        IssueAddTime :
            string * string * int * AddTimeOption * option<System.Threading.CancellationToken>
                -> TrackedTime System.Threading.Tasks.Task
        /// Reset a tracked time of an issue
        IssueResetTime :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Delete specific tracked time
        IssueDeleteTime :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List a repository's keys
        RepoListKeys :
            string * string * int * string * int * int * option<System.Threading.CancellationToken>
                -> DeployKey list System.Threading.Tasks.Task
        /// Add a key to a repository
        RepoCreateKey :
            string * string * CreateKeyOption * option<System.Threading.CancellationToken>
                -> DeployKey System.Threading.Tasks.Task
        /// Get a repository's key by id
        RepoGetKey :
            string * string * int * option<System.Threading.CancellationToken> -> DeployKey System.Threading.Tasks.Task
        /// Delete a key from a repository
        RepoDeleteKey :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get all of a repository's labels
        IssueListLabels :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Label list System.Threading.Tasks.Task
        /// Create a label
        IssueCreateLabel :
            string * string * CreateLabelOption * option<System.Threading.CancellationToken>
                -> Label System.Threading.Tasks.Task
        /// Get a single label
        IssueGetLabel :
            string * string * int * option<System.Threading.CancellationToken> -> Label System.Threading.Tasks.Task
        /// Delete a label
        IssueDeleteLabel :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Update a label
        IssueEditLabel :
            string * string * int * EditLabelOption * option<System.Threading.CancellationToken>
                -> Label System.Threading.Tasks.Task
        /// Get languages and number of bytes of code written
        RepoGetLanguages :
            string * string * option<System.Threading.CancellationToken>
                -> LanguageStatistics System.Threading.Tasks.Task
        /// Get a file or it's LFS object from a repository
        RepoGetRawFileOrLFS :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Get all of a repository's opened milestones
        IssueGetMilestonesList :
            string * string * string * string * int * int * option<System.Threading.CancellationToken>
                -> Milestone list System.Threading.Tasks.Task
        /// Create a milestone
        IssueCreateMilestone :
            string * string * CreateMilestoneOption * option<System.Threading.CancellationToken>
                -> Milestone System.Threading.Tasks.Task
        /// Get a milestone
        IssueGetMilestone :
            string * string * string * option<System.Threading.CancellationToken>
                -> Milestone System.Threading.Tasks.Task
        /// Delete a milestone
        IssueDeleteMilestone :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Update a milestone
        IssueEditMilestone :
            string * string * string * EditMilestoneOption * option<System.Threading.CancellationToken>
                -> Milestone System.Threading.Tasks.Task
        /// Sync a mirrored repository
        RepoMirrorSync :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List users's notification threads on a specific repo
        NotifyGetRepoList :
            string *
            string *
            bool *
            string list *
            string list *
            string *
            string *
            int *
            int *
            option<System.Threading.CancellationToken>
                -> NotificationThread list System.Threading.Tasks.Task
        /// Mark notification threads as read, pinned or unread on a specific repo
        NotifyReadRepoList :
            string * string * string * string list * string * string * option<System.Threading.CancellationToken>
                -> NotificationThread list System.Threading.Tasks.Task
        /// List a repo's pull requests
        RepoListPullRequests :
            string * string * string * string * int * int list * int * int * option<System.Threading.CancellationToken>
                -> PullRequest list System.Threading.Tasks.Task
        /// Create a pull request
        RepoCreatePullRequest :
            string * string * CreatePullRequestOption * option<System.Threading.CancellationToken>
                -> PullRequest System.Threading.Tasks.Task
        /// Get a pull request
        RepoGetPullRequest :
            string * string * int * option<System.Threading.CancellationToken>
                -> PullRequest System.Threading.Tasks.Task
        /// Update a pull request. If using deadline only the date will be taken into account, and time of day ignored.
        RepoEditPullRequest :
            string * string * int * EditPullRequestOption * option<System.Threading.CancellationToken>
                -> PullRequest System.Threading.Tasks.Task
        /// Get a pull request diff or patch
        RepoDownloadPullDiffOrPatch :
            string * string * int * string * bool * option<System.Threading.CancellationToken>
                -> string System.Threading.Tasks.Task
        /// Get commits for a pull request
        RepoGetPullRequestCommits :
            string * string * int * int * int * option<System.Threading.CancellationToken>
                -> Commit list System.Threading.Tasks.Task
        /// Get changed files for a pull request
        RepoGetPullRequestFiles :
            string * string * int * string * string * int * int * option<System.Threading.CancellationToken>
                -> ChangedFile list System.Threading.Tasks.Task
        /// Check if a pull request has been merged
        RepoPullRequestIsMerged :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Merge a pull request
        RepoMergePullRequest :
            string * string * int * MergePullRequestOption * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Cancel the scheduled auto merge for the given pull request
        RepoCancelScheduledAutoMerge :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// create review requests for a pull request
        RepoCreatePullReviewRequests :
            string * string * int * PullReviewRequestOptions * option<System.Threading.CancellationToken>
                -> PullReview list System.Threading.Tasks.Task
        /// cancel review requests for a pull request
        RepoDeletePullReviewRequests :
            string * string * int * PullReviewRequestOptions * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// List all reviews for a pull request
        RepoListPullReviews :
            string * string * int * int * int * option<System.Threading.CancellationToken>
                -> PullReview list System.Threading.Tasks.Task
        /// Create a review to an pull request
        RepoCreatePullReview :
            string * string * int * CreatePullReviewOptions * option<System.Threading.CancellationToken>
                -> PullReview System.Threading.Tasks.Task
        /// Get a specific review for a pull request
        RepoGetPullReview :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> PullReview System.Threading.Tasks.Task
        /// Submit a pending review to an pull request
        RepoSubmitPullReview :
            string * string * int * int * SubmitPullReviewOptions * option<System.Threading.CancellationToken>
                -> PullReview System.Threading.Tasks.Task
        /// Delete a specific review from a pull request
        RepoDeletePullReview :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a specific review for a pull request
        RepoGetPullReviewComments :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> PullReviewComment list System.Threading.Tasks.Task
        /// Dismiss a review for a pull request
        RepoDismissPullReview :
            string * string * int * int * DismissPullReviewOptions * option<System.Threading.CancellationToken>
                -> PullReview System.Threading.Tasks.Task
        /// Cancel to dismiss a review for a pull request
        RepoUnDismissPullReview :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> PullReview System.Threading.Tasks.Task
        /// Merge PR's baseBranch into headBranch
        RepoUpdatePullRequest :
            string * string * int * string * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Get all push mirrors of the repository
        RepoListPushMirrors :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> PushMirror list System.Threading.Tasks.Task
        /// add a push mirror to the repository
        RepoAddPushMirror :
            string * string * CreatePushMirrorOption * option<System.Threading.CancellationToken>
                -> PushMirror System.Threading.Tasks.Task
        /// Sync all push mirrored repository
        RepoPushMirrorSync :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get push mirror of the repository by remoteName
        RepoGetPushMirrorByRemoteName :
            string * string * string * option<System.Threading.CancellationToken>
                -> PushMirror System.Threading.Tasks.Task
        /// deletes a push mirror from a repository by remoteName
        RepoDeletePushMirror :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a file from a repository
        RepoGetRawFile :
            string * string * string * string * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// List a repo's releases
        RepoListReleases :
            string * string * bool * bool * int * int * int * option<System.Threading.CancellationToken>
                -> Release list System.Threading.Tasks.Task
        /// Create a release
        RepoCreateRelease :
            string * string * CreateReleaseOption * option<System.Threading.CancellationToken>
                -> Release System.Threading.Tasks.Task
        /// Gets the most recent non-prerelease, non-draft release of a repository, sorted by created_at
        RepoGetLatestRelease :
            string * string * option<System.Threading.CancellationToken> -> Release System.Threading.Tasks.Task
        /// Get a release by tag name
        RepoGetReleaseByTag :
            string * string * string * option<System.Threading.CancellationToken> -> Release System.Threading.Tasks.Task
        /// Delete a release by tag name
        RepoDeleteReleaseByTag :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a release
        RepoGetRelease :
            string * string * int * option<System.Threading.CancellationToken> -> Release System.Threading.Tasks.Task
        /// Delete a release
        RepoDeleteRelease :
            string * string * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Update a release
        RepoEditRelease :
            string * string * int * EditReleaseOption * option<System.Threading.CancellationToken>
                -> Release System.Threading.Tasks.Task
        /// List release's attachments
        RepoListReleaseAttachments :
            string * string * int * option<System.Threading.CancellationToken>
                -> Attachment list System.Threading.Tasks.Task
        /// Get a release attachment
        RepoGetReleaseAttachment :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Attachment System.Threading.Tasks.Task
        /// Delete a release attachment
        RepoDeleteReleaseAttachment :
            string * string * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a release attachment
        RepoEditReleaseAttachment :
            string * string * int * int * EditAttachmentOptions * option<System.Threading.CancellationToken>
                -> Attachment System.Threading.Tasks.Task
        /// Return all users that can be requested to review in this repo
        RepoGetReviewers :
            string * string * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// Get signing-key.gpg for given repository
        RepoSigningKey :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List a repo's stargazers
        RepoListStargazers :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> User list System.Threading.Tasks.Task
        /// Get a commit's statuses
        RepoListStatuses :
            string * string * string * string * string * int * int * option<System.Threading.CancellationToken>
                -> CommitStatus list System.Threading.Tasks.Task
        /// Create a commit status
        RepoCreateStatus :
            string * string * string * CreateStatusOption * option<System.Threading.CancellationToken>
                -> CommitStatus System.Threading.Tasks.Task
        /// List a repo's watchers
        RepoListSubscribers :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> User list System.Threading.Tasks.Task
        /// Check if the current user is watching a repo
        UserCurrentCheckSubscription :
            string * string * option<System.Threading.CancellationToken> -> WatchInfo System.Threading.Tasks.Task
        /// Unwatch a repo
        UserCurrentDeleteSubscription :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Watch a repo
        UserCurrentPutSubscription :
            string * string * option<System.Threading.CancellationToken> -> WatchInfo System.Threading.Tasks.Task
        /// List a repository's tags
        RepoListTags :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> Tag list System.Threading.Tasks.Task
        /// Create a new git tag in a repository
        RepoCreateTag :
            string * string * CreateTagOption * option<System.Threading.CancellationToken>
                -> Tag System.Threading.Tasks.Task
        /// Get the tag of a repository by tag name
        RepoGetTag :
            string * string * string * option<System.Threading.CancellationToken> -> Tag System.Threading.Tasks.Task
        /// Delete a repository's tag by name
        RepoDeleteTag :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List a repository's teams
        RepoListTeams :
            string * string * option<System.Threading.CancellationToken> -> Team list System.Threading.Tasks.Task
        /// Check if a team is assigned to a repository
        RepoCheckTeam :
            string * string * string * option<System.Threading.CancellationToken> -> Team System.Threading.Tasks.Task
        /// Delete a team from a repository
        RepoDeleteTeam :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Add a team to a repository
        RepoAddTeam :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List a repo's tracked times
        RepoTrackedTimes :
            string * string * string * string * string * int * int * option<System.Threading.CancellationToken>
                -> TrackedTime list System.Threading.Tasks.Task
        /// List a user's tracked times in a repo
        UserTrackedTimes :
            string * string * string * option<System.Threading.CancellationToken>
                -> TrackedTime list System.Threading.Tasks.Task
        /// Get list of topics that a repository has
        RepoListTopics :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> TopicName System.Threading.Tasks.Task
        /// Replace list of topics for a repository
        RepoUpdateTopics :
            string * string * RepoTopicOptions * option<System.Threading.CancellationToken>
                -> unit System.Threading.Tasks.Task
        /// Delete a topic from a repository
        RepoDeleteTopic :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Add a topic to a repository
        RepoAddTopic :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Transfer a repo ownership
        RepoTransfer :
            string * string * TransferRepoOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// Accept a repo transfer
        AcceptRepoTransfer :
            string * string * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Reject a repo transfer
        RejectRepoTransfer :
            string * string * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Create a wiki page
        RepoCreateWikiPage :
            string * string * CreateWikiPageOptions * option<System.Threading.CancellationToken>
                -> WikiPage System.Threading.Tasks.Task
        /// Get a wiki page
        RepoGetWikiPage :
            string * string * string * option<System.Threading.CancellationToken>
                -> WikiPage System.Threading.Tasks.Task
        /// Delete a wiki page
        RepoDeleteWikiPage :
            string * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a wiki page
        RepoEditWikiPage :
            string * string * string * CreateWikiPageOptions * option<System.Threading.CancellationToken>
                -> WikiPage System.Threading.Tasks.Task
        /// Get all wiki pages
        RepoGetWikiPages :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> WikiPageMetaData list System.Threading.Tasks.Task
        /// Get revisions of a wiki page
        RepoGetWikiPageRevisions :
            string * string * string * int * option<System.Threading.CancellationToken>
                -> WikiCommitList System.Threading.Tasks.Task
        /// Create a repository using a template
        GenerateRepo :
            string * string * GenerateRepoOption * option<System.Threading.CancellationToken>
                -> Repository System.Threading.Tasks.Task
        /// Get a repository by id
        RepoGetByID : int * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Get instance's global settings for api
        GetGeneralAPISettings :
            option<System.Threading.CancellationToken> -> GeneralAPISettings System.Threading.Tasks.Task
        /// Get instance's global settings for Attachment
        GetGeneralAttachmentSettings :
            option<System.Threading.CancellationToken> -> GeneralAttachmentSettings System.Threading.Tasks.Task
        /// Get instance's global settings for repositories
        GetGeneralRepositorySettings :
            option<System.Threading.CancellationToken> -> GeneralRepoSettings System.Threading.Tasks.Task
        /// Get instance's global settings for ui
        GetGeneralUISettings :
            option<System.Threading.CancellationToken> -> GeneralUISettings System.Threading.Tasks.Task
        /// Get default signing-key.gpg
        GetSigningKey : option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a team
        OrgGetTeam : int * option<System.Threading.CancellationToken> -> Team System.Threading.Tasks.Task
        /// Delete a team
        OrgDeleteTeam : int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Edit a team
        OrgEditTeam :
            int * EditTeamOption * option<System.Threading.CancellationToken> -> Team System.Threading.Tasks.Task
        /// List a team's members
        OrgListTeamMembers :
            int * int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// List a particular member of team
        OrgListTeamMember :
            int * string * option<System.Threading.CancellationToken> -> User System.Threading.Tasks.Task
        /// Remove a team member
        OrgRemoveTeamMember :
            int * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Add a team member
        OrgAddTeamMember : int * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List a team's repos
        OrgListTeamRepos :
            int * int * int * option<System.Threading.CancellationToken> -> Repository list System.Threading.Tasks.Task
        /// List a particular repo of team
        OrgListTeamRepo :
            int * string * string * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Remove a repository from a team
        OrgRemoveTeamRepository :
            int * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Add a repository to a team
        OrgAddTeamRepository :
            int * string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// search topics via keyword
        TopicSearch :
            string * int * int * option<System.Threading.CancellationToken>
                -> TopicResponse list System.Threading.Tasks.Task
        /// Get the authenticated user
        UserGetCurrent : option<System.Threading.CancellationToken> -> User System.Threading.Tasks.Task
        /// List the authenticated user's oauth2 applications
        UserGetOauth2Application :
            int * int * option<System.Threading.CancellationToken> -> OAuth2Application list System.Threading.Tasks.Task
        /// creates a new OAuth2 application
        UserCreateOAuth2Application :
            CreateOAuth2ApplicationOptions * option<System.Threading.CancellationToken>
                -> OAuth2Application System.Threading.Tasks.Task
        /// get an OAuth2 Application
        UserGetOAuth2Application :
            int * option<System.Threading.CancellationToken> -> OAuth2Application System.Threading.Tasks.Task
        /// delete an OAuth2 Application
        UserDeleteOAuth2Application :
            int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// update an OAuth2 Application, this includes regenerating the client secret
        UserUpdateOAuth2Application :
            int * CreateOAuth2ApplicationOptions * option<System.Threading.CancellationToken>
                -> OAuth2Application System.Threading.Tasks.Task
        /// List the authenticated user's email addresses
        UserListEmails : option<System.Threading.CancellationToken> -> Email list System.Threading.Tasks.Task
        /// Add email addresses
        UserAddEmail :
            CreateEmailOption * option<System.Threading.CancellationToken> -> Email list System.Threading.Tasks.Task
        /// Delete email addresses
        UserDeleteEmail :
            DeleteEmailOption * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List the authenticated user's followers
        UserCurrentListFollowers :
            int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// List the users that the authenticated user is following
        UserCurrentListFollowing :
            int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// Check whether a user is followed by the authenticated user
        UserCurrentCheckFollowing :
            string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Unfollow a user
        UserCurrentDeleteFollow :
            string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Follow a user
        UserCurrentPutFollow : string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a Token to verify
        GetVerificationToken : option<System.Threading.CancellationToken> -> string System.Threading.Tasks.Task
        /// Remove a GPG key
        UserCurrentDeleteGPGKey : int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List the authenticated user's public keys
        UserCurrentListKeys :
            string * int * int * option<System.Threading.CancellationToken>
                -> PublicKey list System.Threading.Tasks.Task
        /// Create a public key
        UserCurrentPostKey :
            CreateKeyOption * option<System.Threading.CancellationToken> -> PublicKey System.Threading.Tasks.Task
        /// Get a public key
        UserCurrentGetKey : int * option<System.Threading.CancellationToken> -> PublicKey System.Threading.Tasks.Task
        /// Delete a public key
        UserCurrentDeleteKey : int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// List the current user's organizations
        OrgListCurrentUserOrgs :
            int * int * option<System.Threading.CancellationToken> -> Organization list System.Threading.Tasks.Task
        /// List the repos that the authenticated user owns
        UserCurrentListRepos :
            int * int * option<System.Threading.CancellationToken> -> Repository list System.Threading.Tasks.Task
        /// Create a repository
        CreateCurrentUserRepo :
            CreateRepoOption * option<System.Threading.CancellationToken> -> Repository System.Threading.Tasks.Task
        /// Get user settings
        GetUserSettings : option<System.Threading.CancellationToken> -> UserSettings list System.Threading.Tasks.Task
        /// Update user settings
        UpdateUserSettings :
            UserSettingsOptions * option<System.Threading.CancellationToken>
                -> UserSettings list System.Threading.Tasks.Task
        /// The repos that the authenticated user has starred
        UserCurrentListStarred :
            int * int * option<System.Threading.CancellationToken> -> Repository list System.Threading.Tasks.Task
        /// Whether the authenticated is starring the repo
        UserCurrentCheckStarring :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Unstar the given repo
        UserCurrentDeleteStar :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Star the given repo
        UserCurrentPutStar :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get list of all existing stopwatches
        UserGetStopWatches :
            int * int * option<System.Threading.CancellationToken> -> StopWatch list System.Threading.Tasks.Task
        /// List repositories watched by the authenticated user
        UserCurrentListSubscriptions :
            int * int * option<System.Threading.CancellationToken> -> Repository list System.Threading.Tasks.Task
        /// List all the teams a user belongs to
        UserListTeams : int * int * option<System.Threading.CancellationToken> -> Team list System.Threading.Tasks.Task
        /// List the current user's tracked times
        UserCurrentTrackedTimes :
            int * int * string * string * option<System.Threading.CancellationToken>
                -> TrackedTime list System.Threading.Tasks.Task
        /// Search for users
        UserSearch :
            string * int * int * int * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a user
        UserGet : string * option<System.Threading.CancellationToken> -> User System.Threading.Tasks.Task
        /// List the given user's followers
        UserListFollowers :
            string * int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// List the users that the given user is following
        UserListFollowing :
            string * int * int * option<System.Threading.CancellationToken> -> User list System.Threading.Tasks.Task
        /// Check if one user is following another user
        UserCheckFollowing :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Get a user's heatmap
        UserGetHeatmapData :
            string * option<System.Threading.CancellationToken> -> UserHeatmapData list System.Threading.Tasks.Task
        /// List the given user's public keys
        UserListKeys :
            string * string * int * int * option<System.Threading.CancellationToken>
                -> PublicKey list System.Threading.Tasks.Task
        /// List a user's organizations
        OrgListUserOrgs :
            string * int * int * option<System.Threading.CancellationToken>
                -> Organization list System.Threading.Tasks.Task
        /// Get user permissions in organization
        OrgGetUserPermissions :
            string * string * option<System.Threading.CancellationToken>
                -> OrganizationPermissions System.Threading.Tasks.Task
        /// List the repos owned by the given user
        UserListRepos :
            string * int * int * option<System.Threading.CancellationToken>
                -> Repository list System.Threading.Tasks.Task
        /// The repos that the given user has starred
        UserListStarred :
            string * int * int * option<System.Threading.CancellationToken>
                -> Repository list System.Threading.Tasks.Task
        /// List the repositories watched by a user
        UserListSubscriptions :
            string * int * int * option<System.Threading.CancellationToken>
                -> Repository list System.Threading.Tasks.Task
        /// List the authenticated user's access tokens
        UserGetTokens :
            string * int * int * option<System.Threading.CancellationToken>
                -> AccessToken list System.Threading.Tasks.Task
        /// Create an access token
        UserCreateToken :
            string * CreateAccessTokenOption * option<System.Threading.CancellationToken>
                -> AccessToken System.Threading.Tasks.Task
        /// delete an access token
        UserDeleteAccessToken :
            string * string * option<System.Threading.CancellationToken> -> unit System.Threading.Tasks.Task
        /// Returns the version of the Gitea application
        GetVersion : option<System.Threading.CancellationToken> -> ServerVersion System.Threading.Tasks.Task
    }

    /// An implementation where every method throws.
    static member Empty : GiteaMock =
        {
            ActivitypubPerson =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: ActivitypubPerson"))
            ActivitypubPersonInbox =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: ActivitypubPersonInbox"))
            AdminCronList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCronList"))
            AdminCronRun = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCronRun"))
            AdminListHooks =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminListHooks"))
            AdminCreateHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCreateHook"))
            AdminGetHook = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminGetHook"))
            AdminEditHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminEditHook"))
            AdminGetAllOrgs =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminGetAllOrgs"))
            AdminUnadoptedList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminUnadoptedList"))
            AdminAdoptRepository =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminAdoptRepository"))
            AdminDeleteUnadoptedRepository =
                (fun _ ->
                    raise (
                        System.NotImplementedException "Unimplemented mock function: AdminDeleteUnadoptedRepository"
                    )
                )
            AdminGetAllUsers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminGetAllUsers"))
            AdminCreateUser =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCreateUser"))
            AdminDeleteUser =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminDeleteUser"))
            AdminEditUser =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminEditUser"))
            AdminCreatePublicKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCreatePublicKey"))
            AdminDeleteUserPublicKey =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: AdminDeleteUserPublicKey")
                )
            AdminCreateOrg =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCreateOrg"))
            AdminCreateRepo =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminCreateRepo"))
            AdminDeleteHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AdminDeleteHook"))
            RenderMarkdown =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RenderMarkdown"))
            RenderMarkdownRaw =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RenderMarkdownRaw"))
            GetNodeInfo = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetNodeInfo"))
            NotifyGetList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyGetList"))
            NotifyReadList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyReadList"))
            NotifyNewAvailable =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyNewAvailable"))
            NotifyGetThread =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyGetThread"))
            NotifyReadThread =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyReadThread"))
            CreateOrgRepoDeprecated =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: CreateOrgRepoDeprecated"))
            OrgGetAll = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgGetAll"))
            OrgCreate = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgCreate"))
            OrgGet = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgGet"))
            OrgDelete = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgDelete"))
            OrgEdit = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgEdit"))
            OrgListHooks = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListHooks"))
            OrgCreateHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgCreateHook"))
            OrgGetHook = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgGetHook"))
            OrgDeleteHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgDeleteHook"))
            OrgEditHook = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgEditHook"))
            OrgListLabels =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListLabels"))
            OrgCreateLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgCreateLabel"))
            OrgGetLabel = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgGetLabel"))
            OrgDeleteLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgDeleteLabel"))
            OrgEditLabel = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgEditLabel"))
            OrgListMembers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListMembers"))
            OrgIsMember = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgIsMember"))
            OrgDeleteMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgDeleteMember"))
            OrgListPublicMembers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListPublicMembers"))
            OrgIsPublicMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgIsPublicMember"))
            OrgConcealMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgConcealMember"))
            OrgPublicizeMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgPublicizeMember"))
            OrgListRepos = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListRepos"))
            CreateOrgRepo =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: CreateOrgRepo"))
            OrgListTeams = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListTeams"))
            OrgCreateTeam =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgCreateTeam"))
            TeamSearch = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: TeamSearch"))
            ListPackages = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: ListPackages"))
            GetPackage = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetPackage"))
            DeletePackage =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: DeletePackage"))
            ListPackageFiles =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: ListPackageFiles"))
            IssueSearchIssues =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueSearchIssues"))
            RepoMigrate = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoMigrate"))
            RepoSearch = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoSearch"))
            RepoGet = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGet"))
            RepoDelete = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDelete"))
            RepoEdit = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoEdit"))
            RepoGetArchive =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetArchive"))
            RepoGetAssignees =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetAssignees"))
            RepoListBranchProtection =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoListBranchProtection")
                )
            RepoCreateBranchProtection =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoCreateBranchProtection")
                )
            RepoGetBranchProtection =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetBranchProtection"))
            RepoDeleteBranchProtection =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteBranchProtection")
                )
            RepoEditBranchProtection =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoEditBranchProtection")
                )
            RepoListBranches =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListBranches"))
            RepoCreateBranch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateBranch"))
            RepoGetBranch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetBranch"))
            RepoDeleteBranch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteBranch"))
            RepoListCollaborators =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListCollaborators"))
            RepoCheckCollaborator =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCheckCollaborator"))
            RepoDeleteCollaborator =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteCollaborator"))
            RepoAddCollaborator =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoAddCollaborator"))
            RepoGetRepoPermissions =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetRepoPermissions"))
            RepoGetAllCommits =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetAllCommits"))
            RepoGetCombinedStatusByRef =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoGetCombinedStatusByRef")
                )
            RepoListStatusesByRef =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListStatusesByRef"))
            RepoGetContentsList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetContentsList"))
            RepoGetContents =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetContents"))
            RepoCreateFile =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateFile"))
            RepoDeleteFile =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteFile"))
            RepoUpdateFile =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoUpdateFile"))
            RepoApplyDiffPatch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoApplyDiffPatch"))
            RepoGetEditorConfig =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetEditorConfig"))
            ListForks = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: ListForks"))
            CreateFork = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: CreateFork"))
            GetBlob = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetBlob"))
            RepoGetSingleCommit =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetSingleCommit"))
            RepoDownloadCommitDiffOrPatch =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoDownloadCommitDiffOrPatch")
                )
            RepoGetNote = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetNote"))
            RepoListAllGitRefs =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListAllGitRefs"))
            RepoListGitRefs =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListGitRefs"))
            GetAnnotatedTag =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetAnnotatedTag"))
            GetTree = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetTree"))
            RepoListHooks =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListHooks"))
            RepoCreateHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateHook"))
            RepoListGitHooks =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListGitHooks"))
            RepoGetGitHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetGitHook"))
            RepoDeleteGitHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteGitHook"))
            RepoEditGitHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoEditGitHook"))
            RepoGetHook = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetHook"))
            RepoDeleteHook =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteHook"))
            RepoEditHook = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoEditHook"))
            RepoTestHook = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoTestHook"))
            RepoGetIssueTemplates =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetIssueTemplates"))
            IssueListIssues =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueListIssues"))
            IssueCreateIssue =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueCreateIssue"))
            IssueGetRepoComments =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetRepoComments"))
            IssueDeleteComment =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteComment"))
            IssueListIssueCommentAttachments =
                (fun _ ->
                    raise (
                        System.NotImplementedException "Unimplemented mock function: IssueListIssueCommentAttachments"
                    )
                )
            IssueGetIssueCommentAttachment =
                (fun _ ->
                    raise (
                        System.NotImplementedException "Unimplemented mock function: IssueGetIssueCommentAttachment"
                    )
                )
            IssueDeleteIssueCommentAttachment =
                (fun _ ->
                    raise (
                        System.NotImplementedException "Unimplemented mock function: IssueDeleteIssueCommentAttachment"
                    )
                )
            IssueEditIssueCommentAttachment =
                (fun _ ->
                    raise (
                        System.NotImplementedException "Unimplemented mock function: IssueEditIssueCommentAttachment"
                    )
                )
            IssueGetCommentReactions =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueGetCommentReactions")
                )
            IssueDeleteCommentReaction =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteCommentReaction")
                )
            IssueGetIssue =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetIssue"))
            IssueDelete = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueDelete"))
            IssueEditIssue =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueEditIssue"))
            IssueListIssueAttachments =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueListIssueAttachments")
                )
            IssueGetIssueAttachment =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetIssueAttachment"))
            IssueDeleteIssueAttachment =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteIssueAttachment")
                )
            IssueEditIssueAttachment =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueEditIssueAttachment")
                )
            IssueGetComments =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetComments"))
            IssueCreateComment =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueCreateComment"))
            IssueDeleteCommentDeprecated =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteCommentDeprecated")
                )
            IssueEditIssueDeadline =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueEditIssueDeadline"))
            IssueGetLabels =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetLabels"))
            IssueAddLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueAddLabel"))
            IssueClearLabels =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueClearLabels"))
            IssueReplaceLabels =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueReplaceLabels"))
            IssueRemoveLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueRemoveLabel"))
            IssueGetIssueReactions =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetIssueReactions"))
            IssueDeleteIssueReaction =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteIssueReaction")
                )
            IssueDeleteStopWatch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteStopWatch"))
            IssueStartStopWatch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueStartStopWatch"))
            IssueStopStopWatch =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueStopStopWatch"))
            IssueSubscriptions =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueSubscriptions"))
            IssueCheckSubscription =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueCheckSubscription"))
            IssueGetCommentsAndTimeline =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: IssueGetCommentsAndTimeline")
                )
            IssueTrackedTimes =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueTrackedTimes"))
            IssueAddTime = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueAddTime"))
            IssueResetTime =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueResetTime"))
            IssueDeleteTime =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteTime"))
            RepoListKeys = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListKeys"))
            RepoCreateKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateKey"))
            RepoGetKey = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetKey"))
            RepoDeleteKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteKey"))
            IssueListLabels =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueListLabels"))
            IssueCreateLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueCreateLabel"))
            IssueGetLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetLabel"))
            IssueDeleteLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteLabel"))
            IssueEditLabel =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueEditLabel"))
            RepoGetLanguages =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetLanguages"))
            RepoGetRawFileOrLFS =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetRawFileOrLFS"))
            IssueGetMilestonesList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetMilestonesList"))
            IssueCreateMilestone =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueCreateMilestone"))
            IssueGetMilestone =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueGetMilestone"))
            IssueDeleteMilestone =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueDeleteMilestone"))
            IssueEditMilestone =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: IssueEditMilestone"))
            RepoMirrorSync =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoMirrorSync"))
            NotifyGetRepoList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyGetRepoList"))
            NotifyReadRepoList =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: NotifyReadRepoList"))
            RepoListPullRequests =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListPullRequests"))
            RepoCreatePullRequest =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreatePullRequest"))
            RepoGetPullRequest =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetPullRequest"))
            RepoEditPullRequest =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoEditPullRequest"))
            RepoDownloadPullDiffOrPatch =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoDownloadPullDiffOrPatch")
                )
            RepoGetPullRequestCommits =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoGetPullRequestCommits")
                )
            RepoGetPullRequestFiles =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetPullRequestFiles"))
            RepoPullRequestIsMerged =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoPullRequestIsMerged"))
            RepoMergePullRequest =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoMergePullRequest"))
            RepoCancelScheduledAutoMerge =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoCancelScheduledAutoMerge")
                )
            RepoCreatePullReviewRequests =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoCreatePullReviewRequests")
                )
            RepoDeletePullReviewRequests =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoDeletePullReviewRequests")
                )
            RepoListPullReviews =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListPullReviews"))
            RepoCreatePullReview =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreatePullReview"))
            RepoGetPullReview =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetPullReview"))
            RepoSubmitPullReview =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoSubmitPullReview"))
            RepoDeletePullReview =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeletePullReview"))
            RepoGetPullReviewComments =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoGetPullReviewComments")
                )
            RepoDismissPullReview =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDismissPullReview"))
            RepoUnDismissPullReview =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoUnDismissPullReview"))
            RepoUpdatePullRequest =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoUpdatePullRequest"))
            RepoListPushMirrors =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListPushMirrors"))
            RepoAddPushMirror =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoAddPushMirror"))
            RepoPushMirrorSync =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoPushMirrorSync"))
            RepoGetPushMirrorByRemoteName =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoGetPushMirrorByRemoteName")
                )
            RepoDeletePushMirror =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeletePushMirror"))
            RepoGetRawFile =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetRawFile"))
            RepoListReleases =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListReleases"))
            RepoCreateRelease =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateRelease"))
            RepoGetLatestRelease =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetLatestRelease"))
            RepoGetReleaseByTag =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetReleaseByTag"))
            RepoDeleteReleaseByTag =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteReleaseByTag"))
            RepoGetRelease =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetRelease"))
            RepoDeleteRelease =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteRelease"))
            RepoEditRelease =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoEditRelease"))
            RepoListReleaseAttachments =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoListReleaseAttachments")
                )
            RepoGetReleaseAttachment =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoGetReleaseAttachment")
                )
            RepoDeleteReleaseAttachment =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteReleaseAttachment")
                )
            RepoEditReleaseAttachment =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoEditReleaseAttachment")
                )
            RepoGetReviewers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetReviewers"))
            RepoSigningKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoSigningKey"))
            RepoListStargazers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListStargazers"))
            RepoListStatuses =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListStatuses"))
            RepoCreateStatus =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateStatus"))
            RepoListSubscribers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListSubscribers"))
            UserCurrentCheckSubscription =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentCheckSubscription")
                )
            UserCurrentDeleteSubscription =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentDeleteSubscription")
                )
            UserCurrentPutSubscription =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentPutSubscription")
                )
            RepoListTags = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListTags"))
            RepoCreateTag =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateTag"))
            RepoGetTag = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetTag"))
            RepoDeleteTag =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteTag"))
            RepoListTeams =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListTeams"))
            RepoCheckTeam =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCheckTeam"))
            RepoDeleteTeam =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteTeam"))
            RepoAddTeam = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoAddTeam"))
            RepoTrackedTimes =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoTrackedTimes"))
            UserTrackedTimes =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserTrackedTimes"))
            RepoListTopics =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoListTopics"))
            RepoUpdateTopics =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoUpdateTopics"))
            RepoDeleteTopic =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteTopic"))
            RepoAddTopic = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoAddTopic"))
            RepoTransfer = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoTransfer"))
            AcceptRepoTransfer =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: AcceptRepoTransfer"))
            RejectRepoTransfer =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RejectRepoTransfer"))
            RepoCreateWikiPage =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoCreateWikiPage"))
            RepoGetWikiPage =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetWikiPage"))
            RepoDeleteWikiPage =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoDeleteWikiPage"))
            RepoEditWikiPage =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoEditWikiPage"))
            RepoGetWikiPages =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetWikiPages"))
            RepoGetWikiPageRevisions =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: RepoGetWikiPageRevisions")
                )
            GenerateRepo = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GenerateRepo"))
            RepoGetByID = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: RepoGetByID"))
            GetGeneralAPISettings =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetGeneralAPISettings"))
            GetGeneralAttachmentSettings =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: GetGeneralAttachmentSettings")
                )
            GetGeneralRepositorySettings =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: GetGeneralRepositorySettings")
                )
            GetGeneralUISettings =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetGeneralUISettings"))
            GetSigningKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetSigningKey"))
            OrgGetTeam = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgGetTeam"))
            OrgDeleteTeam =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgDeleteTeam"))
            OrgEditTeam = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgEditTeam"))
            OrgListTeamMembers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListTeamMembers"))
            OrgListTeamMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListTeamMember"))
            OrgRemoveTeamMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgRemoveTeamMember"))
            OrgAddTeamMember =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgAddTeamMember"))
            OrgListTeamRepos =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListTeamRepos"))
            OrgListTeamRepo =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListTeamRepo"))
            OrgRemoveTeamRepository =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgRemoveTeamRepository"))
            OrgAddTeamRepository =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgAddTeamRepository"))
            TopicSearch = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: TopicSearch"))
            UserGetCurrent =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserGetCurrent"))
            UserGetOauth2Application =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserGetOauth2Application")
                )
            UserCreateOAuth2Application =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCreateOAuth2Application")
                )
            UserGetOAuth2Application =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserGetOAuth2Application")
                )
            UserDeleteOAuth2Application =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserDeleteOAuth2Application")
                )
            UserUpdateOAuth2Application =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserUpdateOAuth2Application")
                )
            UserListEmails =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListEmails"))
            UserAddEmail = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserAddEmail"))
            UserDeleteEmail =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserDeleteEmail"))
            UserCurrentListFollowers =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentListFollowers")
                )
            UserCurrentListFollowing =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentListFollowing")
                )
            UserCurrentCheckFollowing =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentCheckFollowing")
                )
            UserCurrentDeleteFollow =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentDeleteFollow"))
            UserCurrentPutFollow =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentPutFollow"))
            GetVerificationToken =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetVerificationToken"))
            UserCurrentDeleteGPGKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentDeleteGPGKey"))
            UserCurrentListKeys =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentListKeys"))
            UserCurrentPostKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentPostKey"))
            UserCurrentGetKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentGetKey"))
            UserCurrentDeleteKey =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentDeleteKey"))
            OrgListCurrentUserOrgs =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListCurrentUserOrgs"))
            UserCurrentListRepos =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentListRepos"))
            CreateCurrentUserRepo =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: CreateCurrentUserRepo"))
            GetUserSettings =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetUserSettings"))
            UpdateUserSettings =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UpdateUserSettings"))
            UserCurrentListStarred =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentListStarred"))
            UserCurrentCheckStarring =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentCheckStarring")
                )
            UserCurrentDeleteStar =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentDeleteStar"))
            UserCurrentPutStar =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentPutStar"))
            UserGetStopWatches =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserGetStopWatches"))
            UserCurrentListSubscriptions =
                (fun _ ->
                    raise (System.NotImplementedException "Unimplemented mock function: UserCurrentListSubscriptions")
                )
            UserListTeams =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListTeams"))
            UserCurrentTrackedTimes =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCurrentTrackedTimes"))
            UserSearch = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserSearch"))
            UserGet = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserGet"))
            UserListFollowers =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListFollowers"))
            UserListFollowing =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListFollowing"))
            UserCheckFollowing =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCheckFollowing"))
            UserGetHeatmapData =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserGetHeatmapData"))
            UserListKeys = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListKeys"))
            OrgListUserOrgs =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgListUserOrgs"))
            OrgGetUserPermissions =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: OrgGetUserPermissions"))
            UserListRepos =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListRepos"))
            UserListStarred =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListStarred"))
            UserListSubscriptions =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserListSubscriptions"))
            UserGetTokens =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserGetTokens"))
            UserCreateToken =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserCreateToken"))
            UserDeleteAccessToken =
                (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: UserDeleteAccessToken"))
            GetVersion = (fun _ -> raise (System.NotImplementedException "Unimplemented mock function: GetVersion"))
        }

    interface IGitea with
        member this.ActivitypubPerson (arg_0_0, arg_0_1) =
            this.ActivitypubPerson (arg_0_0, arg_0_1)

        member this.ActivitypubPersonInbox (arg_0_0, arg_0_1) =
            this.ActivitypubPersonInbox (arg_0_0, arg_0_1)

        member this.AdminCronList (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminCronList (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminCronRun (arg_0_0, arg_0_1) = this.AdminCronRun (arg_0_0, arg_0_1)

        member this.AdminListHooks (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminListHooks (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminCreateHook (arg_0_0, arg_0_1) = this.AdminCreateHook (arg_0_0, arg_0_1)
        member this.AdminGetHook (arg_0_0, arg_0_1) = this.AdminGetHook (arg_0_0, arg_0_1)

        member this.AdminEditHook (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminEditHook (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminGetAllOrgs (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminGetAllOrgs (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminUnadoptedList (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.AdminUnadoptedList (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.AdminAdoptRepository (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminAdoptRepository (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminDeleteUnadoptedRepository (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminDeleteUnadoptedRepository (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminGetAllUsers (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminGetAllUsers (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminCreateUser (arg_0_0, arg_0_1) = this.AdminCreateUser (arg_0_0, arg_0_1)

        member this.AdminDeleteUser (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminDeleteUser (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminEditUser (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminEditUser (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminCreatePublicKey (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminCreatePublicKey (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminDeleteUserPublicKey (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminDeleteUserPublicKey (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminCreateOrg (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminCreateOrg (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminCreateRepo (arg_0_0, arg_0_1, arg_0_2) =
            this.AdminCreateRepo (arg_0_0, arg_0_1, arg_0_2)

        member this.AdminDeleteHook (arg_0_0, arg_0_1) = this.AdminDeleteHook (arg_0_0, arg_0_1)
        member this.RenderMarkdown (arg_0_0, arg_0_1) = this.RenderMarkdown (arg_0_0, arg_0_1)

        member this.RenderMarkdownRaw (arg_0_0, arg_0_1) =
            this.RenderMarkdownRaw (arg_0_0, arg_0_1)

        member this.GetNodeInfo arg_0_0 = this.GetNodeInfo (arg_0_0)

        member this.NotifyGetList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.NotifyGetList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.NotifyReadList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.NotifyReadList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.NotifyNewAvailable arg_0_0 = this.NotifyNewAvailable (arg_0_0)
        member this.NotifyGetThread (arg_0_0, arg_0_1) = this.NotifyGetThread (arg_0_0, arg_0_1)

        member this.NotifyReadThread (arg_0_0, arg_0_1, arg_0_2) =
            this.NotifyReadThread (arg_0_0, arg_0_1, arg_0_2)

        member this.CreateOrgRepoDeprecated (arg_0_0, arg_0_1, arg_0_2) =
            this.CreateOrgRepoDeprecated (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgGetAll (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgGetAll (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgCreate (arg_0_0, arg_0_1) = this.OrgCreate (arg_0_0, arg_0_1)
        member this.OrgGet (arg_0_0, arg_0_1) = this.OrgGet (arg_0_0, arg_0_1)
        member this.OrgDelete (arg_0_0, arg_0_1) = this.OrgDelete (arg_0_0, arg_0_1)

        member this.OrgEdit (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgEdit (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgListHooks (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListHooks (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgCreateHook (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgCreateHook (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgGetHook (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgGetHook (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgDeleteHook (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgDeleteHook (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgEditHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgEditHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgListLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgCreateLabel (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgCreateLabel (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgGetLabel (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgGetLabel (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgDeleteLabel (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgDeleteLabel (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgEditLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgEditLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgListMembers (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListMembers (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgIsMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgIsMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgDeleteMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgDeleteMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgListPublicMembers (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListPublicMembers (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgIsPublicMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgIsPublicMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgConcealMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgConcealMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgPublicizeMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgPublicizeMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgListRepos (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListRepos (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.CreateOrgRepo (arg_0_0, arg_0_1, arg_0_2) =
            this.CreateOrgRepo (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgListTeams (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListTeams (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgCreateTeam (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgCreateTeam (arg_0_0, arg_0_1, arg_0_2)

        member this.TeamSearch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.TeamSearch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.ListPackages (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.ListPackages (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.GetPackage (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.GetPackage (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.DeletePackage (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.DeletePackage (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.ListPackageFiles (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.ListPackageFiles (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueSearchIssues
            (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9,
                arg_0_10,
                arg_0_11,
                arg_0_12,
                arg_0_13,
                arg_0_14,
                arg_0_15,
                arg_0_16
            )
            =
            this.IssueSearchIssues (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9,
                arg_0_10,
                arg_0_11,
                arg_0_12,
                arg_0_13,
                arg_0_14,
                arg_0_15,
                arg_0_16
            )

        member this.RepoMigrate (arg_0_0, arg_0_1) = this.RepoMigrate (arg_0_0, arg_0_1)

        member this.RepoSearch
            (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9,
                arg_0_10,
                arg_0_11,
                arg_0_12,
                arg_0_13,
                arg_0_14,
                arg_0_15,
                arg_0_16,
                arg_0_17
            )
            =
            this.RepoSearch (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9,
                arg_0_10,
                arg_0_11,
                arg_0_12,
                arg_0_13,
                arg_0_14,
                arg_0_15,
                arg_0_16,
                arg_0_17
            )

        member this.RepoGet (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoGet (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoDelete (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoDelete (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoEdit (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoEdit (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetArchive (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetArchive (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetAssignees (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoGetAssignees (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoListBranchProtection (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoListBranchProtection (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoCreateBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoEditBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoEditBranchProtection (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListBranches (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListBranches (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoCreateBranch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateBranch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetBranch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetBranch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteBranch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteBranch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoListCollaborators (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListCollaborators (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoCheckCollaborator (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCheckCollaborator (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteCollaborator (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteCollaborator (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoAddCollaborator (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoAddCollaborator (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetRepoPermissions (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetRepoPermissions (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetAllCommits (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.RepoGetAllCommits (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.RepoGetCombinedStatusByRef (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoGetCombinedStatusByRef (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoListStatusesByRef (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.RepoListStatusesByRef (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.RepoGetContentsList (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetContentsList (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetContents (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetContents (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoCreateFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoCreateFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoDeleteFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoDeleteFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoUpdateFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoUpdateFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoApplyDiffPatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoApplyDiffPatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetEditorConfig (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetEditorConfig (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.ListForks (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.ListForks (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.CreateFork (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.CreateFork (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.GetBlob (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.GetBlob (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetSingleCommit (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetSingleCommit (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDownloadCommitDiffOrPatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoDownloadCommitDiffOrPatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetNote (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetNote (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoListAllGitRefs (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoListAllGitRefs (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoListGitRefs (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoListGitRefs (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.GetAnnotatedTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.GetAnnotatedTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.GetTree (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6) =
            this.GetTree (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6)

        member this.RepoListHooks (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListHooks (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoCreateHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoListGitHooks (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoListGitHooks (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoGetGitHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetGitHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteGitHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteGitHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoEditGitHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoEditGitHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoEditHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoEditHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoTestHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoTestHook (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetIssueTemplates (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoGetIssueTemplates (arg_0_0, arg_0_1, arg_0_2)

        member this.IssueListIssues
            (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9,
                arg_0_10,
                arg_0_11,
                arg_0_12,
                arg_0_13,
                arg_0_14
            )
            =
            this.IssueListIssues (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9,
                arg_0_10,
                arg_0_11,
                arg_0_12,
                arg_0_13,
                arg_0_14
            )

        member this.IssueCreateIssue (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueCreateIssue (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueGetRepoComments (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6) =
            this.IssueGetRepoComments (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6)

        member this.IssueDeleteComment (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueDeleteComment (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueListIssueCommentAttachments (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueListIssueCommentAttachments (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueGetIssueCommentAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueGetIssueCommentAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueDeleteIssueCommentAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueDeleteIssueCommentAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueEditIssueCommentAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.IssueEditIssueCommentAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.IssueGetCommentReactions (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueGetCommentReactions (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueDeleteCommentReaction (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueDeleteCommentReaction (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueGetIssue (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueGetIssue (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueDelete (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueDelete (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueEditIssue (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueEditIssue (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueListIssueAttachments (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueListIssueAttachments (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueGetIssueAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueGetIssueAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueDeleteIssueAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueDeleteIssueAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueEditIssueAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.IssueEditIssueAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.IssueGetComments (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.IssueGetComments (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.IssueCreateComment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueCreateComment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueDeleteCommentDeprecated (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueDeleteCommentDeprecated (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueEditIssueDeadline (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueEditIssueDeadline (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueGetLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueGetLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueAddLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueAddLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueClearLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueClearLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueReplaceLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueReplaceLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueRemoveLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueRemoveLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueGetIssueReactions (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.IssueGetIssueReactions (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.IssueDeleteIssueReaction (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueDeleteIssueReaction (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueDeleteStopWatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueDeleteStopWatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueStartStopWatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueStartStopWatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueStopStopWatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueStopStopWatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueSubscriptions (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.IssueSubscriptions (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.IssueCheckSubscription (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueCheckSubscription (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueGetCommentsAndTimeline
            (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)
            =
            this.IssueGetCommentsAndTimeline (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.IssueTrackedTimes
            (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7, arg_0_8)
            =
            this.IssueTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7, arg_0_8)

        member this.IssueAddTime (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueAddTime (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueResetTime (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueResetTime (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueDeleteTime (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueDeleteTime (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListKeys (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6) =
            this.RepoListKeys (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6)

        member this.RepoCreateKey (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateKey (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetKey (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetKey (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteKey (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteKey (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueListLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueListLabels (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueCreateLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueCreateLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueGetLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueGetLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueDeleteLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueDeleteLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueEditLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueEditLabel (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetLanguages (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoGetLanguages (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoGetRawFileOrLFS (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetRawFileOrLFS (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.IssueGetMilestonesList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6) =
            this.IssueGetMilestonesList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6)

        member this.IssueCreateMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueCreateMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueGetMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueGetMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueDeleteMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.IssueDeleteMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.IssueEditMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.IssueEditMilestone (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoMirrorSync (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoMirrorSync (arg_0_0, arg_0_1, arg_0_2)

        member this.NotifyGetRepoList
            (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7, arg_0_8, arg_0_9)
            =
            this.NotifyGetRepoList (
                arg_0_0,
                arg_0_1,
                arg_0_2,
                arg_0_3,
                arg_0_4,
                arg_0_5,
                arg_0_6,
                arg_0_7,
                arg_0_8,
                arg_0_9
            )

        member this.NotifyReadRepoList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6) =
            this.NotifyReadRepoList (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6)

        member this.RepoListPullRequests
            (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7, arg_0_8)
            =
            this.RepoListPullRequests (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7, arg_0_8)

        member this.RepoCreatePullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreatePullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetPullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetPullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoEditPullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoEditPullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoDownloadPullDiffOrPatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoDownloadPullDiffOrPatch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoGetPullRequestCommits (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoGetPullRequestCommits (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoGetPullRequestFiles (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.RepoGetPullRequestFiles (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.RepoPullRequestIsMerged (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoPullRequestIsMerged (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoMergePullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoMergePullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoCancelScheduledAutoMerge (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCancelScheduledAutoMerge (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoCreatePullReviewRequests (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoCreatePullReviewRequests (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoDeletePullReviewRequests (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoDeletePullReviewRequests (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListPullReviews (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoListPullReviews (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoCreatePullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoCreatePullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoSubmitPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoSubmitPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoDeletePullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoDeletePullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetPullReviewComments (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetPullReviewComments (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoDismissPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoDismissPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoUnDismissPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoUnDismissPullReview (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoUpdatePullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoUpdatePullRequest (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListPushMirrors (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListPushMirrors (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoAddPushMirror (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoAddPushMirror (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoPushMirrorSync (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoPushMirrorSync (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoGetPushMirrorByRemoteName (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetPushMirrorByRemoteName (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeletePushMirror (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeletePushMirror (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetRawFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetRawFile (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListReleases (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.RepoListReleases (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.RepoCreateRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetLatestRelease (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoGetLatestRelease (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoGetReleaseByTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetReleaseByTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteReleaseByTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteReleaseByTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoEditRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoEditRelease (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListReleaseAttachments (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoListReleaseAttachments (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetReleaseAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetReleaseAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoDeleteReleaseAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoDeleteReleaseAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoEditReleaseAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5) =
            this.RepoEditReleaseAttachment (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5)

        member this.RepoGetReviewers (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoGetReviewers (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoSigningKey (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoSigningKey (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoListStargazers (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListStargazers (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListStatuses (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.RepoListStatuses (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.RepoCreateStatus (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoCreateStatus (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoListSubscribers (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListSubscribers (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.UserCurrentCheckSubscription (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentCheckSubscription (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentDeleteSubscription (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentDeleteSubscription (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentPutSubscription (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentPutSubscription (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoListTags (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListTags (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoCreateTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteTag (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoListTeams (arg_0_0, arg_0_1, arg_0_2) =
            this.RepoListTeams (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoCheckTeam (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCheckTeam (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteTeam (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteTeam (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoAddTeam (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoAddTeam (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7) =
            this.RepoTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4, arg_0_5, arg_0_6, arg_0_7)

        member this.UserTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoListTopics (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoListTopics (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoUpdateTopics (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoUpdateTopics (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteTopic (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteTopic (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoAddTopic (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoAddTopic (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoTransfer (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoTransfer (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.AcceptRepoTransfer (arg_0_0, arg_0_1, arg_0_2) =
            this.AcceptRepoTransfer (arg_0_0, arg_0_1, arg_0_2)

        member this.RejectRepoTransfer (arg_0_0, arg_0_1, arg_0_2) =
            this.RejectRepoTransfer (arg_0_0, arg_0_1, arg_0_2)

        member this.RepoCreateWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoCreateWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoGetWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoDeleteWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.RepoDeleteWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoEditWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoEditWikiPage (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetWikiPages (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetWikiPages (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.RepoGetWikiPageRevisions (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.RepoGetWikiPageRevisions (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.GenerateRepo (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.GenerateRepo (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.RepoGetByID (arg_0_0, arg_0_1) = this.RepoGetByID (arg_0_0, arg_0_1)
        member this.GetGeneralAPISettings arg_0_0 = this.GetGeneralAPISettings (arg_0_0)

        member this.GetGeneralAttachmentSettings arg_0_0 =
            this.GetGeneralAttachmentSettings (arg_0_0)

        member this.GetGeneralRepositorySettings arg_0_0 =
            this.GetGeneralRepositorySettings (arg_0_0)

        member this.GetGeneralUISettings arg_0_0 = this.GetGeneralUISettings (arg_0_0)
        member this.GetSigningKey arg_0_0 = this.GetSigningKey (arg_0_0)
        member this.OrgGetTeam (arg_0_0, arg_0_1) = this.OrgGetTeam (arg_0_0, arg_0_1)
        member this.OrgDeleteTeam (arg_0_0, arg_0_1) = this.OrgDeleteTeam (arg_0_0, arg_0_1)

        member this.OrgEditTeam (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgEditTeam (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgListTeamMembers (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListTeamMembers (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgListTeamMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgListTeamMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgRemoveTeamMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgRemoveTeamMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgAddTeamMember (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgAddTeamMember (arg_0_0, arg_0_1, arg_0_2)

        member this.OrgListTeamRepos (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListTeamRepos (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgListTeamRepo (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListTeamRepo (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgRemoveTeamRepository (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgRemoveTeamRepository (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgAddTeamRepository (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgAddTeamRepository (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.TopicSearch (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.TopicSearch (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserGetCurrent arg_0_0 = this.UserGetCurrent (arg_0_0)

        member this.UserGetOauth2Application (arg_0_0, arg_0_1, arg_0_2) =
            this.UserGetOauth2Application (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCreateOAuth2Application (arg_0_0, arg_0_1) =
            this.UserCreateOAuth2Application (arg_0_0, arg_0_1)

        member this.UserGetOAuth2Application (arg_0_0, arg_0_1) =
            this.UserGetOAuth2Application (arg_0_0, arg_0_1)

        member this.UserDeleteOAuth2Application (arg_0_0, arg_0_1) =
            this.UserDeleteOAuth2Application (arg_0_0, arg_0_1)

        member this.UserUpdateOAuth2Application (arg_0_0, arg_0_1, arg_0_2) =
            this.UserUpdateOAuth2Application (arg_0_0, arg_0_1, arg_0_2)

        member this.UserListEmails arg_0_0 = this.UserListEmails (arg_0_0)
        member this.UserAddEmail (arg_0_0, arg_0_1) = this.UserAddEmail (arg_0_0, arg_0_1)
        member this.UserDeleteEmail (arg_0_0, arg_0_1) = this.UserDeleteEmail (arg_0_0, arg_0_1)

        member this.UserCurrentListFollowers (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentListFollowers (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentListFollowing (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentListFollowing (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentCheckFollowing (arg_0_0, arg_0_1) =
            this.UserCurrentCheckFollowing (arg_0_0, arg_0_1)

        member this.UserCurrentDeleteFollow (arg_0_0, arg_0_1) =
            this.UserCurrentDeleteFollow (arg_0_0, arg_0_1)

        member this.UserCurrentPutFollow (arg_0_0, arg_0_1) =
            this.UserCurrentPutFollow (arg_0_0, arg_0_1)

        member this.GetVerificationToken arg_0_0 = this.GetVerificationToken (arg_0_0)

        member this.UserCurrentDeleteGPGKey (arg_0_0, arg_0_1) =
            this.UserCurrentDeleteGPGKey (arg_0_0, arg_0_1)

        member this.UserCurrentListKeys (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserCurrentListKeys (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserCurrentPostKey (arg_0_0, arg_0_1) =
            this.UserCurrentPostKey (arg_0_0, arg_0_1)

        member this.UserCurrentGetKey (arg_0_0, arg_0_1) =
            this.UserCurrentGetKey (arg_0_0, arg_0_1)

        member this.UserCurrentDeleteKey (arg_0_0, arg_0_1) =
            this.UserCurrentDeleteKey (arg_0_0, arg_0_1)

        member this.OrgListCurrentUserOrgs (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgListCurrentUserOrgs (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentListRepos (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentListRepos (arg_0_0, arg_0_1, arg_0_2)

        member this.CreateCurrentUserRepo (arg_0_0, arg_0_1) =
            this.CreateCurrentUserRepo (arg_0_0, arg_0_1)

        member this.GetUserSettings arg_0_0 = this.GetUserSettings (arg_0_0)

        member this.UpdateUserSettings (arg_0_0, arg_0_1) =
            this.UpdateUserSettings (arg_0_0, arg_0_1)

        member this.UserCurrentListStarred (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentListStarred (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentCheckStarring (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentCheckStarring (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentDeleteStar (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentDeleteStar (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentPutStar (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentPutStar (arg_0_0, arg_0_1, arg_0_2)

        member this.UserGetStopWatches (arg_0_0, arg_0_1, arg_0_2) =
            this.UserGetStopWatches (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentListSubscriptions (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCurrentListSubscriptions (arg_0_0, arg_0_1, arg_0_2)

        member this.UserListTeams (arg_0_0, arg_0_1, arg_0_2) =
            this.UserListTeams (arg_0_0, arg_0_1, arg_0_2)

        member this.UserCurrentTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.UserCurrentTrackedTimes (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.UserSearch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.UserSearch (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.UserGet (arg_0_0, arg_0_1) = this.UserGet (arg_0_0, arg_0_1)

        member this.UserListFollowers (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserListFollowers (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserListFollowing (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserListFollowing (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserCheckFollowing (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCheckFollowing (arg_0_0, arg_0_1, arg_0_2)

        member this.UserGetHeatmapData (arg_0_0, arg_0_1) =
            this.UserGetHeatmapData (arg_0_0, arg_0_1)

        member this.UserListKeys (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4) =
            this.UserListKeys (arg_0_0, arg_0_1, arg_0_2, arg_0_3, arg_0_4)

        member this.OrgListUserOrgs (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.OrgListUserOrgs (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.OrgGetUserPermissions (arg_0_0, arg_0_1, arg_0_2) =
            this.OrgGetUserPermissions (arg_0_0, arg_0_1, arg_0_2)

        member this.UserListRepos (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserListRepos (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserListStarred (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserListStarred (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserListSubscriptions (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserListSubscriptions (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserGetTokens (arg_0_0, arg_0_1, arg_0_2, arg_0_3) =
            this.UserGetTokens (arg_0_0, arg_0_1, arg_0_2, arg_0_3)

        member this.UserCreateToken (arg_0_0, arg_0_1, arg_0_2) =
            this.UserCreateToken (arg_0_0, arg_0_1, arg_0_2)

        member this.UserDeleteAccessToken (arg_0_0, arg_0_1, arg_0_2) =
            this.UserDeleteAccessToken (arg_0_0, arg_0_1, arg_0_2)

        member this.GetVersion arg_0_0 = this.GetVersion (arg_0_0)

namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the APIError type
[<AutoOpen>]
module APIErrorJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type APIError with

        /// Serialize to a JSON node
        static member toJsonNode (input : APIError) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AccessToken type
[<AutoOpen>]
module AccessTokenJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AccessToken with

        /// Serialize to a JSON node
        static member toJsonNode (input : AccessToken) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "scopes",
                    (input.Scopes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha1",
                    (input.Sha1
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tokenLastEight",
                    (input.TokenLastEight
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ActivityPub type
[<AutoOpen>]
module ActivityPubJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ActivityPub with

        /// Serialize to a JSON node
        static member toJsonNode (input : ActivityPub) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AddCollaboratorOption type
[<AutoOpen>]
module AddCollaboratorOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AddCollaboratorOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : AddCollaboratorOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AddTimeOption type
[<AutoOpen>]
module AddTimeOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AddTimeOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : AddTimeOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("time", (input.Time |> System.Text.Json.Nodes.JsonValue.Create<int>))

                node.Add (
                    "userName",
                    (input.UserName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AnnotatedTagObject type
[<AutoOpen>]
module AnnotatedTagObjectJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTagObject with

        /// Serialize to a JSON node
        static member toJsonNode (input : AnnotatedTagObject) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Attachment type
[<AutoOpen>]
module AttachmentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Attachment with

        /// Serialize to a JSON node
        static member toJsonNode (input : Attachment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "browserDownloadUrl",
                    (input.BrowserDownloadUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "downloadCount",
                    (input.DownloadCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "uuid",
                    (input.Uuid
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the BranchProtection type
[<AutoOpen>]
module BranchProtectionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type BranchProtection with

        /// Serialize to a JSON node
        static member toJsonNode (input : BranchProtection) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "approvalsWhitelistTeams",
                    (input.ApprovalsWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "approvalsWhitelistUsername",
                    (input.ApprovalsWhitelistUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnOfficialReviewRequests",
                    (input.BlockOnOfficialReviewRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnOutdatedBranch",
                    (input.BlockOnOutdatedBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnRejectedReviews",
                    (input.BlockOnRejectedReviews
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branchName",
                    (input.BranchName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismissStaleApprovals",
                    (input.DismissStaleApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableApprovalsWhitelist",
                    (input.EnableApprovalsWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableMergeWhitelist",
                    (input.EnableMergeWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePush",
                    (input.EnablePush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePushWhitelist",
                    (input.EnablePushWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableStatusCheck",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhitelistTeams",
                    (input.MergeWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhitelistUsernames",
                    (input.MergeWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protectedFilePatterns",
                    (input.ProtectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistDeployKeys",
                    (input.PushWhitelistDeployKeys
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistTeams",
                    (input.PushWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistUsernames",
                    (input.PushWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requireSignedCommits",
                    (input.RequireSignedCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requiredApprovals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ruleName",
                    (input.RuleName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "statusCheckContexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unprotectedFilePatterns",
                    (input.UnprotectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ChangedFile type
[<AutoOpen>]
module ChangedFileJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ChangedFile with

        /// Serialize to a JSON node
        static member toJsonNode (input : ChangedFile) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "additions",
                    (input.Additions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "changes",
                    (input.Changes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "contentsUrl",
                    (input.ContentsUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "deletions",
                    (input.Deletions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "filename",
                    (input.Filename
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "previousFilename",
                    (input.PreviousFilename
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "rawUrl",
                    (input.RawUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status",
                    (input.Status
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitAffectedFiles type
[<AutoOpen>]
module CommitAffectedFilesJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitAffectedFiles with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitAffectedFiles) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "filename",
                    (input.Filename
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitDateOptions type
[<AutoOpen>]
module CommitDateOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitDateOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitDateOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitMeta type
[<AutoOpen>]
module CommitMetaJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitMeta with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitMeta) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitStats type
[<AutoOpen>]
module CommitStatsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitStats with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitStats) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "additions",
                    (input.Additions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "deletions",
                    (input.Deletions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "total",
                    (input.Total
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitUser type
[<AutoOpen>]
module CommitUserJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitUser with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitUser) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "date",
                    (input.Date
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateAccessTokenOption type
[<AutoOpen>]
module CreateAccessTokenOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateAccessTokenOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateAccessTokenOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "scopes",
                    (input.Scopes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateBranchProtectionOption type
[<AutoOpen>]
module CreateBranchProtectionOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateBranchProtectionOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateBranchProtectionOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "approvalsWhitelistTeams",
                    (input.ApprovalsWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "approvalsWhitelistUsername",
                    (input.ApprovalsWhitelistUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnOfficialReviewRequests",
                    (input.BlockOnOfficialReviewRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnOutdatedBranch",
                    (input.BlockOnOutdatedBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnRejectedReviews",
                    (input.BlockOnRejectedReviews
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branchName",
                    (input.BranchName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismissStaleApprovals",
                    (input.DismissStaleApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableApprovalsWhitelist",
                    (input.EnableApprovalsWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableMergeWhitelist",
                    (input.EnableMergeWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePush",
                    (input.EnablePush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePushWhitelist",
                    (input.EnablePushWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableStatusCheck",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhitelistTeams",
                    (input.MergeWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhitelistUsernames",
                    (input.MergeWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protectedFilePatterns",
                    (input.ProtectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistDeployKeys",
                    (input.PushWhitelistDeployKeys
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistTeams",
                    (input.PushWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistUsernames",
                    (input.PushWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requireSignedCommits",
                    (input.RequireSignedCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requiredApprovals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ruleName",
                    (input.RuleName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "statusCheckContexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unprotectedFilePatterns",
                    (input.UnprotectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateBranchRepoOption type
[<AutoOpen>]
module CreateBranchRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateBranchRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateBranchRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("newBranchName", (input.NewBranchName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "oldBranchName",
                    (input.OldBranchName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateEmailOption type
[<AutoOpen>]
module CreateEmailOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateEmailOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateEmailOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "emails",
                    (input.Emails
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateForkOption type
[<AutoOpen>]
module CreateForkOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateForkOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateForkOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "organization",
                    (input.Organization
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateGPGKeyOption type
[<AutoOpen>]
module CreateGPGKeyOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateGPGKeyOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateGPGKeyOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "armoredPublicKey",
                    (input.ArmoredPublicKey |> System.Text.Json.Nodes.JsonValue.Create<string>)
                )

                node.Add (
                    "armoredSignature",
                    (input.ArmoredSignature
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateHookOptionConfig type
[<AutoOpen>]
module CreateHookOptionConfigJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateHookOptionConfig with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateHookOptionConfig) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateIssueCommentOption type
[<AutoOpen>]
module CreateIssueCommentOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateIssueCommentOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateIssueCommentOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("body", (input.Body |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateIssueOption type
[<AutoOpen>]
module CreateIssueOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateIssueOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateIssueOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closed",
                    (input.Closed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("title", (input.Title |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateKeyOption type
[<AutoOpen>]
module CreateKeyOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateKeyOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateKeyOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("key", (input.Key |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "readOnly",
                    (input.ReadOnly
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("title", (input.Title |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateLabelOption type
[<AutoOpen>]
module CreateLabelOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateLabelOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateLabelOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("color", (input.Color |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "exclusive",
                    (input.Exclusive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateMilestoneOption type
[<AutoOpen>]
module CreateMilestoneOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateMilestoneOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateMilestoneOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "dueOn",
                    (input.DueOn
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateOAuth2ApplicationOptions type
[<AutoOpen>]
module CreateOAuth2ApplicationOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateOAuth2ApplicationOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateOAuth2ApplicationOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "confidentialClient",
                    (input.ConfidentialClient
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "redirectUris",
                    (input.RedirectUris
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateOrgOption type
[<AutoOpen>]
module CreateOrgOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateOrgOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateOrgOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoAdminChangeTeamAccess",
                    (input.RepoAdminChangeTeamAccess
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("username", (input.Username |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePullRequestOption type
[<AutoOpen>]
module CreatePullRequestOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePullRequestOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePullRequestOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "base",
                    (input.Base
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "head",
                    (input.Head
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePullReviewComment type
[<AutoOpen>]
module CreatePullReviewCommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewComment with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePullReviewComment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "newPosition",
                    (input.NewPosition
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "oldPosition",
                    (input.OldPosition
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePushMirrorOption type
[<AutoOpen>]
module CreatePushMirrorOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePushMirrorOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePushMirrorOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "interval",
                    (input.Interval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remoteAddress",
                    (input.RemoteAddress
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remotePassword",
                    (input.RemotePassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remoteUsername",
                    (input.RemoteUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "syncOnCommit",
                    (input.SyncOnCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateReleaseOption type
[<AutoOpen>]
module CreateReleaseOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateReleaseOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateReleaseOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "draft",
                    (input.Draft
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prerelease",
                    (input.Prerelease
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("tagName", (input.TagName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "targetCommitish",
                    (input.TargetCommitish
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateRepoOption type
[<AutoOpen>]
module CreateRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "autoInit",
                    (input.AutoInit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultBranch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "gitignores",
                    (input.Gitignores
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issueLabels",
                    (input.IssueLabels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "license",
                    (input.License
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "readme",
                    (input.Readme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "template",
                    (input.Template
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "trustModel",
                    (input.TrustModel
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateStatusOption type
[<AutoOpen>]
module CreateStatusOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateStatusOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateStatusOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "targetUrl",
                    (input.TargetUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateTagOption type
[<AutoOpen>]
module CreateTagOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateTagOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateTagOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("tagName", (input.TagName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "target",
                    (input.Target
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type1 type
[<AutoOpen>]
module Type1JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type1 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type1) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateTeamOption type
[<AutoOpen>]
module CreateTeamOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateTeamOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateTeamOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "canCreateOrgRepo",
                    (input.CanCreateOrgRepo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "includesAllRepositories",
                    (input.IncludesAllRepositories
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units",
                    (input.Units
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unitsMap",
                    (input.UnitsMap
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type1.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateUserOption type
[<AutoOpen>]
module CreateUserOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateUserOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateUserOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("email", (input.Email |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "loginName",
                    (input.LoginName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mustChangePassword",
                    (input.MustChangePassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("password", (input.Password |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "restricted",
                    (input.Restricted
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sendNotify",
                    (input.SendNotify
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sourceId",
                    (input.SourceId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("username", (input.Username |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateWikiPageOptions type
[<AutoOpen>]
module CreateWikiPageOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateWikiPageOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateWikiPageOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "contentBase64",
                    (input.ContentBase64
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Cron type
[<AutoOpen>]
module CronJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Cron with

        /// Serialize to a JSON node
        static member toJsonNode (input : Cron) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "execTimes",
                    (input.ExecTimes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "next",
                    (input.Next
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prev",
                    (input.Prev
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "schedule",
                    (input.Schedule
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DeleteEmailOption type
[<AutoOpen>]
module DeleteEmailOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DeleteEmailOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : DeleteEmailOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "emails",
                    (input.Emails
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DismissPullReviewOptions type
[<AutoOpen>]
module DismissPullReviewOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DismissPullReviewOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : DismissPullReviewOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "priors",
                    (input.Priors
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditAttachmentOptions type
[<AutoOpen>]
module EditAttachmentOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditAttachmentOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditAttachmentOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditBranchProtectionOption type
[<AutoOpen>]
module EditBranchProtectionOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditBranchProtectionOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditBranchProtectionOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "approvalsWhitelistTeams",
                    (input.ApprovalsWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "approvalsWhitelistUsername",
                    (input.ApprovalsWhitelistUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnOfficialReviewRequests",
                    (input.BlockOnOfficialReviewRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnOutdatedBranch",
                    (input.BlockOnOutdatedBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "blockOnRejectedReviews",
                    (input.BlockOnRejectedReviews
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismissStaleApprovals",
                    (input.DismissStaleApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableApprovalsWhitelist",
                    (input.EnableApprovalsWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableMergeWhitelist",
                    (input.EnableMergeWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePush",
                    (input.EnablePush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePushWhitelist",
                    (input.EnablePushWhitelist
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableStatusCheck",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhitelistTeams",
                    (input.MergeWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhitelistUsernames",
                    (input.MergeWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protectedFilePatterns",
                    (input.ProtectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistDeployKeys",
                    (input.PushWhitelistDeployKeys
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistTeams",
                    (input.PushWhitelistTeams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pushWhitelistUsernames",
                    (input.PushWhitelistUsernames
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requireSignedCommits",
                    (input.RequireSignedCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requiredApprovals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "statusCheckContexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unprotectedFilePatterns",
                    (input.UnprotectedFilePatterns
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditDeadlineOption type
[<AutoOpen>]
module EditDeadlineOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditDeadlineOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditDeadlineOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("dueDate", (input.DueDate |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditGitHookOption type
[<AutoOpen>]
module EditGitHookOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditGitHookOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditGitHookOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type2 type
[<AutoOpen>]
module Type2JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type2 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type2) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditHookOption type
[<AutoOpen>]
module EditHookOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditHookOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditHookOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authorizationHeader",
                    (input.AuthorizationHeader
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branchFilter",
                    (input.BranchFilter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "config",
                    (input.Config
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type2.toJsonNode field
                     ))
                )

                node.Add (
                    "events",
                    (input.Events
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditIssueCommentOption type
[<AutoOpen>]
module EditIssueCommentOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditIssueCommentOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditIssueCommentOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("body", (input.Body |> System.Text.Json.Nodes.JsonValue.Create<string>))

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditIssueOption type
[<AutoOpen>]
module EditIssueOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditIssueOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditIssueOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unsetDueDate",
                    (input.UnsetDueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditLabelOption type
[<AutoOpen>]
module EditLabelOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditLabelOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditLabelOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "color",
                    (input.Color
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "exclusive",
                    (input.Exclusive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditMilestoneOption type
[<AutoOpen>]
module EditMilestoneOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditMilestoneOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditMilestoneOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "dueOn",
                    (input.DueOn
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditOrgOption type
[<AutoOpen>]
module EditOrgOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditOrgOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditOrgOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoAdminChangeTeamAccess",
                    (input.RepoAdminChangeTeamAccess
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditPullRequestOption type
[<AutoOpen>]
module EditPullRequestOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditPullRequestOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditPullRequestOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowMaintainerEdit",
                    (input.AllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "base",
                    (input.Base
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unsetDueDate",
                    (input.UnsetDueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditReactionOption type
[<AutoOpen>]
module EditReactionOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditReactionOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditReactionOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditReleaseOption type
[<AutoOpen>]
module EditReleaseOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditReleaseOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditReleaseOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "draft",
                    (input.Draft
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prerelease",
                    (input.Prerelease
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tagName",
                    (input.TagName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "targetCommitish",
                    (input.TargetCommitish
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type3 type
[<AutoOpen>]
module Type3JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type3 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type3) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditTeamOption type
[<AutoOpen>]
module EditTeamOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditTeamOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditTeamOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "canCreateOrgRepo",
                    (input.CanCreateOrgRepo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "includesAllRepositories",
                    (input.IncludesAllRepositories
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units",
                    (input.Units
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unitsMap",
                    (input.UnitsMap
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type3.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditUserOption type
[<AutoOpen>]
module EditUserOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditUserOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditUserOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "admin",
                    (input.Admin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowCreateOrganization",
                    (input.AllowCreateOrganization
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowGitHook",
                    (input.AllowGitHook
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowImportLocal",
                    (input.AllowImportLocal
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("loginName", (input.LoginName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "maxRepoCreation",
                    (input.MaxRepoCreation
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mustChangePassword",
                    (input.MustChangePassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "password",
                    (input.Password
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prohibitLogin",
                    (input.ProhibitLogin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "restricted",
                    (input.Restricted
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("sourceId", (input.SourceId |> System.Text.Json.Nodes.JsonValue.Create<int>))

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Email type
[<AutoOpen>]
module EmailJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Email with

        /// Serialize to a JSON node
        static member toJsonNode (input : Email) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "primary",
                    (input.Primary
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verified",
                    (input.Verified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ExternalTracker type
[<AutoOpen>]
module ExternalTrackerJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ExternalTracker with

        /// Serialize to a JSON node
        static member toJsonNode (input : ExternalTracker) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "externalTrackerFormat",
                    (input.ExternalTrackerFormat
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "externalTrackerRegexpPattern",
                    (input.ExternalTrackerRegexpPattern
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "externalTrackerStyle",
                    (input.ExternalTrackerStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "externalTrackerUrl",
                    (input.ExternalTrackerUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ExternalWiki type
[<AutoOpen>]
module ExternalWikiJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ExternalWiki with

        /// Serialize to a JSON node
        static member toJsonNode (input : ExternalWiki) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "externalWikiUrl",
                    (input.ExternalWikiUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileCommitResponse type
[<AutoOpen>]
module FileCommitResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileCommitResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileCommitResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "parents",
                    (input.Parents
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitMeta.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tree",
                    (input.Tree
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileLinksResponse type
[<AutoOpen>]
module FileLinksResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileLinksResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileLinksResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "git",
                    (input.Git
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "html",
                    (input.Html
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "self",
                    (input.Self
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GPGKeyEmail type
[<AutoOpen>]
module GPGKeyEmailJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GPGKeyEmail with

        /// Serialize to a JSON node
        static member toJsonNode (input : GPGKeyEmail) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verified",
                    (input.Verified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralAPISettings type
[<AutoOpen>]
module GeneralAPISettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralAPISettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralAPISettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "defaultGitTreesPerPage",
                    (input.DefaultGitTreesPerPage
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultMaxBlobSize",
                    (input.DefaultMaxBlobSize
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultPagingNum",
                    (input.DefaultPagingNum
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "maxResponseItems",
                    (input.MaxResponseItems
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralAttachmentSettings type
[<AutoOpen>]
module GeneralAttachmentSettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralAttachmentSettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralAttachmentSettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowedTypes",
                    (input.AllowedTypes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enabled",
                    (input.Enabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "maxFiles",
                    (input.MaxFiles
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "maxSize",
                    (input.MaxSize
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralRepoSettings type
[<AutoOpen>]
module GeneralRepoSettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralRepoSettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralRepoSettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "httpGitDisabled",
                    (input.HttpGitDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lfsDisabled",
                    (input.LfsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "migrationsDisabled",
                    (input.MigrationsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirrorsDisabled",
                    (input.MirrorsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "starsDisabled",
                    (input.StarsDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "timeTrackingDisabled",
                    (input.TimeTrackingDisabled
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GeneralUISettings type
[<AutoOpen>]
module GeneralUISettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GeneralUISettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : GeneralUISettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowedReactions",
                    (input.AllowedReactions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "customEmojis",
                    (input.CustomEmojis
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultTheme",
                    (input.DefaultTheme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GenerateRepoOption type
[<AutoOpen>]
module GenerateRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GenerateRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : GenerateRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "avatar",
                    (input.Avatar
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultBranch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "gitContent",
                    (input.GitContent
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "gitHooks",
                    (input.GitHooks
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("name", (input.Name |> System.Text.Json.Nodes.JsonValue.Create<string>))
                node.Add ("owner", (input.Owner |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "topics",
                    (input.Topics
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "webhooks",
                    (input.Webhooks
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitBlobResponse type
[<AutoOpen>]
module GitBlobResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitBlobResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitBlobResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "encoding",
                    (input.Encoding
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitEntry type
[<AutoOpen>]
module GitEntryJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitEntry with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitEntry) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "mode",
                    (input.Mode
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitHook type
[<AutoOpen>]
module GitHookJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitHook with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitHook) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "isActive",
                    (input.IsActive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitObject type
[<AutoOpen>]
module GitObjectJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitObject with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitObject) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the GitTreeResponse type
[<AutoOpen>]
module GitTreeResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type GitTreeResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : GitTreeResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "page",
                    (input.Page
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "totalCount",
                    (input.TotalCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tree",
                    (input.Tree
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (GitEntry.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "truncated",
                    (input.Truncated
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type4 type
[<AutoOpen>]
module Type4JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type4 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type4) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Hook type
[<AutoOpen>]
module HookJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Hook with

        /// Serialize to a JSON node
        static member toJsonNode (input : Hook) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authorizationHeader",
                    (input.AuthorizationHeader
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "config",
                    (input.Config
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type4.toJsonNode field
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "events",
                    (input.Events
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Identity type
[<AutoOpen>]
module IdentityJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Identity with

        /// Serialize to a JSON node
        static member toJsonNode (input : Identity) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the InternalTracker type
[<AutoOpen>]
module InternalTrackerJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type InternalTracker with

        /// Serialize to a JSON node
        static member toJsonNode (input : InternalTracker) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowOnlyContributorsToTrackTime",
                    (input.AllowOnlyContributorsToTrackTime
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableIssueDependencies",
                    (input.EnableIssueDependencies
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableTimeTracker",
                    (input.EnableTimeTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueDeadline type
[<AutoOpen>]
module IssueDeadlineJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueDeadline with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueDeadline) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type5 type
[<AutoOpen>]
module Type5JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type5 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type5) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, (fun value -> System.Text.Json.Nodes.JsonObject ()) value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type6 type
[<AutoOpen>]
module Type6JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type6 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type6) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, (fun value -> System.Text.Json.Nodes.JsonObject ()) value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueFormField type
[<AutoOpen>]
module IssueFormFieldJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueFormField with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueFormField) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "attributes",
                    (input.Attributes
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type5.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "validations",
                    (input.Validations
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type6.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueLabelsOption type
[<AutoOpen>]
module IssueLabelsOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueLabelsOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueLabelsOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Label type
[<AutoOpen>]
module LabelJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Label with

        /// Serialize to a JSON node
        static member toJsonNode (input : Label) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "color",
                    (input.Color
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "exclusive",
                    (input.Exclusive
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the MarkdownOption type
[<AutoOpen>]
module MarkdownOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type MarkdownOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : MarkdownOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mode",
                    (input.Mode
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "text",
                    (input.Text
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "wiki",
                    (input.Wiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the MergePullRequestOption type
[<AutoOpen>]
module MergePullRequestOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type MergePullRequestOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : MergePullRequestOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("do", (input.Do |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "mergeCommitID",
                    (input.MergeCommitID
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeMessageField",
                    (input.MergeMessageField
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeTitleField",
                    (input.MergeTitleField
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "deleteBranchAfterMerge",
                    (input.DeleteBranchAfterMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "forceMerge",
                    (input.ForceMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "headCommitId",
                    (input.HeadCommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeWhenChecksSucceed",
                    (input.MergeWhenChecksSucceed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the MigrateRepoOptions type
[<AutoOpen>]
module MigrateRepoOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type MigrateRepoOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : MigrateRepoOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "authPassword",
                    (input.AuthPassword
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authToken",
                    (input.AuthToken
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authUsername",
                    (input.AuthUsername
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("cloneAddr", (input.CloneAddr |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "issues",
                    (input.Issues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lfs",
                    (input.Lfs
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lfsEndpoint",
                    (input.LfsEndpoint
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestones",
                    (input.Milestones
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror",
                    (input.Mirror
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirrorInterval",
                    (input.MirrorInterval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequests",
                    (input.PullRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "releases",
                    (input.Releases
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("repoName", (input.RepoName |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "repoOwner",
                    (input.RepoOwner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "service",
                    (input.Service
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "uid",
                    (input.Uid
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "wiki",
                    (input.Wiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type7 type
[<AutoOpen>]
module Type7JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type7 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type7) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoServices type
[<AutoOpen>]
module NodeInfoServicesJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoServices with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoServices) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "inbound",
                    (input.Inbound
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "outbound",
                    (input.Outbound
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoSoftware type
[<AutoOpen>]
module NodeInfoSoftwareJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoSoftware with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoSoftware) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "homepage",
                    (input.Homepage
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoUsageUsers type
[<AutoOpen>]
module NodeInfoUsageUsersJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsageUsers with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoUsageUsers) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "activeHalfyear",
                    (input.ActiveHalfyear
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "activeMonth",
                    (input.ActiveMonth
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "total",
                    (input.Total
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NotificationCount type
[<AutoOpen>]
module NotificationCountJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NotificationCount with

        /// Serialize to a JSON node
        static member toJsonNode (input : NotificationCount) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "new",
                    (input.New
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the OAuth2Application type
[<AutoOpen>]
module OAuth2ApplicationJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type OAuth2Application with

        /// Serialize to a JSON node
        static member toJsonNode (input : OAuth2Application) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "clientId",
                    (input.ClientId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "clientSecret",
                    (input.ClientSecret
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "confidentialClient",
                    (input.ConfidentialClient
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "redirectUris",
                    (input.RedirectUris
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Organization type
[<AutoOpen>]
module OrganizationJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Organization with

        /// Serialize to a JSON node
        static member toJsonNode (input : Organization) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "avatarUrl",
                    (input.AvatarUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoAdminChangeTeamAccess",
                    (input.RepoAdminChangeTeamAccess
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "username",
                    (input.Username
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the OrganizationPermissions type
[<AutoOpen>]
module OrganizationPermissionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type OrganizationPermissions with

        /// Serialize to a JSON node
        static member toJsonNode (input : OrganizationPermissions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "canCreateRepository",
                    (input.CanCreateRepository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "canRead",
                    (input.CanRead
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "canWrite",
                    (input.CanWrite
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "isAdmin",
                    (input.IsAdmin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "isOwner",
                    (input.IsOwner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PackageFile type
[<AutoOpen>]
module PackageFileJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PackageFile with

        /// Serialize to a JSON node
        static member toJsonNode (input : PackageFile) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "md5",
                    (input.Md5
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha1",
                    (input.Sha1
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha256",
                    (input.Sha256
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha512",
                    (input.Sha512
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PayloadUser type
[<AutoOpen>]
module PayloadUserJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PayloadUser with

        /// Serialize to a JSON node
        static member toJsonNode (input : PayloadUser) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "username",
                    (input.Username
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Permission type
[<AutoOpen>]
module PermissionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Permission with

        /// Serialize to a JSON node
        static member toJsonNode (input : Permission) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "admin",
                    (input.Admin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pull",
                    (input.Pull
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "push",
                    (input.Push
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullRequestMeta type
[<AutoOpen>]
module PullRequestMetaJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullRequestMeta with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullRequestMeta) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "merged",
                    (input.Merged
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergedAt",
                    (input.MergedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullReviewRequestOptions type
[<AutoOpen>]
module PullReviewRequestOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullReviewRequestOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullReviewRequestOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "reviewers",
                    (input.Reviewers
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "teamReviewers",
                    (input.TeamReviewers
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PushMirror type
[<AutoOpen>]
module PushMirrorJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PushMirror with

        /// Serialize to a JSON node
        static member toJsonNode (input : PushMirror) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "interval",
                    (input.Interval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lastError",
                    (input.LastError
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lastUpdate",
                    (input.LastUpdate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remoteAddress",
                    (input.RemoteAddress
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "remoteName",
                    (input.RemoteName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoName",
                    (input.RepoName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "syncOnCommit",
                    (input.SyncOnCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Reference type
[<AutoOpen>]
module ReferenceJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Reference with

        /// Serialize to a JSON node
        static member toJsonNode (input : Reference) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "object",
                    (input.Object
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> GitObject.toJsonNode field
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoTopicOptions type
[<AutoOpen>]
module RepoTopicOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoTopicOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoTopicOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "topics",
                    (input.Topics
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepositoryMeta type
[<AutoOpen>]
module RepositoryMetaJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepositoryMeta with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepositoryMeta) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "owner",
                    (input.Owner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ServerVersion type
[<AutoOpen>]
module ServerVersionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ServerVersion with

        /// Serialize to a JSON node
        static member toJsonNode (input : ServerVersion) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the StopWatch type
[<AutoOpen>]
module StopWatchJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type StopWatch with

        /// Serialize to a JSON node
        static member toJsonNode (input : StopWatch) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "duration",
                    (input.Duration
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issueIndex",
                    (input.IssueIndex
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issueTitle",
                    (input.IssueTitle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoName",
                    (input.RepoName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoOwnerName",
                    (input.RepoOwnerName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "seconds",
                    (input.Seconds
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the SubmitPullReviewOptions type
[<AutoOpen>]
module SubmitPullReviewOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type SubmitPullReviewOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : SubmitPullReviewOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "event",
                    (input.Event
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Tag type
[<AutoOpen>]
module TagJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Tag with

        /// Serialize to a JSON node
        static member toJsonNode (input : Tag) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tarballUrl",
                    (input.TarballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "zipballUrl",
                    (input.ZipballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Type8 type
[<AutoOpen>]
module Type8JsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Type8 with

        /// Serialize to a JSON node
        static member toJsonNode (input : Type8) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<string> value)

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Team type
[<AutoOpen>]
module TeamJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Team with

        /// Serialize to a JSON node
        static member toJsonNode (input : Team) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "canCreateOrgRepo",
                    (input.CanCreateOrgRepo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "includesAllRepositories",
                    (input.IncludesAllRepositories
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "organization",
                    (input.Organization
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Organization.toJsonNode field
                     ))
                )

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "units",
                    (input.Units
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "unitsMap",
                    (input.UnitsMap
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type8.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TopicName type
[<AutoOpen>]
module TopicNameJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TopicName with

        /// Serialize to a JSON node
        static member toJsonNode (input : TopicName) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "topics",
                    (input.Topics
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TopicResponse type
[<AutoOpen>]
module TopicResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TopicResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : TopicResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoCount",
                    (input.RepoCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "topicName",
                    (input.TopicName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updated",
                    (input.Updated
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TransferRepoOption type
[<AutoOpen>]
module TransferRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TransferRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : TransferRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add ("newOwner", (input.NewOwner |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "teamIds",
                    (input.TeamIds
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<int> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UpdateFileOptions type
[<AutoOpen>]
module UpdateFileOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UpdateFileOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : UpdateFileOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "branch",
                    (input.Branch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add ("content", (input.Content |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "dates",
                    (input.Dates
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitDateOptions.toJsonNode field
                     ))
                )

                node.Add (
                    "fromPath",
                    (input.FromPath
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "newBranch",
                    (input.NewBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("sha", (input.Sha |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "signoff",
                    (input.Signoff
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the User type
[<AutoOpen>]
module UserJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type User with

        /// Serialize to a JSON node
        static member toJsonNode (input : User) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "avatarUrl",
                    (input.AvatarUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "email",
                    (input.Email
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "followersCount",
                    (input.FollowersCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "followingCount",
                    (input.FollowingCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "isAdmin",
                    (input.IsAdmin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lastLogin",
                    (input.LastLogin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "login",
                    (input.Login
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "loginName",
                    (input.LoginName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prohibitLogin",
                    (input.ProhibitLogin
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "restricted",
                    (input.Restricted
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "starredReposCount",
                    (input.StarredReposCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "visibility",
                    (input.Visibility
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UserHeatmapData type
[<AutoOpen>]
module UserHeatmapDataJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UserHeatmapData with

        /// Serialize to a JSON node
        static member toJsonNode (input : UserHeatmapData) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "contributions",
                    (input.Contributions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "timestamp",
                    (input.Timestamp
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UserSettings type
[<AutoOpen>]
module UserSettingsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UserSettings with

        /// Serialize to a JSON node
        static member toJsonNode (input : UserSettings) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "diffViewStyle",
                    (input.DiffViewStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hideActivity",
                    (input.HideActivity
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hideEmail",
                    (input.HideEmail
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "theme",
                    (input.Theme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the UserSettingsOptions type
[<AutoOpen>]
module UserSettingsOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type UserSettingsOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : UserSettingsOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "diffViewStyle",
                    (input.DiffViewStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hideActivity",
                    (input.HideActivity
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hideEmail",
                    (input.HideEmail
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "location",
                    (input.Location
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "theme",
                    (input.Theme
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WatchInfo type
[<AutoOpen>]
module WatchInfoJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WatchInfo with

        /// Serialize to a JSON node
        static member toJsonNode (input : WatchInfo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ignored",
                    (input.Ignored
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "reason",
                    (input.Reason
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun value -> System.Text.Json.Nodes.JsonObject ()) field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repositoryUrl",
                    (input.RepositoryUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "subscribed",
                    (input.Subscribed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiCommit type
[<AutoOpen>]
module WikiCommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiCommit with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiCommit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "commiter",
                    (input.Commiter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiCommitList type
[<AutoOpen>]
module WikiCommitListJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiCommitList with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiCommitList) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commits",
                    (input.Commits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (WikiCommit.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "count",
                    (input.Count
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiPage type
[<AutoOpen>]
module WikiPageJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiPage with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiPage) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commitCount",
                    (input.CommitCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "contentBase64",
                    (input.ContentBase64
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "footer",
                    (input.Footer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lastCommit",
                    (input.LastCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> WikiCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "sidebar",
                    (input.Sidebar
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "subUrl",
                    (input.SubUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the WikiPageMetaData type
[<AutoOpen>]
module WikiPageMetaDataJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type WikiPageMetaData with

        /// Serialize to a JSON node
        static member toJsonNode (input : WikiPageMetaData) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lastCommit",
                    (input.LastCommit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> WikiCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "subUrl",
                    (input.SubUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Comment type
[<AutoOpen>]
module CommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Comment with

        /// Serialize to a JSON node
        static member toJsonNode (input : Comment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assets",
                    (input.Assets
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Attachment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issueUrl",
                    (input.IssueUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalAuthor",
                    (input.OriginalAuthor
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalAuthorId",
                    (input.OriginalAuthorId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequestUrl",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CommitStatus type
[<AutoOpen>]
module CommitStatusJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CommitStatus with

        /// Serialize to a JSON node
        static member toJsonNode (input : CommitStatus) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "context",
                    (input.Context
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "creator",
                    (input.Creator
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "status",
                    (input.Status
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "targetUrl",
                    (input.TargetUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the ContentsResponse type
[<AutoOpen>]
module ContentsResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type ContentsResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : ContentsResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "links",
                    (input.Links
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> FileLinksResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "downloadUrl",
                    (input.DownloadUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "encoding",
                    (input.Encoding
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "gitUrl",
                    (input.GitUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "lastCommitSha",
                    (input.LastCommitSha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "submoduleGitUrl",
                    (input.SubmoduleGitUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "target",
                    (input.Target
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateFileOptions type
[<AutoOpen>]
module CreateFileOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateFileOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateFileOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "branch",
                    (input.Branch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add ("content", (input.Content |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "dates",
                    (input.Dates
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitDateOptions.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "newBranch",
                    (input.NewBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "signoff",
                    (input.Signoff
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreateHookOption type
[<AutoOpen>]
module CreateHookOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreateHookOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreateHookOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "active",
                    (input.Active
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "authorizationHeader",
                    (input.AuthorizationHeader
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "branchFilter",
                    (input.BranchFilter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("config", (input.Config |> CreateHookOptionConfig.toJsonNode))

                node.Add (
                    "events",
                    (input.Events
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CreatePullReviewOptions type
[<AutoOpen>]
module CreatePullReviewOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : CreatePullReviewOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments",
                    (input.Comments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CreatePullReviewComment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commitId",
                    (input.CommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "event",
                    (input.Event
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DeleteFileOptions type
[<AutoOpen>]
module DeleteFileOptionsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DeleteFileOptions with

        /// Serialize to a JSON node
        static member toJsonNode (input : DeleteFileOptions) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "branch",
                    (input.Branch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Identity.toJsonNode field
                     ))
                )

                node.Add (
                    "dates",
                    (input.Dates
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitDateOptions.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "newBranch",
                    (input.NewBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add ("sha", (input.Sha |> System.Text.Json.Nodes.JsonValue.Create<string>))

                node.Add (
                    "signoff",
                    (input.Signoff
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the EditRepoOption type
[<AutoOpen>]
module EditRepoOptionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type EditRepoOption with

        /// Serialize to a JSON node
        static member toJsonNode (input : EditRepoOption) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowManualMerge",
                    (input.AllowManualMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowMergeCommits",
                    (input.AllowMergeCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowRebase",
                    (input.AllowRebase
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowRebaseExplicit",
                    (input.AllowRebaseExplicit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowRebaseUpdate",
                    (input.AllowRebaseUpdate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowSquashMerge",
                    (input.AllowSquashMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "archived",
                    (input.Archived
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "autodetectManualMerge",
                    (input.AutodetectManualMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultAllowMaintainerEdit",
                    (input.DefaultAllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultBranch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultDeleteBranchAfterMerge",
                    (input.DefaultDeleteBranchAfterMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultMergeStyle",
                    (input.DefaultMergeStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enablePrune",
                    (input.EnablePrune
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "externalTracker",
                    (input.ExternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "externalWiki",
                    (input.ExternalWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalWiki.toJsonNode field
                     ))
                )

                node.Add (
                    "hasIssues",
                    (input.HasIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasProjects",
                    (input.HasProjects
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasPullRequests",
                    (input.HasPullRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasWiki",
                    (input.HasWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ignoreWhitespaceConflicts",
                    (input.IgnoreWhitespaceConflicts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "internalTracker",
                    (input.InternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> InternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "mirrorInterval",
                    (input.MirrorInterval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "template",
                    (input.Template
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the IssueTemplate type
[<AutoOpen>]
module IssueTemplateJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type IssueTemplate with

        /// Serialize to a JSON node
        static member toJsonNode (input : IssueTemplate) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "about",
                    (input.About
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (IssueFormField.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fileName",
                    (input.FileName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Milestone type
[<AutoOpen>]
module MilestoneJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Milestone with

        /// Serialize to a JSON node
        static member toJsonNode (input : Milestone) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "closedAt",
                    (input.ClosedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closedIssues",
                    (input.ClosedIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueOn",
                    (input.DueOn
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "openIssues",
                    (input.OpenIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfoUsage type
[<AutoOpen>]
module NodeInfoUsageJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsage with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfoUsage) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "localComments",
                    (input.LocalComments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "localPosts",
                    (input.LocalPosts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "users",
                    (input.Users
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoUsageUsers.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NotificationSubject type
[<AutoOpen>]
module NotificationSubjectJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NotificationSubject with

        /// Serialize to a JSON node
        static member toJsonNode (input : NotificationSubject) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "latestCommentHtmlUrl",
                    (input.LatestCommentHtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "latestCommentUrl",
                    (input.LatestCommentUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PayloadCommitVerification type
[<AutoOpen>]
module PayloadCommitVerificationJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PayloadCommitVerification with

        /// Serialize to a JSON node
        static member toJsonNode (input : PayloadCommitVerification) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "payload",
                    (input.Payload
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "reason",
                    (input.Reason
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "signature",
                    (input.Signature
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "signer",
                    (input.Signer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadUser.toJsonNode field
                     ))
                )

                node.Add (
                    "verified",
                    (input.Verified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PublicKey type
[<AutoOpen>]
module PublicKeyJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PublicKey with

        /// Serialize to a JSON node
        static member toJsonNode (input : PublicKey) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fingerprint",
                    (input.Fingerprint
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "key",
                    (input.Key
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "keyType",
                    (input.KeyType
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "readOnly",
                    (input.ReadOnly
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullReview type
[<AutoOpen>]
module PullReviewJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullReview with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullReview) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commentsCount",
                    (input.CommentsCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commitId",
                    (input.CommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dismissed",
                    (input.Dismissed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "official",
                    (input.Official
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequestUrl",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "stale",
                    (input.Stale
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "submittedAt",
                    (input.SubmittedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "team",
                    (input.Team
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Team.toJsonNode field
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullReviewComment type
[<AutoOpen>]
module PullReviewCommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullReviewComment with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullReviewComment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "commitId",
                    (input.CommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "diffHunk",
                    (input.DiffHunk
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalCommitId",
                    (input.OriginalCommitId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalPosition",
                    (input.OriginalPosition
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "path",
                    (input.Path
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "position",
                    (input.Position
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequestReviewId",
                    (input.PullRequestReviewId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequestUrl",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "resolver",
                    (input.Resolver
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Reaction type
[<AutoOpen>]
module ReactionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Reaction with

        /// Serialize to a JSON node
        static member toJsonNode (input : Reaction) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Release type
[<AutoOpen>]
module ReleaseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Release with

        /// Serialize to a JSON node
        static member toJsonNode (input : Release) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assets",
                    (input.Assets
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Attachment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "draft",
                    (input.Draft
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "prerelease",
                    (input.Prerelease
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "publishedAt",
                    (input.PublishedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tagName",
                    (input.TagName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tarballUrl",
                    (input.TarballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "targetCommitish",
                    (input.TargetCommitish
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "zipballUrl",
                    (input.ZipballUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoCollaboratorPermission type
[<AutoOpen>]
module RepoCollaboratorPermissionJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoCollaboratorPermission with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoCollaboratorPermission) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "permission",
                    (input.Permission
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "roleName",
                    (input.RoleName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoCommit type
[<AutoOpen>]
module RepoCommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoCommit with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoCommit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tree",
                    (input.Tree
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the RepoTransfer type
[<AutoOpen>]
module RepoTransferJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type RepoTransfer with

        /// Serialize to a JSON node
        static member toJsonNode (input : RepoTransfer) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "doer",
                    (input.Doer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "recipient",
                    (input.Recipient
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "teams",
                    (input.Teams
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Team.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Repository type
[<AutoOpen>]
module RepositoryJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Repository with

        /// Serialize to a JSON node
        static member toJsonNode (input : Repository) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowMergeCommits",
                    (input.AllowMergeCommits
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowRebase",
                    (input.AllowRebase
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowRebaseExplicit",
                    (input.AllowRebaseExplicit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowRebaseUpdate",
                    (input.AllowRebaseUpdate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "allowSquashMerge",
                    (input.AllowSquashMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "archived",
                    (input.Archived
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "avatarUrl",
                    (input.AvatarUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "cloneUrl",
                    (input.CloneUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultAllowMaintainerEdit",
                    (input.DefaultAllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultBranch",
                    (input.DefaultBranch
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultDeleteBranchAfterMerge",
                    (input.DefaultDeleteBranchAfterMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "defaultMergeStyle",
                    (input.DefaultMergeStyle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "empty",
                    (input.Empty
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "externalTracker",
                    (input.ExternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "externalWiki",
                    (input.ExternalWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ExternalWiki.toJsonNode field
                     ))
                )

                node.Add (
                    "fork",
                    (input.Fork
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "forksCount",
                    (input.ForksCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fullName",
                    (input.FullName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasIssues",
                    (input.HasIssues
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasProjects",
                    (input.HasProjects
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasPullRequests",
                    (input.HasPullRequests
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "hasWiki",
                    (input.HasWiki
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ignoreWhitespaceConflicts",
                    (input.IgnoreWhitespaceConflicts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "internal",
                    (input.Internal
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "internalTracker",
                    (input.InternalTracker
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> InternalTracker.toJsonNode field
                     ))
                )

                node.Add (
                    "language",
                    (input.Language
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "languagesUrl",
                    (input.LanguagesUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "link",
                    (input.Link
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirror",
                    (input.Mirror
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirrorInterval",
                    (input.MirrorInterval
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mirrorUpdated",
                    (input.MirrorUpdated
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "openIssuesCount",
                    (input.OpenIssuesCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "openPrCounter",
                    (input.OpenPrCounter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalUrl",
                    (input.OriginalUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "owner",
                    (input.Owner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add ("parent", (input.Parent |> Repository.toJsonNode))

                node.Add (
                    "permissions",
                    (input.Permissions
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Permission.toJsonNode field
                     ))
                )

                node.Add (
                    "private",
                    (input.Private
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "releaseCounter",
                    (input.ReleaseCounter
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repoTransfer",
                    (input.RepoTransfer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> RepoTransfer.toJsonNode field
                     ))
                )

                node.Add (
                    "size",
                    (input.Size
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sshUrl",
                    (input.SshUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "starsCount",
                    (input.StarsCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "template",
                    (input.Template
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "watchersCount",
                    (input.WatchersCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "website",
                    (input.Website
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the SearchResults type
[<AutoOpen>]
module SearchResultsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type SearchResults with

        /// Serialize to a JSON node
        static member toJsonNode (input : SearchResults) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "data",
                    (input.Data
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Repository.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ok",
                    (input.Ok
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the AnnotatedTag type
[<AutoOpen>]
module AnnotatedTagJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTag with

        /// Serialize to a JSON node
        static member toJsonNode (input : AnnotatedTag) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "object",
                    (input.Object
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> AnnotatedTagObject.toJsonNode field
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tag",
                    (input.Tag
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "tagger",
                    (input.Tagger
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitUser.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the CombinedStatus type
[<AutoOpen>]
module CombinedStatusJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type CombinedStatus with

        /// Serialize to a JSON node
        static member toJsonNode (input : CombinedStatus) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commitUrl",
                    (input.CommitUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "statuses",
                    (input.Statuses
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitStatus.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "totalCount",
                    (input.TotalCount
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Commit type
[<AutoOpen>]
module CommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Commit with

        /// Serialize to a JSON node
        static member toJsonNode (input : Commit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> RepoCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "files",
                    (input.Files
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitAffectedFiles.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "parents",
                    (input.Parents
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (CommitMeta.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "stats",
                    (input.Stats
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> CommitStats.toJsonNode field
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the DeployKey type
[<AutoOpen>]
module DeployKeyJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type DeployKey with

        /// Serialize to a JSON node
        static member toJsonNode (input : DeployKey) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "fingerprint",
                    (input.Fingerprint
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "key",
                    (input.Key
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "keyId",
                    (input.KeyId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "readOnly",
                    (input.ReadOnly
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileDeleteResponse type
[<AutoOpen>]
module FileDeleteResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileDeleteResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileDeleteResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> FileCommitResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun value -> System.Text.Json.Nodes.JsonObject ()) field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the FileResponse type
[<AutoOpen>]
module FileResponseJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type FileResponse with

        /// Serialize to a JSON node
        static member toJsonNode (input : FileResponse) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> FileCommitResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "content",
                    (input.Content
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> ContentsResponse.toJsonNode field
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Issue type
[<AutoOpen>]
module IssueJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Issue with

        /// Serialize to a JSON node
        static member toJsonNode (input : Issue) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assets",
                    (input.Assets
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Attachment.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (User.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closedAt",
                    (input.ClosedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments",
                    (input.Comments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "isLocked",
                    (input.IsLocked
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Label.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "number",
                    (input.Number
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalAuthor",
                    (input.OriginalAuthor
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "originalAuthorId",
                    (input.OriginalAuthorId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequest",
                    (input.PullRequest
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PullRequestMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> RepositoryMeta.toJsonNode field
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NodeInfo type
[<AutoOpen>]
module NodeInfoJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NodeInfo with

        /// Serialize to a JSON node
        static member toJsonNode (input : NodeInfo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "metadata",
                    (input.Metadata
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Type7.toJsonNode field
                     ))
                )

                node.Add (
                    "openRegistrations",
                    (input.OpenRegistrations
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protocols",
                    (input.Protocols
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "services",
                    (input.Services
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoServices.toJsonNode field
                     ))
                )

                node.Add (
                    "software",
                    (input.Software
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoSoftware.toJsonNode field
                     ))
                )

                node.Add (
                    "usage",
                    (input.Usage
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NodeInfoUsage.toJsonNode field
                     ))
                )

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Note type
[<AutoOpen>]
module NoteJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Note with

        /// Serialize to a JSON node
        static member toJsonNode (input : Note) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Commit.toJsonNode field
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the NotificationThread type
[<AutoOpen>]
module NotificationThreadJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type NotificationThread with

        /// Serialize to a JSON node
        static member toJsonNode (input : NotificationThread) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pinned",
                    (input.Pinned
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "subject",
                    (input.Subject
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> NotificationSubject.toJsonNode field
                     ))
                )

                node.Add (
                    "unread",
                    (input.Unread
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PRBranchInfo type
[<AutoOpen>]
module PRBranchInfoJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PRBranchInfo with

        /// Serialize to a JSON node
        static member toJsonNode (input : PRBranchInfo) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "label",
                    (input.Label
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "ref",
                    (input.Ref
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "repo",
                    (input.Repo
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "repoId",
                    (input.RepoId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "sha",
                    (input.Sha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Package type
[<AutoOpen>]
module PackageJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Package with

        /// Serialize to a JSON node
        static member toJsonNode (input : Package) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "creator",
                    (input.Creator
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "owner",
                    (input.Owner
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "repository",
                    (input.Repository
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Repository.toJsonNode field
                     ))
                )

                node.Add (
                    "version",
                    (input.Version
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PayloadCommit type
[<AutoOpen>]
module PayloadCommitJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PayloadCommit with

        /// Serialize to a JSON node
        static member toJsonNode (input : PayloadCommit) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "added",
                    (input.Added
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "author",
                    (input.Author
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadUser.toJsonNode field
                     ))
                )

                node.Add (
                    "committer",
                    (input.Committer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadUser.toJsonNode field
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "message",
                    (input.Message
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "modified",
                    (input.Modified
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "removed",
                    (input.Removed
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "timestamp",
                    (input.Timestamp
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "verification",
                    (input.Verification
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommitVerification.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the PullRequest type
[<AutoOpen>]
module PullRequestJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type PullRequest with

        /// Serialize to a JSON node
        static member toJsonNode (input : PullRequest) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "allowMaintainerEdit",
                    (input.AllowMaintainerEdit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "assignees",
                    (input.Assignees
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (User.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "base",
                    (input.Base
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PRBranchInfo.toJsonNode field
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "closedAt",
                    (input.ClosedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "comments",
                    (input.Comments
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "diffUrl",
                    (input.DiffUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dueDate",
                    (input.DueDate
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "head",
                    (input.Head
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PRBranchInfo.toJsonNode field
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "isLocked",
                    (input.IsLocked
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "labels",
                    (input.Labels
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (Label.toJsonNode mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeBase",
                    (input.MergeBase
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeCommitSha",
                    (input.MergeCommitSha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergeable",
                    (input.Mergeable
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "merged",
                    (input.Merged
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergedAt",
                    (input.MergedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "mergedBy",
                    (input.MergedBy
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "number",
                    (input.Number
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "patchUrl",
                    (input.PatchUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "state",
                    (input.State
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "title",
                    (input.Title
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "url",
                    (input.Url
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TrackedTime type
[<AutoOpen>]
module TrackedTimeJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TrackedTime with

        /// Serialize to a JSON node
        static member toJsonNode (input : TrackedTime) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "created",
                    (input.Created
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issue",
                    (input.Issue
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Issue.toJsonNode field
                     ))
                )

                node.Add (
                    "issueId",
                    (input.IssueId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "time",
                    (input.Time
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "userId",
                    (input.UserId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "userName",
                    (input.UserName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the Branch type
[<AutoOpen>]
module BranchJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type Branch with

        /// Serialize to a JSON node
        static member toJsonNode (input : Branch) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "commit",
                    (input.Commit
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> PayloadCommit.toJsonNode field
                     ))
                )

                node.Add (
                    "effectiveBranchProtectionName",
                    (input.EffectiveBranchProtectionName
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "enableStatusCheck",
                    (input.EnableStatusCheck
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "name",
                    (input.Name
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "protected",
                    (input.Protected
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "requiredApprovals",
                    (input.RequiredApprovals
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "statusCheckContexts",
                    (input.StatusCheckContexts
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             ((fun field ->
                                 let arr = System.Text.Json.Nodes.JsonArray ()

                                 for mem in field do
                                     arr.Add (System.Text.Json.Nodes.JsonValue.Create<string> mem)

                                 arr
                             )
                                 field)
                             :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "userCanMerge",
                    (input.UserCanMerge
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "userCanPush",
                    (input.UserCanPush
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the TimelineComment type
[<AutoOpen>]
module TimelineCommentJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type TimelineComment with

        /// Serialize to a JSON node
        static member toJsonNode (input : TimelineComment) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, id value)

                node.Add (
                    "assignee",
                    (input.Assignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "assigneeTeam",
                    (input.AssigneeTeam
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Team.toJsonNode field
                     ))
                )

                node.Add (
                    "body",
                    (input.Body
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "createdAt",
                    (input.CreatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "dependentIssue",
                    (input.DependentIssue
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Issue.toJsonNode field
                     ))
                )

                node.Add (
                    "htmlUrl",
                    (input.HtmlUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "id",
                    (input.Id
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "issueUrl",
                    (input.IssueUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "label",
                    (input.Label
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Label.toJsonNode field
                     ))
                )

                node.Add (
                    "milestone",
                    (input.Milestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "newRef",
                    (input.NewRef
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "newTitle",
                    (input.NewTitle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "oldMilestone",
                    (input.OldMilestone
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Milestone.toJsonNode field
                     ))
                )

                node.Add (
                    "oldProjectId",
                    (input.OldProjectId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "oldRef",
                    (input.OldRef
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "oldTitle",
                    (input.OldTitle
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "projectId",
                    (input.ProjectId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "pullRequestUrl",
                    (input.PullRequestUrl
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "refAction",
                    (input.RefAction
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "refComment",
                    (input.RefComment
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Comment.toJsonNode field
                     ))
                )

                node.Add (
                    "refCommitSha",
                    (input.RefCommitSha
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "refIssue",
                    (input.RefIssue
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> Issue.toJsonNode field
                     ))
                )

                node.Add (
                    "removedAssignee",
                    (input.RemovedAssignee
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<bool> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "resolveDoer",
                    (input.ResolveDoer
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

                node.Add (
                    "reviewId",
                    (input.ReviewId
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<int> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "trackedTime",
                    (input.TrackedTime
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> TrackedTime.toJsonNode field
                     ))
                )

                node.Add (
                    "updatedAt",
                    (input.UpdatedAt
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field ->
                             (System.Text.Json.Nodes.JsonValue.Create<string> field) :> System.Text.Json.Nodes.JsonNode
                     ))
                )

                node.Add (
                    "user",
                    (input.User
                     |> (fun field ->
                         match field with
                         | None -> null :> System.Text.Json.Nodes.JsonNode
                         | Some field -> User.toJsonNode field
                     ))
                )

            node :> _
namespace Gitea

open WoofWare.Myriad.Plugins

/// Module containing JSON serializing extension members for the LanguageStatistics type
[<AutoOpen>]
module LanguageStatisticsJsonSerializeExtension =
    /// Extension methods for JSON parsing
    type LanguageStatistics with

        /// Serialize to a JSON node
        static member toJsonNode (input : LanguageStatistics) : System.Text.Json.Nodes.JsonNode =
            let node = System.Text.Json.Nodes.JsonObject ()

            do
                for KeyValue (key, value) in input.AdditionalProperties do
                    node.Add (key, System.Text.Json.Nodes.JsonValue.Create<int> value)

            node :> _

namespace Gitea

/// Module containing JSON parsing extension members for the APIError type
[<AutoOpen>]
module APIErrorJsonParseExtension =
    /// Extension methods for JSON parsing
    type APIError with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : APIError =
            let arg_2 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                Url = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AccessToken type
[<AutoOpen>]
module AccessTokenJsonParseExtension =
    /// Extension methods for JSON parsing
    type AccessToken with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AccessToken =
            let arg_5 =
                match node.["tokenLastEight"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["sha1"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["scopes"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "id"
                        || key = "name"
                        || key = "scopes"
                        || key = "sha1"
                        || key = "tokenLastEight"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Id = arg_1
                Name = arg_2
                Scopes = arg_3
                Sha1 = arg_4
                TokenLastEight = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ActivityPub type
[<AutoOpen>]
module ActivityPubJsonParseExtension =
    /// Extension methods for JSON parsing
    type ActivityPub with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ActivityPub =
            let arg_1 =
                match node.["context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "context" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AddCollaboratorOption type
[<AutoOpen>]
module AddCollaboratorOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type AddCollaboratorOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AddCollaboratorOption =
            let arg_1 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "permission" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Permission = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AddTimeOption type
[<AutoOpen>]
module AddTimeOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type AddTimeOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AddTimeOption =
            let arg_3 =
                match node.["userName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                (match node.["time"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("time")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.Int32> ()

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "created" || key = "time" || key = "userName" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Time = arg_2
                UserName = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AnnotatedTagObject type
[<AutoOpen>]
module AnnotatedTagObjectJsonParseExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTagObject with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AnnotatedTagObject =
            let arg_2 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "sha" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Sha = arg_1
                Url = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Attachment type
[<AutoOpen>]
module AttachmentJsonParseExtension =
    /// Extension methods for JSON parsing
    type Attachment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Attachment =
            let arg_7 =
                match node.["uuid"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["downloadCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["browserDownloadUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "browserDownloadUrl"
                        || key = "createdAt"
                        || key = "downloadCount"
                        || key = "id"
                        || key = "name"
                        || key = "size"
                        || key = "uuid"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                BrowserDownloadUrl = arg_1
                CreatedAt = arg_2
                DownloadCount = arg_3
                Id = arg_4
                Name = arg_5
                Size = arg_6
                Uuid = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the BranchProtection type
[<AutoOpen>]
module BranchProtectionJsonParseExtension =
    /// Extension methods for JSON parsing
    type BranchProtection with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : BranchProtection =
            let arg_25 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_24 =
                match node.["unprotectedFilePatterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_23 =
                match node.["statusCheckContexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_22 =
                match node.["ruleName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_21 =
                match node.["requiredApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_20 =
                match node.["requireSignedCommits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_19 =
                match node.["pushWhitelistUsernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_18 =
                match node.["pushWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_17 =
                match node.["pushWhitelistDeployKeys"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_16 =
                match node.["protectedFilePatterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                match node.["mergeWhitelistUsernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_14 =
                match node.["mergeWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_13 =
                match node.["enableStatusCheck"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_12 =
                match node.["enablePushWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["enablePush"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["enableMergeWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["enableApprovalsWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["dismissStaleApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["branchName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["blockOnRejectedReviews"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["blockOnOutdatedBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["blockOnOfficialReviewRequests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["approvalsWhitelistUsername"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["approvalsWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "approvalsWhitelistTeams"
                        || key = "approvalsWhitelistUsername"
                        || key = "blockOnOfficialReviewRequests"
                        || key = "blockOnOutdatedBranch"
                        || key = "blockOnRejectedReviews"
                        || key = "branchName"
                        || key = "createdAt"
                        || key = "dismissStaleApprovals"
                        || key = "enableApprovalsWhitelist"
                        || key = "enableMergeWhitelist"
                        || key = "enablePush"
                        || key = "enablePushWhitelist"
                        || key = "enableStatusCheck"
                        || key = "mergeWhitelistTeams"
                        || key = "mergeWhitelistUsernames"
                        || key = "protectedFilePatterns"
                        || key = "pushWhitelistDeployKeys"
                        || key = "pushWhitelistTeams"
                        || key = "pushWhitelistUsernames"
                        || key = "requireSignedCommits"
                        || key = "requiredApprovals"
                        || key = "ruleName"
                        || key = "statusCheckContexts"
                        || key = "unprotectedFilePatterns"
                        || key = "updatedAt"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ApprovalsWhitelistTeams = arg_1
                ApprovalsWhitelistUsername = arg_2
                BlockOnOfficialReviewRequests = arg_3
                BlockOnOutdatedBranch = arg_4
                BlockOnRejectedReviews = arg_5
                BranchName = arg_6
                CreatedAt = arg_7
                DismissStaleApprovals = arg_8
                EnableApprovalsWhitelist = arg_9
                EnableMergeWhitelist = arg_10
                EnablePush = arg_11
                EnablePushWhitelist = arg_12
                EnableStatusCheck = arg_13
                MergeWhitelistTeams = arg_14
                MergeWhitelistUsernames = arg_15
                ProtectedFilePatterns = arg_16
                PushWhitelistDeployKeys = arg_17
                PushWhitelistTeams = arg_18
                PushWhitelistUsernames = arg_19
                RequireSignedCommits = arg_20
                RequiredApprovals = arg_21
                RuleName = arg_22
                StatusCheckContexts = arg_23
                UnprotectedFilePatterns = arg_24
                UpdatedAt = arg_25
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ChangedFile type
[<AutoOpen>]
module ChangedFileJsonParseExtension =
    /// Extension methods for JSON parsing
    type ChangedFile with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ChangedFile =
            let arg_9 =
                match node.["status"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["rawUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["previousFilename"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["filename"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["deletions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["contentsUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["changes"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["additions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "additions"
                        || key = "changes"
                        || key = "contentsUrl"
                        || key = "deletions"
                        || key = "filename"
                        || key = "htmlUrl"
                        || key = "previousFilename"
                        || key = "rawUrl"
                        || key = "status"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Additions = arg_1
                Changes = arg_2
                ContentsUrl = arg_3
                Deletions = arg_4
                Filename = arg_5
                HtmlUrl = arg_6
                PreviousFilename = arg_7
                RawUrl = arg_8
                Status = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitAffectedFiles type
[<AutoOpen>]
module CommitAffectedFilesJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitAffectedFiles with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitAffectedFiles =
            let arg_1 =
                match node.["filename"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "filename" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Filename = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitDateOptions type
[<AutoOpen>]
module CommitDateOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitDateOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitDateOptions =
            let arg_2 =
                match node.["committer"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "author" || key = "committer" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Committer = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitMeta type
[<AutoOpen>]
module CommitMetaJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitMeta with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitMeta =
            let arg_3 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "created" || key = "sha" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Sha = arg_2
                Url = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitStats type
[<AutoOpen>]
module CommitStatsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitStats with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitStats =
            let arg_3 =
                match node.["total"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["deletions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["additions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "additions" || key = "deletions" || key = "total" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Additions = arg_1
                Deletions = arg_2
                Total = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitUser type
[<AutoOpen>]
module CommitUserJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitUser with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitUser =
            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["date"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "date" || key = "email" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Date = arg_1
                Email = arg_2
                Name = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateAccessTokenOption type
[<AutoOpen>]
module CreateAccessTokenOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateAccessTokenOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateAccessTokenOption =
            let arg_2 =
                match node.["scopes"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "name" || key = "scopes" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Name = arg_1
                Scopes = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateBranchProtectionOption type
[<AutoOpen>]
module CreateBranchProtectionOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateBranchProtectionOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateBranchProtectionOption =
            let arg_23 =
                match node.["unprotectedFilePatterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_22 =
                match node.["statusCheckContexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_21 =
                match node.["ruleName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["requiredApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_19 =
                match node.["requireSignedCommits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["pushWhitelistUsernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_17 =
                match node.["pushWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_16 =
                match node.["pushWhitelistDeployKeys"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_15 =
                match node.["protectedFilePatterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["mergeWhitelistUsernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_13 =
                match node.["mergeWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_12 =
                match node.["enableStatusCheck"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["enablePushWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["enablePush"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["enableMergeWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["enableApprovalsWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["dismissStaleApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["branchName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["blockOnRejectedReviews"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["blockOnOutdatedBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["blockOnOfficialReviewRequests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["approvalsWhitelistUsername"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["approvalsWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "approvalsWhitelistTeams"
                        || key = "approvalsWhitelistUsername"
                        || key = "blockOnOfficialReviewRequests"
                        || key = "blockOnOutdatedBranch"
                        || key = "blockOnRejectedReviews"
                        || key = "branchName"
                        || key = "dismissStaleApprovals"
                        || key = "enableApprovalsWhitelist"
                        || key = "enableMergeWhitelist"
                        || key = "enablePush"
                        || key = "enablePushWhitelist"
                        || key = "enableStatusCheck"
                        || key = "mergeWhitelistTeams"
                        || key = "mergeWhitelistUsernames"
                        || key = "protectedFilePatterns"
                        || key = "pushWhitelistDeployKeys"
                        || key = "pushWhitelistTeams"
                        || key = "pushWhitelistUsernames"
                        || key = "requireSignedCommits"
                        || key = "requiredApprovals"
                        || key = "ruleName"
                        || key = "statusCheckContexts"
                        || key = "unprotectedFilePatterns"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ApprovalsWhitelistTeams = arg_1
                ApprovalsWhitelistUsername = arg_2
                BlockOnOfficialReviewRequests = arg_3
                BlockOnOutdatedBranch = arg_4
                BlockOnRejectedReviews = arg_5
                BranchName = arg_6
                DismissStaleApprovals = arg_7
                EnableApprovalsWhitelist = arg_8
                EnableMergeWhitelist = arg_9
                EnablePush = arg_10
                EnablePushWhitelist = arg_11
                EnableStatusCheck = arg_12
                MergeWhitelistTeams = arg_13
                MergeWhitelistUsernames = arg_14
                ProtectedFilePatterns = arg_15
                PushWhitelistDeployKeys = arg_16
                PushWhitelistTeams = arg_17
                PushWhitelistUsernames = arg_18
                RequireSignedCommits = arg_19
                RequiredApprovals = arg_20
                RuleName = arg_21
                StatusCheckContexts = arg_22
                UnprotectedFilePatterns = arg_23
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateBranchRepoOption type
[<AutoOpen>]
module CreateBranchRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateBranchRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateBranchRepoOption =
            let arg_2 =
                match node.["oldBranchName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["newBranchName"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("newBranchName")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "newBranchName" || key = "oldBranchName" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                NewBranchName = arg_1
                OldBranchName = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateEmailOption type
[<AutoOpen>]
module CreateEmailOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateEmailOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateEmailOption =
            let arg_1 =
                match node.["emails"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "emails" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Emails = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateForkOption type
[<AutoOpen>]
module CreateForkOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateForkOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateForkOption =
            let arg_2 =
                match node.["organization"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "name" || key = "organization" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Name = arg_1
                Organization = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateGPGKeyOption type
[<AutoOpen>]
module CreateGPGKeyOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateGPGKeyOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateGPGKeyOption =
            let arg_2 =
                match node.["armoredSignature"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["armoredPublicKey"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("armoredPublicKey")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "armoredPublicKey" || key = "armoredSignature" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ArmoredPublicKey = arg_1
                ArmoredSignature = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateHookOptionConfig type
[<AutoOpen>]
module CreateHookOptionConfigJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateHookOptionConfig with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateHookOptionConfig =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateIssueCommentOption type
[<AutoOpen>]
module CreateIssueCommentOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateIssueCommentOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateIssueCommentOption =
            let arg_1 =
                (match node.["body"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("body")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateIssueOption type
[<AutoOpen>]
module CreateIssueOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateIssueOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateIssueOption =
            let arg_9 =
                (match node.["title"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("title")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_8 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["closed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignees"
                        || key = "body"
                        || key = "closed"
                        || key = "dueDate"
                        || key = "labels"
                        || key = "milestone"
                        || key = "ref"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                Assignees = arg_2
                Body = arg_3
                Closed = arg_4
                DueDate = arg_5
                Labels = arg_6
                Milestone = arg_7
                Ref = arg_8
                Title = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateKeyOption type
[<AutoOpen>]
module CreateKeyOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateKeyOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateKeyOption =
            let arg_3 =
                (match node.["title"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("title")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_2 =
                match node.["readOnly"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                (match node.["key"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("key")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "key" || key = "readOnly" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Key = arg_1
                ReadOnly = arg_2
                Title = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateLabelOption type
[<AutoOpen>]
module CreateLabelOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateLabelOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateLabelOption =
            let arg_3 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_2 =
                match node.["exclusive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                (match node.["color"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("color")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "color" || key = "exclusive" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Color = arg_1
                Exclusive = arg_2
                Name = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateMilestoneOption type
[<AutoOpen>]
module CreateMilestoneOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateMilestoneOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateMilestoneOption =
            let arg_3 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["dueOn"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "dueOn" || key = "state" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DueOn = arg_1
                State = arg_2
                Title = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateOAuth2ApplicationOptions type
[<AutoOpen>]
module CreateOAuth2ApplicationOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateOAuth2ApplicationOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateOAuth2ApplicationOptions =
            let arg_3 =
                match node.["redirectUris"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["confidentialClient"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "confidentialClient" || key = "name" || key = "redirectUris" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ConfidentialClient = arg_1
                Name = arg_2
                RedirectUris = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateOrgOption type
[<AutoOpen>]
module CreateOrgOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateOrgOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateOrgOption =
            let arg_6 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                (match node.["username"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("username")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["repoAdminChangeTeamAccess"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "fullName"
                        || key = "location"
                        || key = "repoAdminChangeTeamAccess"
                        || key = "username"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                FullName = arg_1
                Location = arg_2
                RepoAdminChangeTeamAccess = arg_3
                Username = arg_4
                Visibility = arg_5
                Website = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePullRequestOption type
[<AutoOpen>]
module CreatePullRequestOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePullRequestOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePullRequestOption =
            let arg_9 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["head"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["base"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignees"
                        || key = "base"
                        || key = "body"
                        || key = "dueDate"
                        || key = "head"
                        || key = "labels"
                        || key = "milestone"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                Assignees = arg_2
                Base = arg_3
                Body = arg_4
                DueDate = arg_5
                Head = arg_6
                Labels = arg_7
                Milestone = arg_8
                Title = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePullReviewComment type
[<AutoOpen>]
module CreatePullReviewCommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewComment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePullReviewComment =
            let arg_4 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["oldPosition"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["newPosition"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" || key = "newPosition" || key = "oldPosition" || key = "path" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                NewPosition = arg_2
                OldPosition = arg_3
                Path = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePushMirrorOption type
[<AutoOpen>]
module CreatePushMirrorOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePushMirrorOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePushMirrorOption =
            let arg_5 =
                match node.["syncOnCommit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["remoteUsername"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["remotePassword"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["remoteAddress"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "interval"
                        || key = "remoteAddress"
                        || key = "remotePassword"
                        || key = "remoteUsername"
                        || key = "syncOnCommit"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Interval = arg_1
                RemoteAddress = arg_2
                RemotePassword = arg_3
                RemoteUsername = arg_4
                SyncOnCommit = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateReleaseOption type
[<AutoOpen>]
module CreateReleaseOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateReleaseOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateReleaseOption =
            let arg_6 =
                match node.["targetCommitish"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                (match node.["tagName"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("tagName")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_4 =
                match node.["prerelease"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["draft"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "draft"
                        || key = "name"
                        || key = "prerelease"
                        || key = "tagName"
                        || key = "targetCommitish"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Draft = arg_2
                Name = arg_3
                Prerelease = arg_4
                TagName = arg_5
                TargetCommitish = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateRepoOption type
[<AutoOpen>]
module CreateRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateRepoOption =
            let arg_10 =
                match node.["trustModel"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["template"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["readme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_5 =
                match node.["license"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["issueLabels"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["gitignores"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["defaultBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["autoInit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "autoInit"
                        || key = "defaultBranch"
                        || key = "gitignores"
                        || key = "issueLabels"
                        || key = "license"
                        || key = "name"
                        || key = "private"
                        || key = "readme"
                        || key = "template"
                        || key = "trustModel"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AutoInit = arg_1
                DefaultBranch = arg_2
                Gitignores = arg_3
                IssueLabels = arg_4
                License = arg_5
                Name = arg_6
                Private = arg_7
                Readme = arg_8
                Template = arg_9
                TrustModel = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateStatusOption type
[<AutoOpen>]
module CreateStatusOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateStatusOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateStatusOption =
            let arg_3 =
                match node.["targetUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "context" || key = "state" || key = "targetUrl" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
                State = arg_2
                TargetUrl = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateTagOption type
[<AutoOpen>]
module CreateTagOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateTagOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateTagOption =
            let arg_3 =
                match node.["target"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                (match node.["tagName"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("tagName")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" || key = "tagName" || key = "target" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                TagName = arg_2
                Target = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type1 type
[<AutoOpen>]
module Type1JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type1 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type1 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateTeamOption type
[<AutoOpen>]
module CreateTeamOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateTeamOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateTeamOption =
            let arg_6 =
                match node.["unitsMap"] with
                | null -> None
                | v -> Type1.jsonParse v |> Some

            let arg_5 =
                match node.["units"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_2 =
                match node.["includesAllRepositories"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["canCreateOrgRepo"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "canCreateOrgRepo"
                        || key = "includesAllRepositories"
                        || key = "name"
                        || key = "permission"
                        || key = "units"
                        || key = "unitsMap"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateOrgRepo = arg_1
                IncludesAllRepositories = arg_2
                Name = arg_3
                Permission = arg_4
                Units = arg_5
                UnitsMap = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateUserOption type
[<AutoOpen>]
module CreateUserOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateUserOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateUserOption =
            let arg_11 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                (match node.["username"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("username")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_9 =
                match node.["sourceId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_8 =
                match node.["sendNotify"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["restricted"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                (match node.["password"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("password")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_5 =
                match node.["mustChangePassword"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["loginName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                (match node.["email"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("email")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_1 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "createdAt"
                        || key = "email"
                        || key = "fullName"
                        || key = "loginName"
                        || key = "mustChangePassword"
                        || key = "password"
                        || key = "restricted"
                        || key = "sendNotify"
                        || key = "sourceId"
                        || key = "username"
                        || key = "visibility"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Email = arg_2
                FullName = arg_3
                LoginName = arg_4
                MustChangePassword = arg_5
                Password = arg_6
                Restricted = arg_7
                SendNotify = arg_8
                SourceId = arg_9
                Username = arg_10
                Visibility = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateWikiPageOptions type
[<AutoOpen>]
module CreateWikiPageOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateWikiPageOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateWikiPageOptions =
            let arg_3 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["contentBase64"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "contentBase64" || key = "message" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ContentBase64 = arg_1
                Message = arg_2
                Title = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Cron type
[<AutoOpen>]
module CronJsonParseExtension =
    /// Extension methods for JSON parsing
    type Cron with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Cron =
            let arg_5 =
                match node.["schedule"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["prev"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["next"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["execTimes"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "execTimes"
                        || key = "name"
                        || key = "next"
                        || key = "prev"
                        || key = "schedule"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ExecTimes = arg_1
                Name = arg_2
                Next = arg_3
                Prev = arg_4
                Schedule = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DeleteEmailOption type
[<AutoOpen>]
module DeleteEmailOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type DeleteEmailOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DeleteEmailOption =
            let arg_1 =
                match node.["emails"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "emails" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Emails = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DismissPullReviewOptions type
[<AutoOpen>]
module DismissPullReviewOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type DismissPullReviewOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DismissPullReviewOptions =
            let arg_2 =
                match node.["priors"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "message" || key = "priors" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                Priors = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditAttachmentOptions type
[<AutoOpen>]
module EditAttachmentOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditAttachmentOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditAttachmentOptions =
            let arg_1 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "name" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Name = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditBranchProtectionOption type
[<AutoOpen>]
module EditBranchProtectionOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditBranchProtectionOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditBranchProtectionOption =
            let arg_21 =
                match node.["unprotectedFilePatterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["statusCheckContexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_19 =
                match node.["requiredApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_18 =
                match node.["requireSignedCommits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["pushWhitelistUsernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_16 =
                match node.["pushWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_15 =
                match node.["pushWhitelistDeployKeys"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_14 =
                match node.["protectedFilePatterns"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["mergeWhitelistUsernames"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_12 =
                match node.["mergeWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_11 =
                match node.["enableStatusCheck"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["enablePushWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["enablePush"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["enableMergeWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["enableApprovalsWhitelist"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["dismissStaleApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["blockOnRejectedReviews"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["blockOnOutdatedBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["blockOnOfficialReviewRequests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["approvalsWhitelistUsername"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["approvalsWhitelistTeams"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "approvalsWhitelistTeams"
                        || key = "approvalsWhitelistUsername"
                        || key = "blockOnOfficialReviewRequests"
                        || key = "blockOnOutdatedBranch"
                        || key = "blockOnRejectedReviews"
                        || key = "dismissStaleApprovals"
                        || key = "enableApprovalsWhitelist"
                        || key = "enableMergeWhitelist"
                        || key = "enablePush"
                        || key = "enablePushWhitelist"
                        || key = "enableStatusCheck"
                        || key = "mergeWhitelistTeams"
                        || key = "mergeWhitelistUsernames"
                        || key = "protectedFilePatterns"
                        || key = "pushWhitelistDeployKeys"
                        || key = "pushWhitelistTeams"
                        || key = "pushWhitelistUsernames"
                        || key = "requireSignedCommits"
                        || key = "requiredApprovals"
                        || key = "statusCheckContexts"
                        || key = "unprotectedFilePatterns"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ApprovalsWhitelistTeams = arg_1
                ApprovalsWhitelistUsername = arg_2
                BlockOnOfficialReviewRequests = arg_3
                BlockOnOutdatedBranch = arg_4
                BlockOnRejectedReviews = arg_5
                DismissStaleApprovals = arg_6
                EnableApprovalsWhitelist = arg_7
                EnableMergeWhitelist = arg_8
                EnablePush = arg_9
                EnablePushWhitelist = arg_10
                EnableStatusCheck = arg_11
                MergeWhitelistTeams = arg_12
                MergeWhitelistUsernames = arg_13
                ProtectedFilePatterns = arg_14
                PushWhitelistDeployKeys = arg_15
                PushWhitelistTeams = arg_16
                PushWhitelistUsernames = arg_17
                RequireSignedCommits = arg_18
                RequiredApprovals = arg_19
                StatusCheckContexts = arg_20
                UnprotectedFilePatterns = arg_21
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditDeadlineOption type
[<AutoOpen>]
module EditDeadlineOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditDeadlineOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditDeadlineOption =
            let arg_1 =
                (match node.["dueDate"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("dueDate")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "dueDate" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DueDate = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditGitHookOption type
[<AutoOpen>]
module EditGitHookOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditGitHookOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditGitHookOption =
            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type2 type
[<AutoOpen>]
module Type2JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type2 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type2 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditHookOption type
[<AutoOpen>]
module EditHookOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditHookOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditHookOption =
            let arg_5 =
                match node.["events"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["config"] with
                | null -> None
                | v -> Type2.jsonParse v |> Some

            let arg_3 =
                match node.["branchFilter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["authorizationHeader"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "authorizationHeader"
                        || key = "branchFilter"
                        || key = "config"
                        || key = "events"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AuthorizationHeader = arg_2
                BranchFilter = arg_3
                Config = arg_4
                Events = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditIssueCommentOption type
[<AutoOpen>]
module EditIssueCommentOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditIssueCommentOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditIssueCommentOption =
            let arg_1 =
                (match node.["body"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("body")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditIssueOption type
[<AutoOpen>]
module EditIssueOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditIssueOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditIssueOption =
            let arg_9 =
                match node.["unsetDueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assignees"
                        || key = "body"
                        || key = "dueDate"
                        || key = "milestone"
                        || key = "ref"
                        || key = "state"
                        || key = "title"
                        || key = "unsetDueDate"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                Assignees = arg_2
                Body = arg_3
                DueDate = arg_4
                Milestone = arg_5
                Ref = arg_6
                State = arg_7
                Title = arg_8
                UnsetDueDate = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditLabelOption type
[<AutoOpen>]
module EditLabelOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditLabelOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditLabelOption =
            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["exclusive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["color"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "color" || key = "exclusive" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Color = arg_1
                Exclusive = arg_2
                Name = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditMilestoneOption type
[<AutoOpen>]
module EditMilestoneOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditMilestoneOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditMilestoneOption =
            let arg_3 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["dueOn"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "dueOn" || key = "state" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DueOn = arg_1
                State = arg_2
                Title = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditOrgOption type
[<AutoOpen>]
module EditOrgOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditOrgOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditOrgOption =
            let arg_5 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["repoAdminChangeTeamAccess"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "fullName"
                        || key = "location"
                        || key = "repoAdminChangeTeamAccess"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                FullName = arg_1
                Location = arg_2
                RepoAdminChangeTeamAccess = arg_3
                Visibility = arg_4
                Website = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditPullRequestOption type
[<AutoOpen>]
module EditPullRequestOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditPullRequestOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditPullRequestOption =
            let arg_11 =
                match node.["unsetDueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["milestone"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["base"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["assignees"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["assignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["allowMaintainerEdit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allowMaintainerEdit"
                        || key = "assignee"
                        || key = "assignees"
                        || key = "base"
                        || key = "body"
                        || key = "dueDate"
                        || key = "labels"
                        || key = "milestone"
                        || key = "state"
                        || key = "title"
                        || key = "unsetDueDate"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowMaintainerEdit = arg_1
                Assignee = arg_2
                Assignees = arg_3
                Base = arg_4
                Body = arg_5
                DueDate = arg_6
                Labels = arg_7
                Milestone = arg_8
                State = arg_9
                Title = arg_10
                UnsetDueDate = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditReactionOption type
[<AutoOpen>]
module EditReactionOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditReactionOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditReactionOption =
            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditReleaseOption type
[<AutoOpen>]
module EditReleaseOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditReleaseOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditReleaseOption =
            let arg_6 =
                match node.["targetCommitish"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["tagName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["prerelease"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["draft"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "draft"
                        || key = "name"
                        || key = "prerelease"
                        || key = "tagName"
                        || key = "targetCommitish"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Draft = arg_2
                Name = arg_3
                Prerelease = arg_4
                TagName = arg_5
                TargetCommitish = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type3 type
[<AutoOpen>]
module Type3JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type3 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type3 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditTeamOption type
[<AutoOpen>]
module EditTeamOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditTeamOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditTeamOption =
            let arg_6 =
                match node.["unitsMap"] with
                | null -> None
                | v -> Type3.jsonParse v |> Some

            let arg_5 =
                match node.["units"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_2 =
                match node.["includesAllRepositories"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["canCreateOrgRepo"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "canCreateOrgRepo"
                        || key = "includesAllRepositories"
                        || key = "name"
                        || key = "permission"
                        || key = "units"
                        || key = "unitsMap"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateOrgRepo = arg_1
                IncludesAllRepositories = arg_2
                Name = arg_3
                Permission = arg_4
                Units = arg_5
                UnitsMap = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditUserOption type
[<AutoOpen>]
module EditUserOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditUserOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditUserOption =
            let arg_17 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_16 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                (match node.["sourceId"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("sourceId")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.Int32> ()

            let arg_14 =
                match node.["restricted"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["prohibitLogin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_12 =
                match node.["password"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["mustChangePassword"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["maxRepoCreation"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_9 =
                (match node.["loginName"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("loginName")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_8 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["allowImportLocal"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["allowGitHook"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["allowCreateOrganization"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["admin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "admin"
                        || key = "allowCreateOrganization"
                        || key = "allowGitHook"
                        || key = "allowImportLocal"
                        || key = "email"
                        || key = "fullName"
                        || key = "location"
                        || key = "loginName"
                        || key = "maxRepoCreation"
                        || key = "mustChangePassword"
                        || key = "password"
                        || key = "prohibitLogin"
                        || key = "restricted"
                        || key = "sourceId"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                Admin = arg_2
                AllowCreateOrganization = arg_3
                AllowGitHook = arg_4
                AllowImportLocal = arg_5
                Email = arg_6
                FullName = arg_7
                Location = arg_8
                LoginName = arg_9
                MaxRepoCreation = arg_10
                MustChangePassword = arg_11
                Password = arg_12
                ProhibitLogin = arg_13
                Restricted = arg_14
                SourceId = arg_15
                Visibility = arg_16
                Website = arg_17
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Email type
[<AutoOpen>]
module EmailJsonParseExtension =
    /// Extension methods for JSON parsing
    type Email with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Email =
            let arg_3 =
                match node.["verified"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["primary"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "primary" || key = "verified" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Primary = arg_2
                Verified = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ExternalTracker type
[<AutoOpen>]
module ExternalTrackerJsonParseExtension =
    /// Extension methods for JSON parsing
    type ExternalTracker with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ExternalTracker =
            let arg_4 =
                match node.["externalTrackerUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["externalTrackerStyle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["externalTrackerRegexpPattern"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["externalTrackerFormat"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "externalTrackerFormat"
                        || key = "externalTrackerRegexpPattern"
                        || key = "externalTrackerStyle"
                        || key = "externalTrackerUrl"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ExternalTrackerFormat = arg_1
                ExternalTrackerRegexpPattern = arg_2
                ExternalTrackerStyle = arg_3
                ExternalTrackerUrl = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ExternalWiki type
[<AutoOpen>]
module ExternalWikiJsonParseExtension =
    /// Extension methods for JSON parsing
    type ExternalWiki with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ExternalWiki =
            let arg_1 =
                match node.["externalWikiUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "externalWikiUrl" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ExternalWikiUrl = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileCommitResponse type
[<AutoOpen>]
module FileCommitResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileCommitResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileCommitResponse =
            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["tree"] with
                | null -> None
                | v -> CommitMeta.jsonParse v |> Some

            let arg_7 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["parents"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitMeta.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["committer"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "committer"
                        || key = "created"
                        || key = "htmlUrl"
                        || key = "message"
                        || key = "parents"
                        || key = "sha"
                        || key = "tree"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Committer = arg_2
                Created = arg_3
                HtmlUrl = arg_4
                Message = arg_5
                Parents = arg_6
                Sha = arg_7
                Tree = arg_8
                Url = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileLinksResponse type
[<AutoOpen>]
module FileLinksResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileLinksResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileLinksResponse =
            let arg_3 =
                match node.["self"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["html"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["git"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "git" || key = "html" || key = "self" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Git = arg_1
                Html = arg_2
                Self = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GPGKeyEmail type
[<AutoOpen>]
module GPGKeyEmailJsonParseExtension =
    /// Extension methods for JSON parsing
    type GPGKeyEmail with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GPGKeyEmail =
            let arg_2 =
                match node.["verified"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "verified" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Verified = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralAPISettings type
[<AutoOpen>]
module GeneralAPISettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralAPISettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralAPISettings =
            let arg_4 =
                match node.["maxResponseItems"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["defaultPagingNum"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["defaultMaxBlobSize"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["defaultGitTreesPerPage"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "defaultGitTreesPerPage"
                        || key = "defaultMaxBlobSize"
                        || key = "defaultPagingNum"
                        || key = "maxResponseItems"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DefaultGitTreesPerPage = arg_1
                DefaultMaxBlobSize = arg_2
                DefaultPagingNum = arg_3
                MaxResponseItems = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralAttachmentSettings type
[<AutoOpen>]
module GeneralAttachmentSettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralAttachmentSettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralAttachmentSettings =
            let arg_4 =
                match node.["maxSize"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["maxFiles"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["enabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allowedTypes"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "allowedTypes" || key = "enabled" || key = "maxFiles" || key = "maxSize" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowedTypes = arg_1
                Enabled = arg_2
                MaxFiles = arg_3
                MaxSize = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralRepoSettings type
[<AutoOpen>]
module GeneralRepoSettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralRepoSettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralRepoSettings =
            let arg_6 =
                match node.["timeTrackingDisabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["starsDisabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["mirrorsDisabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["migrationsDisabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["lfsDisabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["httpGitDisabled"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "httpGitDisabled"
                        || key = "lfsDisabled"
                        || key = "migrationsDisabled"
                        || key = "mirrorsDisabled"
                        || key = "starsDisabled"
                        || key = "timeTrackingDisabled"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                HttpGitDisabled = arg_1
                LfsDisabled = arg_2
                MigrationsDisabled = arg_3
                MirrorsDisabled = arg_4
                StarsDisabled = arg_5
                TimeTrackingDisabled = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GeneralUISettings type
[<AutoOpen>]
module GeneralUISettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type GeneralUISettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GeneralUISettings =
            let arg_3 =
                match node.["defaultTheme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["customEmojis"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["allowedReactions"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "allowedReactions" || key = "customEmojis" || key = "defaultTheme" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowedReactions = arg_1
                CustomEmojis = arg_2
                DefaultTheme = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GenerateRepoOption type
[<AutoOpen>]
module GenerateRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type GenerateRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GenerateRepoOption =
            let arg_10 =
                match node.["webhooks"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["topics"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                (match node.["owner"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("owner")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_6 =
                (match node.["name"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("name")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_5 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["gitHooks"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["gitContent"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["defaultBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["avatar"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "avatar"
                        || key = "defaultBranch"
                        || key = "gitContent"
                        || key = "gitHooks"
                        || key = "labels"
                        || key = "name"
                        || key = "owner"
                        || key = "private"
                        || key = "topics"
                        || key = "webhooks"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Avatar = arg_1
                DefaultBranch = arg_2
                GitContent = arg_3
                GitHooks = arg_4
                Labels = arg_5
                Name = arg_6
                Owner = arg_7
                Private = arg_8
                Topics = arg_9
                Webhooks = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitBlobResponse type
[<AutoOpen>]
module GitBlobResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitBlobResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitBlobResponse =
            let arg_5 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["encoding"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "content"
                        || key = "encoding"
                        || key = "sha"
                        || key = "size"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
                Encoding = arg_2
                Sha = arg_3
                Size = arg_4
                Url = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitEntry type
[<AutoOpen>]
module GitEntryJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitEntry with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitEntry =
            let arg_5 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["mode"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "mode" || key = "path" || key = "sha" || key = "size" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Mode = arg_1
                Path = arg_2
                Sha = arg_3
                Size = arg_4
                Url = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitHook type
[<AutoOpen>]
module GitHookJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitHook with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitHook =
            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["isActive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" || key = "isActive" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
                IsActive = arg_2
                Name = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitObject type
[<AutoOpen>]
module GitObjectJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitObject with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitObject =
            let arg_2 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "sha" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Sha = arg_1
                Url = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the GitTreeResponse type
[<AutoOpen>]
module GitTreeResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type GitTreeResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : GitTreeResponse =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["truncated"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["tree"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> GitEntry.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_3 =
                match node.["totalCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["page"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "page"
                        || key = "sha"
                        || key = "totalCount"
                        || key = "tree"
                        || key = "truncated"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Page = arg_1
                Sha = arg_2
                TotalCount = arg_3
                Tree = arg_4
                Truncated = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type4 type
[<AutoOpen>]
module Type4JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type4 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type4 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Hook type
[<AutoOpen>]
module HookJsonParseExtension =
    /// Extension methods for JSON parsing
    type Hook with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Hook =
            let arg_7 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["events"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["config"] with
                | null -> None
                | v -> Type4.jsonParse v |> Some

            let arg_2 =
                match node.["authorizationHeader"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "authorizationHeader"
                        || key = "config"
                        || key = "createdAt"
                        || key = "events"
                        || key = "id"
                        || key = "updatedAt"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AuthorizationHeader = arg_2
                Config = arg_3
                CreatedAt = arg_4
                Events = arg_5
                Id = arg_6
                UpdatedAt = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Identity type
[<AutoOpen>]
module IdentityJsonParseExtension =
    /// Extension methods for JSON parsing
    type Identity with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Identity =
            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "name" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Name = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the InternalTracker type
[<AutoOpen>]
module InternalTrackerJsonParseExtension =
    /// Extension methods for JSON parsing
    type InternalTracker with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : InternalTracker =
            let arg_3 =
                match node.["enableTimeTracker"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["enableIssueDependencies"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allowOnlyContributorsToTrackTime"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allowOnlyContributorsToTrackTime"
                        || key = "enableIssueDependencies"
                        || key = "enableTimeTracker"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowOnlyContributorsToTrackTime = arg_1
                EnableIssueDependencies = arg_2
                EnableTimeTracker = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueDeadline type
[<AutoOpen>]
module IssueDeadlineJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueDeadline with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueDeadline =
            let arg_1 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "dueDate" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DueDate = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type5 type
[<AutoOpen>]
module Type5JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type5 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type5 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, unit> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then () else result.Add (key, ())

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type6 type
[<AutoOpen>]
module Type6JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type6 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type6 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, unit> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then () else result.Add (key, ())

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueFormField type
[<AutoOpen>]
module IssueFormFieldJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueFormField with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueFormField =
            let arg_3 =
                match node.["validations"] with
                | null -> None
                | v -> Type6.jsonParse v |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["attributes"] with
                | null -> None
                | v -> Type5.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "attributes" || key = "id" || key = "validations" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Attributes = arg_1
                Id = arg_2
                Validations = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueLabelsOption type
[<AutoOpen>]
module IssueLabelsOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueLabelsOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueLabelsOption =
            let arg_1 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "labels" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Labels = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Label type
[<AutoOpen>]
module LabelJsonParseExtension =
    /// Extension methods for JSON parsing
    type Label with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Label =
            let arg_5 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["exclusive"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["color"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "color" || key = "exclusive" || key = "id" || key = "name" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Color = arg_1
                Exclusive = arg_2
                Id = arg_3
                Name = arg_4
                Url = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the MarkdownOption type
[<AutoOpen>]
module MarkdownOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type MarkdownOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : MarkdownOption =
            let arg_4 =
                match node.["wiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["text"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["mode"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "context" || key = "mode" || key = "text" || key = "wiki" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
                Mode = arg_2
                Text = arg_3
                Wiki = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the MergePullRequestOption type
[<AutoOpen>]
module MergePullRequestOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type MergePullRequestOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : MergePullRequestOption =
            let arg_8 =
                match node.["mergeWhenChecksSucceed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["headCommitId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["forceMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["deleteBranchAfterMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["mergeTitleField"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["mergeMessageField"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["mergeCommitID"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                (match node.["do"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("do")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "do"
                        || key = "mergeCommitID"
                        || key = "mergeMessageField"
                        || key = "mergeTitleField"
                        || key = "deleteBranchAfterMerge"
                        || key = "forceMerge"
                        || key = "headCommitId"
                        || key = "mergeWhenChecksSucceed"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Do = arg_1
                MergeCommitID = arg_2
                MergeMessageField = arg_3
                MergeTitleField = arg_4
                DeleteBranchAfterMerge = arg_5
                ForceMerge = arg_6
                HeadCommitId = arg_7
                MergeWhenChecksSucceed = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the MigrateRepoOptions type
[<AutoOpen>]
module MigrateRepoOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type MigrateRepoOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : MigrateRepoOptions =
            let arg_19 =
                match node.["wiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["uid"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_17 =
                match node.["service"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_16 =
                match node.["repoOwner"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                (match node.["repoName"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("repoName")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_14 =
                match node.["releases"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["pullRequests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_12 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["mirrorInterval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["mirror"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["milestones"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["lfsEndpoint"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["lfs"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["issues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                (match node.["cloneAddr"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("cloneAddr")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["authUsername"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["authToken"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["authPassword"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "authPassword"
                        || key = "authToken"
                        || key = "authUsername"
                        || key = "cloneAddr"
                        || key = "issues"
                        || key = "labels"
                        || key = "lfs"
                        || key = "lfsEndpoint"
                        || key = "milestones"
                        || key = "mirror"
                        || key = "mirrorInterval"
                        || key = "private"
                        || key = "pullRequests"
                        || key = "releases"
                        || key = "repoName"
                        || key = "repoOwner"
                        || key = "service"
                        || key = "uid"
                        || key = "wiki"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AuthPassword = arg_1
                AuthToken = arg_2
                AuthUsername = arg_3
                CloneAddr = arg_4
                Issues = arg_5
                Labels = arg_6
                Lfs = arg_7
                LfsEndpoint = arg_8
                Milestones = arg_9
                Mirror = arg_10
                MirrorInterval = arg_11
                Private = arg_12
                PullRequests = arg_13
                Releases = arg_14
                RepoName = arg_15
                RepoOwner = arg_16
                Service = arg_17
                Uid = arg_18
                Wiki = arg_19
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type7 type
[<AutoOpen>]
module Type7JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type7 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type7 =
            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoServices type
[<AutoOpen>]
module NodeInfoServicesJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoServices with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoServices =
            let arg_2 =
                match node.["outbound"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["inbound"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "inbound" || key = "outbound" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Inbound = arg_1
                Outbound = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoSoftware type
[<AutoOpen>]
module NodeInfoSoftwareJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoSoftware with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoSoftware =
            let arg_4 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["repository"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["homepage"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "homepage" || key = "name" || key = "repository" || key = "version" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Homepage = arg_1
                Name = arg_2
                Repository = arg_3
                Version = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoUsageUsers type
[<AutoOpen>]
module NodeInfoUsageUsersJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsageUsers with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoUsageUsers =
            let arg_3 =
                match node.["total"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["activeMonth"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["activeHalfyear"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "activeHalfyear" || key = "activeMonth" || key = "total" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ActiveHalfyear = arg_1
                ActiveMonth = arg_2
                Total = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NotificationCount type
[<AutoOpen>]
module NotificationCountJsonParseExtension =
    /// Extension methods for JSON parsing
    type NotificationCount with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NotificationCount =
            let arg_1 =
                match node.["new"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "new" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                New = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the OAuth2Application type
[<AutoOpen>]
module OAuth2ApplicationJsonParseExtension =
    /// Extension methods for JSON parsing
    type OAuth2Application with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : OAuth2Application =
            let arg_7 =
                match node.["redirectUris"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["confidentialClient"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["clientSecret"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["clientId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "clientId"
                        || key = "clientSecret"
                        || key = "confidentialClient"
                        || key = "created"
                        || key = "id"
                        || key = "name"
                        || key = "redirectUris"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ClientId = arg_1
                ClientSecret = arg_2
                ConfidentialClient = arg_3
                Created = arg_4
                Id = arg_5
                Name = arg_6
                RedirectUris = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Organization type
[<AutoOpen>]
module OrganizationJsonParseExtension =
    /// Extension methods for JSON parsing
    type Organization with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Organization =
            let arg_9 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["username"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["repoAdminChangeTeamAccess"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["avatarUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "avatarUrl"
                        || key = "fullName"
                        || key = "id"
                        || key = "location"
                        || key = "name"
                        || key = "repoAdminChangeTeamAccess"
                        || key = "username"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AvatarUrl = arg_1
                FullName = arg_2
                Id = arg_3
                Location = arg_4
                Name = arg_5
                RepoAdminChangeTeamAccess = arg_6
                Username = arg_7
                Visibility = arg_8
                Website = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the OrganizationPermissions type
[<AutoOpen>]
module OrganizationPermissionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type OrganizationPermissions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : OrganizationPermissions =
            let arg_5 =
                match node.["isOwner"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["isAdmin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["canWrite"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["canRead"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["canCreateRepository"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "canCreateRepository"
                        || key = "canRead"
                        || key = "canWrite"
                        || key = "isAdmin"
                        || key = "isOwner"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateRepository = arg_1
                CanRead = arg_2
                CanWrite = arg_3
                IsAdmin = arg_4
                IsOwner = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PackageFile type
[<AutoOpen>]
module PackageFileJsonParseExtension =
    /// Extension methods for JSON parsing
    type PackageFile with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PackageFile =
            let arg_7 =
                match node.["sha512"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["sha256"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["sha1"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["md5"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "size"
                        || key = "id"
                        || key = "md5"
                        || key = "name"
                        || key = "sha1"
                        || key = "sha256"
                        || key = "sha512"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Size = arg_1
                Id = arg_2
                Md5 = arg_3
                Name = arg_4
                Sha1 = arg_5
                Sha256 = arg_6
                Sha512 = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PayloadUser type
[<AutoOpen>]
module PayloadUserJsonParseExtension =
    /// Extension methods for JSON parsing
    type PayloadUser with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PayloadUser =
            let arg_3 =
                match node.["username"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "email" || key = "name" || key = "username" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Email = arg_1
                Name = arg_2
                Username = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Permission type
[<AutoOpen>]
module PermissionJsonParseExtension =
    /// Extension methods for JSON parsing
    type Permission with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Permission =
            let arg_3 =
                match node.["push"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["pull"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["admin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "admin" || key = "pull" || key = "push" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Admin = arg_1
                Pull = arg_2
                Push = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullRequestMeta type
[<AutoOpen>]
module PullRequestMetaJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullRequestMeta with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullRequestMeta =
            let arg_2 =
                match node.["mergedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["merged"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "merged" || key = "mergedAt" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Merged = arg_1
                MergedAt = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullReviewRequestOptions type
[<AutoOpen>]
module PullReviewRequestOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullReviewRequestOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullReviewRequestOptions =
            let arg_2 =
                match node.["teamReviewers"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["reviewers"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "reviewers" || key = "teamReviewers" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Reviewers = arg_1
                TeamReviewers = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PushMirror type
[<AutoOpen>]
module PushMirrorJsonParseExtension =
    /// Extension methods for JSON parsing
    type PushMirror with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PushMirror =
            let arg_8 =
                match node.["syncOnCommit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["repoName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["remoteName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["remoteAddress"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["lastUpdate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["lastError"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["interval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "interval"
                        || key = "lastError"
                        || key = "lastUpdate"
                        || key = "remoteAddress"
                        || key = "remoteName"
                        || key = "repoName"
                        || key = "syncOnCommit"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Interval = arg_2
                LastError = arg_3
                LastUpdate = arg_4
                RemoteAddress = arg_5
                RemoteName = arg_6
                RepoName = arg_7
                SyncOnCommit = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Reference type
[<AutoOpen>]
module ReferenceJsonParseExtension =
    /// Extension methods for JSON parsing
    type Reference with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Reference =
            let arg_3 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["object"] with
                | null -> None
                | v -> GitObject.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "object" || key = "ref" || key = "url" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Object = arg_1
                Ref = arg_2
                Url = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoTopicOptions type
[<AutoOpen>]
module RepoTopicOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoTopicOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoTopicOptions =
            let arg_1 =
                match node.["topics"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "topics" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Topics = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepositoryMeta type
[<AutoOpen>]
module RepositoryMetaJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepositoryMeta with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepositoryMeta =
            let arg_4 =
                match node.["owner"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "fullName" || key = "id" || key = "name" || key = "owner" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                FullName = arg_1
                Id = arg_2
                Name = arg_3
                Owner = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ServerVersion type
[<AutoOpen>]
module ServerVersionJsonParseExtension =
    /// Extension methods for JSON parsing
    type ServerVersion with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ServerVersion =
            let arg_1 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "version" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Version = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the StopWatch type
[<AutoOpen>]
module StopWatchJsonParseExtension =
    /// Extension methods for JSON parsing
    type StopWatch with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : StopWatch =
            let arg_7 =
                match node.["seconds"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["repoOwnerName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["repoName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["issueTitle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["issueIndex"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["duration"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "duration"
                        || key = "issueIndex"
                        || key = "issueTitle"
                        || key = "repoName"
                        || key = "repoOwnerName"
                        || key = "seconds"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Duration = arg_2
                IssueIndex = arg_3
                IssueTitle = arg_4
                RepoName = arg_5
                RepoOwnerName = arg_6
                Seconds = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the SubmitPullReviewOptions type
[<AutoOpen>]
module SubmitPullReviewOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type SubmitPullReviewOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : SubmitPullReviewOptions =
            let arg_2 =
                match node.["event"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" || key = "event" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Event = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Tag type
[<AutoOpen>]
module TagJsonParseExtension =
    /// Extension methods for JSON parsing
    type Tag with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Tag =
            let arg_6 =
                match node.["zipballUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["tarballUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> CommitMeta.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commit"
                        || key = "id"
                        || key = "message"
                        || key = "name"
                        || key = "tarballUrl"
                        || key = "zipballUrl"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Id = arg_2
                Message = arg_3
                Name = arg_4
                TarballUrl = arg_5
                ZipballUrl = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Type8 type
[<AutoOpen>]
module Type8JsonParseExtension =
    /// Extension methods for JSON parsing
    type Type8 with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Type8 =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, string> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.String> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Team type
[<AutoOpen>]
module TeamJsonParseExtension =
    /// Extension methods for JSON parsing
    type Team with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Team =
            let arg_8 =
                match node.["unitsMap"] with
                | null -> None
                | v -> Type8.jsonParse v |> Some

            let arg_7 =
                match node.["units"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["organization"] with
                | null -> None
                | v -> Organization.jsonParse v |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["includesAllRepositories"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["canCreateOrgRepo"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "canCreateOrgRepo"
                        || key = "id"
                        || key = "includesAllRepositories"
                        || key = "name"
                        || key = "organization"
                        || key = "permission"
                        || key = "units"
                        || key = "unitsMap"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CanCreateOrgRepo = arg_1
                Id = arg_2
                IncludesAllRepositories = arg_3
                Name = arg_4
                Organization = arg_5
                Permission = arg_6
                Units = arg_7
                UnitsMap = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TopicName type
[<AutoOpen>]
module TopicNameJsonParseExtension =
    /// Extension methods for JSON parsing
    type TopicName with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TopicName =
            let arg_1 =
                match node.["topics"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "topics" then () else result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Topics = arg_1
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TopicResponse type
[<AutoOpen>]
module TopicResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type TopicResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TopicResponse =
            let arg_5 =
                match node.["updated"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["topicName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["repoCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "id"
                        || key = "repoCount"
                        || key = "topicName"
                        || key = "updated"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Id = arg_2
                RepoCount = arg_3
                TopicName = arg_4
                Updated = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TransferRepoOption type
[<AutoOpen>]
module TransferRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type TransferRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TransferRepoOption =
            let arg_2 =
                match node.["teamIds"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.Int32> ())
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                (match node.["newOwner"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("newOwner")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "newOwner" || key = "teamIds" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                NewOwner = arg_1
                TeamIds = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UpdateFileOptions type
[<AutoOpen>]
module UpdateFileOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type UpdateFileOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UpdateFileOptions =
            let arg_10 =
                match node.["signoff"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                (match node.["sha"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("sha")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_8 =
                match node.["newBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["fromPath"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dates"] with
                | null -> None
                | v -> CommitDateOptions.jsonParse v |> Some

            let arg_4 =
                (match node.["content"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("content")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_2 =
                match node.["branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "branch"
                        || key = "committer"
                        || key = "content"
                        || key = "dates"
                        || key = "fromPath"
                        || key = "message"
                        || key = "newBranch"
                        || key = "sha"
                        || key = "signoff"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Branch = arg_2
                Committer = arg_3
                Content = arg_4
                Dates = arg_5
                FromPath = arg_6
                Message = arg_7
                NewBranch = arg_8
                Sha = arg_9
                Signoff = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the User type
[<AutoOpen>]
module UserJsonParseExtension =
    /// Extension methods for JSON parsing
    type User with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : User =
            let arg_19 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_18 =
                match node.["visibility"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["starredReposCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_16 =
                match node.["restricted"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_15 =
                match node.["prohibitLogin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_14 =
                match node.["loginName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["login"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["lastLogin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["isAdmin"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["followingCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["followersCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["email"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["avatarUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "avatarUrl"
                        || key = "created"
                        || key = "email"
                        || key = "followersCount"
                        || key = "followingCount"
                        || key = "fullName"
                        || key = "id"
                        || key = "isAdmin"
                        || key = "language"
                        || key = "lastLogin"
                        || key = "location"
                        || key = "login"
                        || key = "loginName"
                        || key = "prohibitLogin"
                        || key = "restricted"
                        || key = "starredReposCount"
                        || key = "visibility"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AvatarUrl = arg_2
                Created = arg_3
                Email = arg_4
                FollowersCount = arg_5
                FollowingCount = arg_6
                FullName = arg_7
                Id = arg_8
                IsAdmin = arg_9
                Language = arg_10
                LastLogin = arg_11
                Location = arg_12
                Login = arg_13
                LoginName = arg_14
                ProhibitLogin = arg_15
                Restricted = arg_16
                StarredReposCount = arg_17
                Visibility = arg_18
                Website = arg_19
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UserHeatmapData type
[<AutoOpen>]
module UserHeatmapDataJsonParseExtension =
    /// Extension methods for JSON parsing
    type UserHeatmapData with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UserHeatmapData =
            let arg_2 =
                match node.["timestamp"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["contributions"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "contributions" || key = "timestamp" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Contributions = arg_1
                Timestamp = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UserSettings type
[<AutoOpen>]
module UserSettingsJsonParseExtension =
    /// Extension methods for JSON parsing
    type UserSettings with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UserSettings =
            let arg_8 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["theme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["hideEmail"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["hideActivity"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["diffViewStyle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "diffViewStyle"
                        || key = "fullName"
                        || key = "hideActivity"
                        || key = "hideEmail"
                        || key = "language"
                        || key = "location"
                        || key = "theme"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DiffViewStyle = arg_1
                FullName = arg_2
                HideActivity = arg_3
                HideEmail = arg_4
                Language = arg_5
                Location = arg_6
                Theme = arg_7
                Website = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the UserSettingsOptions type
[<AutoOpen>]
module UserSettingsOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type UserSettingsOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : UserSettingsOptions =
            let arg_8 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["theme"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["location"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["hideEmail"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["hideActivity"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["diffViewStyle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "diffViewStyle"
                        || key = "fullName"
                        || key = "hideActivity"
                        || key = "hideEmail"
                        || key = "language"
                        || key = "location"
                        || key = "theme"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                DiffViewStyle = arg_1
                FullName = arg_2
                HideActivity = arg_3
                HideEmail = arg_4
                Language = arg_5
                Location = arg_6
                Theme = arg_7
                Website = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WatchInfo type
[<AutoOpen>]
module WatchInfoJsonParseExtension =
    /// Extension methods for JSON parsing
    type WatchInfo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WatchInfo =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["subscribed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["repositoryUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["reason"] with
                | null -> None
                | v -> () |> Some

            let arg_2 =
                match node.["ignored"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "createdAt"
                        || key = "ignored"
                        || key = "reason"
                        || key = "repositoryUrl"
                        || key = "subscribed"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Ignored = arg_2
                Reason = arg_3
                RepositoryUrl = arg_4
                Subscribed = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiCommit type
[<AutoOpen>]
module WikiCommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiCommit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiCommit =
            let arg_4 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["commiter"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "author" || key = "commiter" || key = "message" || key = "sha" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Commiter = arg_2
                Message = arg_3
                Sha = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiCommitList type
[<AutoOpen>]
module WikiCommitListJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiCommitList with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiCommitList =
            let arg_2 =
                match node.["count"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["commits"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> WikiCommit.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commits" || key = "count" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commits = arg_1
                Count = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiPage type
[<AutoOpen>]
module WikiPageJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiPage with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiPage =
            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["subUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["sidebar"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["lastCommit"] with
                | null -> None
                | v -> WikiCommit.jsonParse v |> Some

            let arg_4 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["footer"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["contentBase64"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commitCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commitCount"
                        || key = "contentBase64"
                        || key = "footer"
                        || key = "htmlUrl"
                        || key = "lastCommit"
                        || key = "sidebar"
                        || key = "subUrl"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CommitCount = arg_1
                ContentBase64 = arg_2
                Footer = arg_3
                HtmlUrl = arg_4
                LastCommit = arg_5
                Sidebar = arg_6
                SubUrl = arg_7
                Title = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the WikiPageMetaData type
[<AutoOpen>]
module WikiPageMetaDataJsonParseExtension =
    /// Extension methods for JSON parsing
    type WikiPageMetaData with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : WikiPageMetaData =
            let arg_4 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["subUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["lastCommit"] with
                | null -> None
                | v -> WikiCommit.jsonParse v |> Some

            let arg_1 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "htmlUrl" || key = "lastCommit" || key = "subUrl" || key = "title" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                HtmlUrl = arg_1
                LastCommit = arg_2
                SubUrl = arg_3
                Title = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Comment type
[<AutoOpen>]
module CommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type Comment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Comment =
            let arg_11 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_10 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["pullRequestUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["originalAuthorId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["originalAuthor"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["issueUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["assets"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Attachment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assets"
                        || key = "body"
                        || key = "createdAt"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "issueUrl"
                        || key = "originalAuthor"
                        || key = "originalAuthorId"
                        || key = "pullRequestUrl"
                        || key = "updatedAt"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assets = arg_1
                Body = arg_2
                CreatedAt = arg_3
                HtmlUrl = arg_4
                Id = arg_5
                IssueUrl = arg_6
                OriginalAuthor = arg_7
                OriginalAuthorId = arg_8
                PullRequestUrl = arg_9
                UpdatedAt = arg_10
                User = arg_11
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CommitStatus type
[<AutoOpen>]
module CommitStatusJsonParseExtension =
    /// Extension methods for JSON parsing
    type CommitStatus with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CommitStatus =
            let arg_8 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["targetUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["status"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["creator"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["context"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "context"
                        || key = "createdAt"
                        || key = "creator"
                        || key = "id"
                        || key = "status"
                        || key = "targetUrl"
                        || key = "updatedAt"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Context = arg_1
                CreatedAt = arg_2
                Creator = arg_3
                Id = arg_4
                Status = arg_5
                TargetUrl = arg_6
                UpdatedAt = arg_7
                Url = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the ContentsResponse type
[<AutoOpen>]
module ContentsResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type ContentsResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : ContentsResponse =
            let arg_14 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["target"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["submoduleGitUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_10 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["lastCommitSha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["gitUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["encoding"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["downloadUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["links"] with
                | null -> None
                | v -> FileLinksResponse.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "links"
                        || key = "content"
                        || key = "downloadUrl"
                        || key = "encoding"
                        || key = "gitUrl"
                        || key = "htmlUrl"
                        || key = "lastCommitSha"
                        || key = "name"
                        || key = "path"
                        || key = "sha"
                        || key = "size"
                        || key = "submoduleGitUrl"
                        || key = "target"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Links = arg_1
                Content = arg_2
                DownloadUrl = arg_3
                Encoding = arg_4
                GitUrl = arg_5
                HtmlUrl = arg_6
                LastCommitSha = arg_7
                Name = arg_8
                Path = arg_9
                Sha = arg_10
                Size = arg_11
                SubmoduleGitUrl = arg_12
                Target = arg_13
                Url = arg_14
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateFileOptions type
[<AutoOpen>]
module CreateFileOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateFileOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateFileOptions =
            let arg_8 =
                match node.["signoff"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["newBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dates"] with
                | null -> None
                | v -> CommitDateOptions.jsonParse v |> Some

            let arg_4 =
                (match node.["content"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("content")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_2 =
                match node.["branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "branch"
                        || key = "committer"
                        || key = "content"
                        || key = "dates"
                        || key = "message"
                        || key = "newBranch"
                        || key = "signoff"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Branch = arg_2
                Committer = arg_3
                Content = arg_4
                Dates = arg_5
                Message = arg_6
                NewBranch = arg_7
                Signoff = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreateHookOption type
[<AutoOpen>]
module CreateHookOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreateHookOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreateHookOption =
            let arg_5 =
                match node.["events"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                CreateHookOptionConfig.jsonParse (
                    match node.["config"] with
                    | null ->
                        raise (
                            System.Collections.Generic.KeyNotFoundException (
                                sprintf "Required key '%s' not found on JSON object" ("config")
                            )
                        )
                    | v -> v
                )

            let arg_3 =
                match node.["branchFilter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["authorizationHeader"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["active"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "active"
                        || key = "authorizationHeader"
                        || key = "branchFilter"
                        || key = "config"
                        || key = "events"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Active = arg_1
                AuthorizationHeader = arg_2
                BranchFilter = arg_3
                Config = arg_4
                Events = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CreatePullReviewOptions type
[<AutoOpen>]
module CreatePullReviewOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type CreatePullReviewOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CreatePullReviewOptions =
            let arg_4 =
                match node.["event"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["commitId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["comments"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CreatePullReviewComment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "body" || key = "comments" || key = "commitId" || key = "event" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                Comments = arg_2
                CommitId = arg_3
                Event = arg_4
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DeleteFileOptions type
[<AutoOpen>]
module DeleteFileOptionsJsonParseExtension =
    /// Extension methods for JSON parsing
    type DeleteFileOptions with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DeleteFileOptions =
            let arg_8 =
                match node.["signoff"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                (match node.["sha"] with
                 | null ->
                     raise (
                         System.Collections.Generic.KeyNotFoundException (
                             sprintf "Required key '%s' not found on JSON object" ("sha")
                         )
                     )
                 | v -> v)
                    .AsValue()
                    .GetValue<System.String> ()

            let arg_6 =
                match node.["newBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["dates"] with
                | null -> None
                | v -> CommitDateOptions.jsonParse v |> Some

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_2 =
                match node.["branch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> Identity.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "branch"
                        || key = "committer"
                        || key = "dates"
                        || key = "message"
                        || key = "newBranch"
                        || key = "sha"
                        || key = "signoff"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Branch = arg_2
                Committer = arg_3
                Dates = arg_4
                Message = arg_5
                NewBranch = arg_6
                Sha = arg_7
                Signoff = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the EditRepoOption type
[<AutoOpen>]
module EditRepoOptionJsonParseExtension =
    /// Extension methods for JSON parsing
    type EditRepoOption with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : EditRepoOption =
            let arg_26 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_25 =
                match node.["template"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_24 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_23 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_22 =
                match node.["mirrorInterval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_21 =
                match node.["internalTracker"] with
                | null -> None
                | v -> InternalTracker.jsonParse v |> Some

            let arg_20 =
                match node.["ignoreWhitespaceConflicts"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_19 =
                match node.["hasWiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["hasPullRequests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["hasProjects"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_16 =
                match node.["hasIssues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_15 =
                match node.["externalWiki"] with
                | null -> None
                | v -> ExternalWiki.jsonParse v |> Some

            let arg_14 =
                match node.["externalTracker"] with
                | null -> None
                | v -> ExternalTracker.jsonParse v |> Some

            let arg_13 =
                match node.["enablePrune"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_12 =
                match node.["defaultMergeStyle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["defaultDeleteBranchAfterMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["defaultBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["defaultAllowMaintainerEdit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["autodetectManualMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["archived"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["allowSquashMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["allowRebaseUpdate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["allowRebaseExplicit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["allowRebase"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["allowMergeCommits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allowManualMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allowManualMerge"
                        || key = "allowMergeCommits"
                        || key = "allowRebase"
                        || key = "allowRebaseExplicit"
                        || key = "allowRebaseUpdate"
                        || key = "allowSquashMerge"
                        || key = "archived"
                        || key = "autodetectManualMerge"
                        || key = "defaultAllowMaintainerEdit"
                        || key = "defaultBranch"
                        || key = "defaultDeleteBranchAfterMerge"
                        || key = "defaultMergeStyle"
                        || key = "enablePrune"
                        || key = "externalTracker"
                        || key = "externalWiki"
                        || key = "hasIssues"
                        || key = "hasProjects"
                        || key = "hasPullRequests"
                        || key = "hasWiki"
                        || key = "ignoreWhitespaceConflicts"
                        || key = "internalTracker"
                        || key = "mirrorInterval"
                        || key = "name"
                        || key = "private"
                        || key = "template"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowManualMerge = arg_1
                AllowMergeCommits = arg_2
                AllowRebase = arg_3
                AllowRebaseExplicit = arg_4
                AllowRebaseUpdate = arg_5
                AllowSquashMerge = arg_6
                Archived = arg_7
                AutodetectManualMerge = arg_8
                DefaultAllowMaintainerEdit = arg_9
                DefaultBranch = arg_10
                DefaultDeleteBranchAfterMerge = arg_11
                DefaultMergeStyle = arg_12
                EnablePrune = arg_13
                ExternalTracker = arg_14
                ExternalWiki = arg_15
                HasIssues = arg_16
                HasProjects = arg_17
                HasPullRequests = arg_18
                HasWiki = arg_19
                IgnoreWhitespaceConflicts = arg_20
                InternalTracker = arg_21
                MirrorInterval = arg_22
                Name = arg_23
                Private = arg_24
                Template = arg_25
                Website = arg_26
            }
namespace Gitea

/// Module containing JSON parsing extension members for the IssueTemplate type
[<AutoOpen>]
module IssueTemplateJsonParseExtension =
    /// Extension methods for JSON parsing
    type IssueTemplate with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : IssueTemplate =
            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["labels"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["fileName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["body"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> IssueFormField.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_1 =
                match node.["about"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "about"
                        || key = "body"
                        || key = "content"
                        || key = "fileName"
                        || key = "labels"
                        || key = "name"
                        || key = "ref"
                        || key = "title"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                About = arg_1
                Body = arg_2
                Content = arg_3
                FileName = arg_4
                Labels = arg_5
                Name = arg_6
                Ref = arg_7
                Title = arg_8
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Milestone type
[<AutoOpen>]
module MilestoneJsonParseExtension =
    /// Extension methods for JSON parsing
    type Milestone with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Milestone =
            let arg_9 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["openIssues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["dueOn"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["closedIssues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["closedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "closedAt"
                        || key = "closedIssues"
                        || key = "createdAt"
                        || key = "dueOn"
                        || key = "id"
                        || key = "openIssues"
                        || key = "state"
                        || key = "title"
                        || key = "updatedAt"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                ClosedAt = arg_1
                ClosedIssues = arg_2
                CreatedAt = arg_3
                DueOn = arg_4
                Id = arg_5
                OpenIssues = arg_6
                State = arg_7
                Title = arg_8
                UpdatedAt = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfoUsage type
[<AutoOpen>]
module NodeInfoUsageJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfoUsage with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfoUsage =
            let arg_3 =
                match node.["users"] with
                | null -> None
                | v -> NodeInfoUsageUsers.jsonParse v |> Some

            let arg_2 =
                match node.["localPosts"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["localComments"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "localComments" || key = "localPosts" || key = "users" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                LocalComments = arg_1
                LocalPosts = arg_2
                Users = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NotificationSubject type
[<AutoOpen>]
module NotificationSubjectJsonParseExtension =
    /// Extension methods for JSON parsing
    type NotificationSubject with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NotificationSubject =
            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["latestCommentUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["latestCommentHtmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "htmlUrl"
                        || key = "latestCommentHtmlUrl"
                        || key = "latestCommentUrl"
                        || key = "state"
                        || key = "title"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                HtmlUrl = arg_1
                LatestCommentHtmlUrl = arg_2
                LatestCommentUrl = arg_3
                State = arg_4
                Title = arg_5
                Url = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PayloadCommitVerification type
[<AutoOpen>]
module PayloadCommitVerificationJsonParseExtension =
    /// Extension methods for JSON parsing
    type PayloadCommitVerification with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PayloadCommitVerification =
            let arg_5 =
                match node.["verified"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["signer"] with
                | null -> None
                | v -> PayloadUser.jsonParse v |> Some

            let arg_3 =
                match node.["signature"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["reason"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["payload"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "payload"
                        || key = "reason"
                        || key = "signature"
                        || key = "signer"
                        || key = "verified"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Payload = arg_1
                Reason = arg_2
                Signature = arg_3
                Signer = arg_4
                Verified = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PublicKey type
[<AutoOpen>]
module PublicKeyJsonParseExtension =
    /// Extension methods for JSON parsing
    type PublicKey with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PublicKey =
            let arg_9 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_8 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["readOnly"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["keyType"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["key"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["fingerprint"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "createdAt"
                        || key = "fingerprint"
                        || key = "id"
                        || key = "key"
                        || key = "keyType"
                        || key = "readOnly"
                        || key = "title"
                        || key = "url"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Fingerprint = arg_2
                Id = arg_3
                Key = arg_4
                KeyType = arg_5
                ReadOnly = arg_6
                Title = arg_7
                Url = arg_8
                User = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullReview type
[<AutoOpen>]
module PullReviewJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullReview with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullReview =
            let arg_14 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_13 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["team"] with
                | null -> None
                | v -> Team.jsonParse v |> Some

            let arg_11 =
                match node.["submittedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["stale"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["pullRequestUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["official"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["dismissed"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["commitId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["commentsCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "commentsCount"
                        || key = "commitId"
                        || key = "dismissed"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "official"
                        || key = "pullRequestUrl"
                        || key = "stale"
                        || key = "state"
                        || key = "submittedAt"
                        || key = "team"
                        || key = "updatedAt"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                CommentsCount = arg_2
                CommitId = arg_3
                Dismissed = arg_4
                HtmlUrl = arg_5
                Id = arg_6
                Official = arg_7
                PullRequestUrl = arg_8
                Stale = arg_9
                State = arg_10
                SubmittedAt = arg_11
                Team = arg_12
                UpdatedAt = arg_13
                User = arg_14
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullReviewComment type
[<AutoOpen>]
module PullReviewCommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullReviewComment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullReviewComment =
            let arg_15 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_14 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["resolver"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_12 =
                match node.["pullRequestUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["pullRequestReviewId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_10 =
                match node.["position"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_9 =
                match node.["path"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["originalPosition"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_7 =
                match node.["originalCommitId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["diffHunk"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["commitId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "body"
                        || key = "commitId"
                        || key = "createdAt"
                        || key = "diffHunk"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "originalCommitId"
                        || key = "originalPosition"
                        || key = "path"
                        || key = "position"
                        || key = "pullRequestReviewId"
                        || key = "pullRequestUrl"
                        || key = "resolver"
                        || key = "updatedAt"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Body = arg_1
                CommitId = arg_2
                CreatedAt = arg_3
                DiffHunk = arg_4
                HtmlUrl = arg_5
                Id = arg_6
                OriginalCommitId = arg_7
                OriginalPosition = arg_8
                Path = arg_9
                Position = arg_10
                PullRequestReviewId = arg_11
                PullRequestUrl = arg_12
                Resolver = arg_13
                UpdatedAt = arg_14
                User = arg_15
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Reaction type
[<AutoOpen>]
module ReactionJsonParseExtension =
    /// Extension methods for JSON parsing
    type Reaction with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Reaction =
            let arg_3 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["content"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "content" || key = "createdAt" || key = "user" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Content = arg_1
                CreatedAt = arg_2
                User = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Release type
[<AutoOpen>]
module ReleaseJsonParseExtension =
    /// Extension methods for JSON parsing
    type Release with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Release =
            let arg_15 =
                match node.["zipballUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_13 =
                match node.["targetCommitish"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["tarballUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["tagName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["publishedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["prerelease"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["draft"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["author"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["assets"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Attachment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assets"
                        || key = "author"
                        || key = "body"
                        || key = "createdAt"
                        || key = "draft"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "name"
                        || key = "prerelease"
                        || key = "publishedAt"
                        || key = "tagName"
                        || key = "tarballUrl"
                        || key = "targetCommitish"
                        || key = "url"
                        || key = "zipballUrl"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assets = arg_1
                Author = arg_2
                Body = arg_3
                CreatedAt = arg_4
                Draft = arg_5
                HtmlUrl = arg_6
                Id = arg_7
                Name = arg_8
                Prerelease = arg_9
                PublishedAt = arg_10
                TagName = arg_11
                TarballUrl = arg_12
                TargetCommitish = arg_13
                Url = arg_14
                ZipballUrl = arg_15
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoCollaboratorPermission type
[<AutoOpen>]
module RepoCollaboratorPermissionJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoCollaboratorPermission with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoCollaboratorPermission =
            let arg_3 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["roleName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["permission"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "permission" || key = "roleName" || key = "user" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Permission = arg_1
                RoleName = arg_2
                User = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoCommit type
[<AutoOpen>]
module RepoCommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoCommit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoCommit =
            let arg_6 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_5 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["tree"] with
                | null -> None
                | v -> CommitMeta.jsonParse v |> Some

            let arg_3 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["committer"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "committer"
                        || key = "message"
                        || key = "tree"
                        || key = "url"
                        || key = "verification"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Committer = arg_2
                Message = arg_3
                Tree = arg_4
                Url = arg_5
                Verification = arg_6
            }
namespace Gitea

/// Module containing JSON parsing extension members for the RepoTransfer type
[<AutoOpen>]
module RepoTransferJsonParseExtension =
    /// Extension methods for JSON parsing
    type RepoTransfer with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : RepoTransfer =
            let arg_3 =
                match node.["teams"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq |> Some

            let arg_2 =
                match node.["recipient"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["doer"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "doer" || key = "recipient" || key = "teams" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Doer = arg_1
                Recipient = arg_2
                Teams = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Repository type
[<AutoOpen>]
module RepositoryJsonParseExtension =
    /// Extension methods for JSON parsing
    type Repository with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Repository =
            let arg_51 =
                match node.["website"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_50 =
                match node.["watchersCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_49 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_48 =
                match node.["template"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_47 =
                match node.["starsCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_46 =
                match node.["sshUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_45 =
                match node.["size"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_44 =
                match node.["repoTransfer"] with
                | null -> None
                | v -> RepoTransfer.jsonParse v |> Some

            let arg_43 =
                match node.["releaseCounter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_42 =
                match node.["private"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_41 =
                match node.["permissions"] with
                | null -> None
                | v -> Permission.jsonParse v |> Some

            let arg_40 =
                Repository.jsonParse (
                    match node.["parent"] with
                    | null ->
                        raise (
                            System.Collections.Generic.KeyNotFoundException (
                                sprintf "Required key '%s' not found on JSON object" ("parent")
                            )
                        )
                    | v -> v
                )

            let arg_39 =
                match node.["owner"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_38 =
                match node.["originalUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_37 =
                match node.["openPrCounter"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_36 =
                match node.["openIssuesCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_35 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_34 =
                match node.["mirrorUpdated"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_33 =
                match node.["mirrorInterval"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_32 =
                match node.["mirror"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_31 =
                match node.["link"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_30 =
                match node.["languagesUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_29 =
                match node.["language"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_28 =
                match node.["internalTracker"] with
                | null -> None
                | v -> InternalTracker.jsonParse v |> Some

            let arg_27 =
                match node.["internal"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_26 =
                match node.["ignoreWhitespaceConflicts"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_25 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_24 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_23 =
                match node.["hasWiki"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_22 =
                match node.["hasPullRequests"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_21 =
                match node.["hasProjects"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_20 =
                match node.["hasIssues"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_19 =
                match node.["fullName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_18 =
                match node.["forksCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_17 =
                match node.["fork"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_16 =
                match node.["externalWiki"] with
                | null -> None
                | v -> ExternalWiki.jsonParse v |> Some

            let arg_15 =
                match node.["externalTracker"] with
                | null -> None
                | v -> ExternalTracker.jsonParse v |> Some

            let arg_14 =
                match node.["empty"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["defaultMergeStyle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_12 =
                match node.["defaultDeleteBranchAfterMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_11 =
                match node.["defaultBranch"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["defaultAllowMaintainerEdit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_9 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["cloneUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["avatarUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["archived"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["allowSquashMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["allowRebaseUpdate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_3 =
                match node.["allowRebaseExplicit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["allowRebase"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["allowMergeCommits"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allowMergeCommits"
                        || key = "allowRebase"
                        || key = "allowRebaseExplicit"
                        || key = "allowRebaseUpdate"
                        || key = "allowSquashMerge"
                        || key = "archived"
                        || key = "avatarUrl"
                        || key = "cloneUrl"
                        || key = "createdAt"
                        || key = "defaultAllowMaintainerEdit"
                        || key = "defaultBranch"
                        || key = "defaultDeleteBranchAfterMerge"
                        || key = "defaultMergeStyle"
                        || key = "empty"
                        || key = "externalTracker"
                        || key = "externalWiki"
                        || key = "fork"
                        || key = "forksCount"
                        || key = "fullName"
                        || key = "hasIssues"
                        || key = "hasProjects"
                        || key = "hasPullRequests"
                        || key = "hasWiki"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "ignoreWhitespaceConflicts"
                        || key = "internal"
                        || key = "internalTracker"
                        || key = "language"
                        || key = "languagesUrl"
                        || key = "link"
                        || key = "mirror"
                        || key = "mirrorInterval"
                        || key = "mirrorUpdated"
                        || key = "name"
                        || key = "openIssuesCount"
                        || key = "openPrCounter"
                        || key = "originalUrl"
                        || key = "owner"
                        || key = "parent"
                        || key = "permissions"
                        || key = "private"
                        || key = "releaseCounter"
                        || key = "repoTransfer"
                        || key = "size"
                        || key = "sshUrl"
                        || key = "starsCount"
                        || key = "template"
                        || key = "updatedAt"
                        || key = "watchersCount"
                        || key = "website"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowMergeCommits = arg_1
                AllowRebase = arg_2
                AllowRebaseExplicit = arg_3
                AllowRebaseUpdate = arg_4
                AllowSquashMerge = arg_5
                Archived = arg_6
                AvatarUrl = arg_7
                CloneUrl = arg_8
                CreatedAt = arg_9
                DefaultAllowMaintainerEdit = arg_10
                DefaultBranch = arg_11
                DefaultDeleteBranchAfterMerge = arg_12
                DefaultMergeStyle = arg_13
                Empty = arg_14
                ExternalTracker = arg_15
                ExternalWiki = arg_16
                Fork = arg_17
                ForksCount = arg_18
                FullName = arg_19
                HasIssues = arg_20
                HasProjects = arg_21
                HasPullRequests = arg_22
                HasWiki = arg_23
                HtmlUrl = arg_24
                Id = arg_25
                IgnoreWhitespaceConflicts = arg_26
                Internal = arg_27
                InternalTracker = arg_28
                Language = arg_29
                LanguagesUrl = arg_30
                Link = arg_31
                Mirror = arg_32
                MirrorInterval = arg_33
                MirrorUpdated = arg_34
                Name = arg_35
                OpenIssuesCount = arg_36
                OpenPrCounter = arg_37
                OriginalUrl = arg_38
                Owner = arg_39
                Parent = arg_40
                Permissions = arg_41
                Private = arg_42
                ReleaseCounter = arg_43
                RepoTransfer = arg_44
                Size = arg_45
                SshUrl = arg_46
                StarsCount = arg_47
                Template = arg_48
                UpdatedAt = arg_49
                WatchersCount = arg_50
                Website = arg_51
            }
namespace Gitea

/// Module containing JSON parsing extension members for the SearchResults type
[<AutoOpen>]
module SearchResultsJsonParseExtension =
    /// Extension methods for JSON parsing
    type SearchResults with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : SearchResults =
            let arg_2 =
                match node.["ok"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["data"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Repository.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "data" || key = "ok" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Data = arg_1
                Ok = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the AnnotatedTag type
[<AutoOpen>]
module AnnotatedTagJsonParseExtension =
    /// Extension methods for JSON parsing
    type AnnotatedTag with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : AnnotatedTag =
            let arg_7 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_6 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["tagger"] with
                | null -> None
                | v -> CommitUser.jsonParse v |> Some

            let arg_4 =
                match node.["tag"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["object"] with
                | null -> None
                | v -> AnnotatedTagObject.jsonParse v |> Some

            let arg_1 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "message"
                        || key = "object"
                        || key = "sha"
                        || key = "tag"
                        || key = "tagger"
                        || key = "url"
                        || key = "verification"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Message = arg_1
                Object = arg_2
                Sha = arg_3
                Tag = arg_4
                Tagger = arg_5
                Url = arg_6
                Verification = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the CombinedStatus type
[<AutoOpen>]
module CombinedStatusJsonParseExtension =
    /// Extension methods for JSON parsing
    type CombinedStatus with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : CombinedStatus =
            let arg_7 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["totalCount"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["statuses"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitStatus.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_1 =
                match node.["commitUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commitUrl"
                        || key = "repository"
                        || key = "sha"
                        || key = "state"
                        || key = "statuses"
                        || key = "totalCount"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CommitUrl = arg_1
                Repository = arg_2
                Sha = arg_3
                State = arg_4
                Statuses = arg_5
                TotalCount = arg_6
                Url = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Commit type
[<AutoOpen>]
module CommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type Commit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Commit =
            let arg_10 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["stats"] with
                | null -> None
                | v -> CommitStats.jsonParse v |> Some

            let arg_8 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["parents"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitMeta.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["files"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> CommitAffectedFiles.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_4 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_2 =
                match node.["commit"] with
                | null -> None
                | v -> RepoCommit.jsonParse v |> Some

            let arg_1 =
                match node.["author"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "author"
                        || key = "commit"
                        || key = "committer"
                        || key = "created"
                        || key = "files"
                        || key = "htmlUrl"
                        || key = "parents"
                        || key = "sha"
                        || key = "stats"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Author = arg_1
                Commit = arg_2
                Committer = arg_3
                Created = arg_4
                Files = arg_5
                HtmlUrl = arg_6
                Parents = arg_7
                Sha = arg_8
                Stats = arg_9
                Url = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the DeployKey type
[<AutoOpen>]
module DeployKeyJsonParseExtension =
    /// Extension methods for JSON parsing
    type DeployKey with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : DeployKey =
            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_6 =
                match node.["readOnly"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_5 =
                match node.["keyId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["key"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["fingerprint"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "createdAt"
                        || key = "fingerprint"
                        || key = "id"
                        || key = "key"
                        || key = "keyId"
                        || key = "readOnly"
                        || key = "repository"
                        || key = "title"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Fingerprint = arg_2
                Id = arg_3
                Key = arg_4
                KeyId = arg_5
                ReadOnly = arg_6
                Repository = arg_7
                Title = arg_8
                Url = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileDeleteResponse type
[<AutoOpen>]
module FileDeleteResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileDeleteResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileDeleteResponse =
            let arg_3 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_2 =
                match node.["content"] with
                | null -> None
                | v -> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> FileCommitResponse.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commit" || key = "content" || key = "verification" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Content = arg_2
                Verification = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the FileResponse type
[<AutoOpen>]
module FileResponseJsonParseExtension =
    /// Extension methods for JSON parsing
    type FileResponse with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : FileResponse =
            let arg_3 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_2 =
                match node.["content"] with
                | null -> None
                | v -> ContentsResponse.jsonParse v |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> FileCommitResponse.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commit" || key = "content" || key = "verification" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Content = arg_2
                Verification = arg_3
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Issue type
[<AutoOpen>]
module IssueJsonParseExtension =
    /// Extension methods for JSON parsing
    type Issue with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Issue =
            let arg_24 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_23 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_22 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_21 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_19 =
                match node.["repository"] with
                | null -> None
                | v -> RepositoryMeta.jsonParse v |> Some

            let arg_18 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["pullRequest"] with
                | null -> None
                | v -> PullRequestMeta.jsonParse v |> Some

            let arg_16 =
                match node.["originalAuthorId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_15 =
                match node.["originalAuthor"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["number"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_13 =
                match node.["milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_12 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq |> Some

            let arg_11 =
                match node.["isLocked"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_10 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_9 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["comments"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["closedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["assignees"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq |> Some

            let arg_2 =
                match node.["assignee"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["assets"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> Attachment.jsonParse elt)
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assets"
                        || key = "assignee"
                        || key = "assignees"
                        || key = "body"
                        || key = "closedAt"
                        || key = "comments"
                        || key = "createdAt"
                        || key = "dueDate"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "isLocked"
                        || key = "labels"
                        || key = "milestone"
                        || key = "number"
                        || key = "originalAuthor"
                        || key = "originalAuthorId"
                        || key = "pullRequest"
                        || key = "ref"
                        || key = "repository"
                        || key = "state"
                        || key = "title"
                        || key = "updatedAt"
                        || key = "url"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assets = arg_1
                Assignee = arg_2
                Assignees = arg_3
                Body = arg_4
                ClosedAt = arg_5
                Comments = arg_6
                CreatedAt = arg_7
                DueDate = arg_8
                HtmlUrl = arg_9
                Id = arg_10
                IsLocked = arg_11
                Labels = arg_12
                Milestone = arg_13
                Number = arg_14
                OriginalAuthor = arg_15
                OriginalAuthorId = arg_16
                PullRequest = arg_17
                Ref = arg_18
                Repository = arg_19
                State = arg_20
                Title = arg_21
                UpdatedAt = arg_22
                Url = arg_23
                User = arg_24
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NodeInfo type
[<AutoOpen>]
module NodeInfoJsonParseExtension =
    /// Extension methods for JSON parsing
    type NodeInfo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NodeInfo =
            let arg_7 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["usage"] with
                | null -> None
                | v -> NodeInfoUsage.jsonParse v |> Some

            let arg_5 =
                match node.["software"] with
                | null -> None
                | v -> NodeInfoSoftware.jsonParse v |> Some

            let arg_4 =
                match node.["services"] with
                | null -> None
                | v -> NodeInfoServices.jsonParse v |> Some

            let arg_3 =
                match node.["protocols"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_2 =
                match node.["openRegistrations"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["metadata"] with
                | null -> None
                | v -> Type7.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "metadata"
                        || key = "openRegistrations"
                        || key = "protocols"
                        || key = "services"
                        || key = "software"
                        || key = "usage"
                        || key = "version"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Metadata = arg_1
                OpenRegistrations = arg_2
                Protocols = arg_3
                Services = arg_4
                Software = arg_5
                Usage = arg_6
                Version = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Note type
[<AutoOpen>]
module NoteJsonParseExtension =
    /// Extension methods for JSON parsing
    type Note with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Note =
            let arg_2 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> Commit.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "commit" || key = "message" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                Message = arg_2
            }
namespace Gitea

/// Module containing JSON parsing extension members for the NotificationThread type
[<AutoOpen>]
module NotificationThreadJsonParseExtension =
    /// Extension methods for JSON parsing
    type NotificationThread with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : NotificationThread =
            let arg_7 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["unread"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["subject"] with
                | null -> None
                | v -> NotificationSubject.jsonParse v |> Some

            let arg_3 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_2 =
                match node.["pinned"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_1 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "id"
                        || key = "pinned"
                        || key = "repository"
                        || key = "subject"
                        || key = "unread"
                        || key = "updatedAt"
                        || key = "url"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Id = arg_1
                Pinned = arg_2
                Repository = arg_3
                Subject = arg_4
                Unread = arg_5
                UpdatedAt = arg_6
                Url = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PRBranchInfo type
[<AutoOpen>]
module PRBranchInfoJsonParseExtension =
    /// Extension methods for JSON parsing
    type PRBranchInfo with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PRBranchInfo =
            let arg_5 =
                match node.["sha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["repoId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["repo"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_2 =
                match node.["ref"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["label"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if key = "label" || key = "ref" || key = "repo" || key = "repoId" || key = "sha" then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Label = arg_1
                Ref = arg_2
                Repo = arg_3
                RepoId = arg_4
                Sha = arg_5
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Package type
[<AutoOpen>]
module PackageJsonParseExtension =
    /// Extension methods for JSON parsing
    type Package with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Package =
            let arg_7 =
                match node.["version"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["repository"] with
                | null -> None
                | v -> Repository.jsonParse v |> Some

            let arg_5 =
                match node.["owner"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_2 =
                match node.["creator"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "createdAt"
                        || key = "creator"
                        || key = "id"
                        || key = "name"
                        || key = "owner"
                        || key = "repository"
                        || key = "version"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                CreatedAt = arg_1
                Creator = arg_2
                Id = arg_3
                Name = arg_4
                Owner = arg_5
                Repository = arg_6
                Version = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PayloadCommit type
[<AutoOpen>]
module PayloadCommitJsonParseExtension =
    /// Extension methods for JSON parsing
    type PayloadCommit with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PayloadCommit =
            let arg_10 =
                match node.["verification"] with
                | null -> None
                | v -> PayloadCommitVerification.jsonParse v |> Some

            let arg_9 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["timestamp"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["removed"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["modified"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_5 =
                match node.["message"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["committer"] with
                | null -> None
                | v -> PayloadUser.jsonParse v |> Some

            let arg_2 =
                match node.["author"] with
                | null -> None
                | v -> PayloadUser.jsonParse v |> Some

            let arg_1 =
                match node.["added"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "added"
                        || key = "author"
                        || key = "committer"
                        || key = "id"
                        || key = "message"
                        || key = "modified"
                        || key = "removed"
                        || key = "timestamp"
                        || key = "url"
                        || key = "verification"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Added = arg_1
                Author = arg_2
                Committer = arg_3
                Id = arg_4
                Message = arg_5
                Modified = arg_6
                Removed = arg_7
                Timestamp = arg_8
                Url = arg_9
                Verification = arg_10
            }
namespace Gitea

/// Module containing JSON parsing extension members for the PullRequest type
[<AutoOpen>]
module PullRequestJsonParseExtension =
    /// Extension methods for JSON parsing
    type PullRequest with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : PullRequest =
            let arg_29 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_28 =
                match node.["url"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_27 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_26 =
                match node.["title"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_25 =
                match node.["state"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_24 =
                match node.["patchUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_23 =
                match node.["number"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_22 =
                match node.["milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_21 =
                match node.["mergedBy"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_20 =
                match node.["mergedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_19 =
                match node.["merged"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_18 =
                match node.["mergeable"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_17 =
                match node.["mergeCommitSha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_16 =
                match node.["mergeBase"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                match node.["labels"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq |> Some

            let arg_14 =
                match node.["isLocked"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_13 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_12 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["head"] with
                | null -> None
                | v -> PRBranchInfo.jsonParse v |> Some

            let arg_10 =
                match node.["dueDate"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_9 =
                match node.["diffUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_8 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["comments"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["closedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_4 =
                match node.["base"] with
                | null -> None
                | v -> PRBranchInfo.jsonParse v |> Some

            let arg_3 =
                match node.["assignees"] with
                | null -> None
                | v -> v.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq |> Some

            let arg_2 =
                match node.["assignee"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_1 =
                match node.["allowMaintainerEdit"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "allowMaintainerEdit"
                        || key = "assignee"
                        || key = "assignees"
                        || key = "base"
                        || key = "body"
                        || key = "closedAt"
                        || key = "comments"
                        || key = "createdAt"
                        || key = "diffUrl"
                        || key = "dueDate"
                        || key = "head"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "isLocked"
                        || key = "labels"
                        || key = "mergeBase"
                        || key = "mergeCommitSha"
                        || key = "mergeable"
                        || key = "merged"
                        || key = "mergedAt"
                        || key = "mergedBy"
                        || key = "milestone"
                        || key = "number"
                        || key = "patchUrl"
                        || key = "state"
                        || key = "title"
                        || key = "updatedAt"
                        || key = "url"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                AllowMaintainerEdit = arg_1
                Assignee = arg_2
                Assignees = arg_3
                Base = arg_4
                Body = arg_5
                ClosedAt = arg_6
                Comments = arg_7
                CreatedAt = arg_8
                DiffUrl = arg_9
                DueDate = arg_10
                Head = arg_11
                HtmlUrl = arg_12
                Id = arg_13
                IsLocked = arg_14
                Labels = arg_15
                MergeBase = arg_16
                MergeCommitSha = arg_17
                Mergeable = arg_18
                Merged = arg_19
                MergedAt = arg_20
                MergedBy = arg_21
                Milestone = arg_22
                Number = arg_23
                PatchUrl = arg_24
                State = arg_25
                Title = arg_26
                UpdatedAt = arg_27
                Url = arg_28
                User = arg_29
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TrackedTime type
[<AutoOpen>]
module TrackedTimeJsonParseExtension =
    /// Extension methods for JSON parsing
    type TrackedTime with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TrackedTime =
            let arg_7 =
                match node.["userName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_6 =
                match node.["userId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["time"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_4 =
                match node.["issueId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_3 =
                match node.["issue"] with
                | null -> None
                | v -> Issue.jsonParse v |> Some

            let arg_2 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_1 =
                match node.["created"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "created"
                        || key = "id"
                        || key = "issue"
                        || key = "issueId"
                        || key = "time"
                        || key = "userId"
                        || key = "userName"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Created = arg_1
                Id = arg_2
                Issue = arg_3
                IssueId = arg_4
                Time = arg_5
                UserId = arg_6
                UserName = arg_7
            }
namespace Gitea

/// Module containing JSON parsing extension members for the Branch type
[<AutoOpen>]
module BranchJsonParseExtension =
    /// Extension methods for JSON parsing
    type Branch with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : Branch =
            let arg_9 =
                match node.["userCanPush"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_8 =
                match node.["userCanMerge"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_7 =
                match node.["statusCheckContexts"] with
                | null -> None
                | v ->
                    v.AsArray ()
                    |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                    |> List.ofSeq
                    |> Some

            let arg_6 =
                match node.["requiredApprovals"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_5 =
                match node.["protected"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_4 =
                match node.["name"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["enableStatusCheck"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_2 =
                match node.["effectiveBranchProtectionName"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_1 =
                match node.["commit"] with
                | null -> None
                | v -> PayloadCommit.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "commit"
                        || key = "effectiveBranchProtectionName"
                        || key = "enableStatusCheck"
                        || key = "name"
                        || key = "protected"
                        || key = "requiredApprovals"
                        || key = "statusCheckContexts"
                        || key = "userCanMerge"
                        || key = "userCanPush"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Commit = arg_1
                EffectiveBranchProtectionName = arg_2
                EnableStatusCheck = arg_3
                Name = arg_4
                Protected = arg_5
                RequiredApprovals = arg_6
                StatusCheckContexts = arg_7
                UserCanMerge = arg_8
                UserCanPush = arg_9
            }
namespace Gitea

/// Module containing JSON parsing extension members for the TimelineComment type
[<AutoOpen>]
module TimelineCommentJsonParseExtension =
    /// Extension methods for JSON parsing
    type TimelineComment with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : TimelineComment =
            let arg_28 =
                match node.["user"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_27 =
                match node.["updatedAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_26 =
                match node.["trackedTime"] with
                | null -> None
                | v -> TrackedTime.jsonParse v |> Some

            let arg_25 =
                match node.["reviewId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_24 =
                match node.["resolveDoer"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_23 =
                match node.["removedAssignee"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Boolean> () |> Some

            let arg_22 =
                match node.["refIssue"] with
                | null -> None
                | v -> Issue.jsonParse v |> Some

            let arg_21 =
                match node.["refCommitSha"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_20 =
                match node.["refComment"] with
                | null -> None
                | v -> Comment.jsonParse v |> Some

            let arg_19 =
                match node.["refAction"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_18 =
                match node.["pullRequestUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_17 =
                match node.["projectId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_16 =
                match node.["oldTitle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_15 =
                match node.["oldRef"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_14 =
                match node.["oldProjectId"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_13 =
                match node.["oldMilestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_12 =
                match node.["newTitle"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_11 =
                match node.["newRef"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_10 =
                match node.["milestone"] with
                | null -> None
                | v -> Milestone.jsonParse v |> Some

            let arg_9 =
                match node.["label"] with
                | null -> None
                | v -> Label.jsonParse v |> Some

            let arg_8 =
                match node.["issueUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_7 =
                match node.["id"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.Int32> () |> Some

            let arg_6 =
                match node.["htmlUrl"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_5 =
                match node.["dependentIssue"] with
                | null -> None
                | v -> Issue.jsonParse v |> Some

            let arg_4 =
                match node.["createdAt"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_3 =
                match node.["body"] with
                | null -> None
                | v -> v.AsValue().GetValue<System.String> () |> Some

            let arg_2 =
                match node.["assigneeTeam"] with
                | null -> None
                | v -> Team.jsonParse v |> Some

            let arg_1 =
                match node.["assignee"] with
                | null -> None
                | v -> User.jsonParse v |> Some

            let arg_0 =
                let result =
                    System.Collections.Generic.Dictionary<string, System.Text.Json.Nodes.JsonNode> ()

                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if
                        key = "assignee"
                        || key = "assigneeTeam"
                        || key = "body"
                        || key = "createdAt"
                        || key = "dependentIssue"
                        || key = "htmlUrl"
                        || key = "id"
                        || key = "issueUrl"
                        || key = "label"
                        || key = "milestone"
                        || key = "newRef"
                        || key = "newTitle"
                        || key = "oldMilestone"
                        || key = "oldProjectId"
                        || key = "oldRef"
                        || key = "oldTitle"
                        || key = "projectId"
                        || key = "pullRequestUrl"
                        || key = "refAction"
                        || key = "refComment"
                        || key = "refCommitSha"
                        || key = "refIssue"
                        || key = "removedAssignee"
                        || key = "resolveDoer"
                        || key = "reviewId"
                        || key = "trackedTime"
                        || key = "updatedAt"
                        || key = "user"
                    then
                        ()
                    else
                        result.Add (key, node.[key])

                result

            {
                AdditionalProperties = arg_0
                Assignee = arg_1
                AssigneeTeam = arg_2
                Body = arg_3
                CreatedAt = arg_4
                DependentIssue = arg_5
                HtmlUrl = arg_6
                Id = arg_7
                IssueUrl = arg_8
                Label = arg_9
                Milestone = arg_10
                NewRef = arg_11
                NewTitle = arg_12
                OldMilestone = arg_13
                OldProjectId = arg_14
                OldRef = arg_15
                OldTitle = arg_16
                ProjectId = arg_17
                PullRequestUrl = arg_18
                RefAction = arg_19
                RefComment = arg_20
                RefCommitSha = arg_21
                RefIssue = arg_22
                RemovedAssignee = arg_23
                ResolveDoer = arg_24
                ReviewId = arg_25
                TrackedTime = arg_26
                UpdatedAt = arg_27
                User = arg_28
            }
namespace Gitea

/// Module containing JSON parsing extension members for the LanguageStatistics type
[<AutoOpen>]
module LanguageStatisticsJsonParseExtension =
    /// Extension methods for JSON parsing
    type LanguageStatistics with

        /// Parse from a JSON node.
        static member jsonParse (node : System.Text.Json.Nodes.JsonNode) : LanguageStatistics =
            let arg_0 =
                let result = System.Collections.Generic.Dictionary<string, int> ()
                let node = node.AsObject ()

                for KeyValue (key, value) in node do
                    if false then
                        ()
                    else
                        result.Add (
                            key,
                            (match node.[key] with
                             | null ->
                                 raise (
                                     System.Collections.Generic.KeyNotFoundException (
                                         sprintf "Required key '%s' not found on JSON object" (key)
                                     )
                                 )
                             | v -> v)
                                .AsValue()
                                .GetValue<System.Int32> ()
                        )

                result

            {
                AdditionalProperties = arg_0
            }

namespace Gitea

open WoofWare.Myriad.Plugins

/// Module for constructing a REST client.
[<CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix) ; RequireQualifiedAccess>]
module Gitea =
    /// Create a REST client.
    let make (client : System.Net.Http.HttpClient) : IGitea =
        { new IGitea with
            member _.ActivitypubPerson (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/activitypub/user/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ActivityPub.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ActivitypubPersonInbox (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/activitypub/user/{username}/inbox"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCronList (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/admin/cron"
                                 + (if "/admin/cron".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Cron.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCronRun (task : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/cron/{task}"
                                    .Replace ("{task}", task.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminListHooks (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/admin/hooks"
                                 + (if "/admin/hooks".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Hook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateHook (body : CreateHookOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/admin/hooks", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminGetHook (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/hooks/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminEditHook (id : int, body : EditHookOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/hooks/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminGetAllOrgs (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/admin/orgs"
                                 + (if "/admin/orgs".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminUnadoptedList
                (page : int, limit : int, pattern : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/admin/unadopted"
                                 + (if "/admin/unadopted".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&pattern="
                                 + ((pattern.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> elt.AsValue().GetValue<System.String> ())
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminAdoptRepository
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/unadopted/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteUnadoptedRepository
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/unadopted/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminGetAllUsers (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/admin/users"
                                 + (if "/admin/users".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateUser (body : CreateUserOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/admin/users", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateUserOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteUser (username : string, purge : bool, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/admin/users/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/admin/users/{username}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "purge="
                                 + ((purge.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminEditUser
                (username : string, body : EditUserOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/users/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditUserOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreatePublicKey
                (username : string, key : CreateKeyOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/users/{username}/keys"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            key
                            |> CreateKeyOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PublicKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteUserPublicKey
                (username : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/users/{username}/keys/{id}"
                                    .Replace("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateOrg
                (username : string, organization : CreateOrgOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/users/{username}/orgs"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            organization
                            |> CreateOrgOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminCreateRepo
                (username : string, repository : CreateRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/admin/users/{username}/repos"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            repository
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AdminDeleteHook (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/amdin/hooks/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RenderMarkdown (body : MarkdownOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/markdown", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> MarkdownOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RenderMarkdownRaw (body : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/markdown/raw", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams = new System.Net.Http.StringContent (body)
                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetNodeInfo (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/nodeinfo", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NodeInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyGetList
                (
                    all : bool,
                    status_types : string list,
                    subject_type : string list,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/notifications"
                                 + (if "/notifications".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "all="
                                 + ((all.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&subject-type="
                                 + ((subject_type.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyReadList
                (
                    last_read_at : string,
                    all : string,
                    status_types : string list,
                    to_status : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/notifications"
                                 + (if "/notifications".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "last_read_at="
                                 + ((last_read_at.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&all="
                                 + ((all.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&to-status="
                                 + ((to_status.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyNewAvailable (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/notifications/new", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NotificationCount.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyGetThread (id : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/notifications/threads/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NotificationThread.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyReadThread
                (id : string, to_status : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/notifications/threads/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/notifications/threads/{id}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "to-status="
                                 + ((to_status.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return NotificationThread.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateOrgRepoDeprecated
                (org : string, body : CreateRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/org/{org}/repos"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetAll (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs"
                                 + (if "/orgs".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreate (organization : CreateOrgOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/orgs", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            organization
                            |> CreateOrgOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGet (org : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDelete (org : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEdit (org : string, body : EditOrgOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditOrgOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Organization.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListHooks
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/hooks"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/hooks".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Hook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreateHook
                (org : string, body : CreateHookOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/hooks"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetHook (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/hooks/{id}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteHook (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/hooks/{id}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEditHook
                (org : string, id : int, body : EditHookOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/hooks/{id}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListLabels
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/labels"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/labels".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreateLabel
                (org : string, body : CreateLabelOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/labels"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetLabel (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/labels/{id}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteLabel (org : string, id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/labels/{id}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEditLabel
                (org : string, id : int, body : EditLabelOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/labels/{id}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListMembers
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/members"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/members".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgIsMember (org : string, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteMember (org : string, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListPublicMembers
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/public_members"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/public_members".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgIsPublicMember
                (org : string, username : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/public_members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgConcealMember
                (org : string, username : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/public_members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgPublicizeMember
                (org : string, username : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/public_members/{username}"
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListRepos
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/repos"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/repos".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateOrgRepo
                (org : string, body : CreateRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/repos"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeams
                (org : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/teams"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/teams".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgCreateTeam
                (org : string, body : CreateTeamOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/orgs/{org}/teams"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateTeamOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.TeamSearch
                (
                    org : string,
                    q : string,
                    include_desc : bool,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/orgs/{org}/teams/search"
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/orgs/{org}/teams/search".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&include_desc="
                                 + ((include_desc.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ListPackages
                (
                    owner : string,
                    page : int,
                    limit : int,
                    type' : string,
                    q : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/packages/{owner}"
                                    .Replace ("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/packages/{owner}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&type="
                                 + ((type'.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Package.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetPackage
                (
                    owner : string,
                    type' : string,
                    name : string,
                    version : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/packages/{owner}/{type}/{name}/{version}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{type}", type'.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{version}", version.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Package.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.DeletePackage
                (
                    owner : string,
                    type' : string,
                    name : string,
                    version : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/packages/{owner}/{type}/{name}/{version}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{type}", type'.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{version}", version.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ListPackageFiles
                (
                    owner : string,
                    type' : string,
                    name : string,
                    version : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/packages/{owner}/{type}/{name}/{version}/files"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{type}", type'.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{version}", version.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PackageFile.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueSearchIssues
                (
                    state : string,
                    labels : string,
                    milestones : string,
                    q : string,
                    priority_repo_id : int,
                    type' : string,
                    since : string,
                    before : string,
                    assigned : bool,
                    created : bool,
                    mentioned : bool,
                    review_requested : bool,
                    owner : string,
                    team : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/issues/search"
                                 + (if "/repos/issues/search".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&labels="
                                 + ((labels.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&milestones="
                                 + ((milestones.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&priority_repo_id="
                                 + ((priority_repo_id.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&type="
                                 + ((type'.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&assigned="
                                 + ((assigned.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&created="
                                 + ((created.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&mentioned="
                                 + ((mentioned.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&review_requested="
                                 + ((review_requested.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&owner="
                                 + ((owner.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&team="
                                 + ((team.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Issue.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoMigrate (body : MigrateRepoOptions, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/repos/migrate", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> MigrateRepoOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoSearch
                (
                    q : string,
                    topic : bool,
                    includeDesc : bool,
                    uid : int,
                    priority_owner_id : int,
                    team_id : int,
                    starredBy : int,
                    private' : bool,
                    is_private : bool,
                    template : bool,
                    archived : bool,
                    mode : string,
                    exclusive : bool,
                    sort : string,
                    order : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/search"
                                 + (if "/repos/search".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&topic="
                                 + ((topic.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&includeDesc="
                                 + ((includeDesc.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&uid="
                                 + ((uid.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&priority_owner_id="
                                 + ((priority_owner_id.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&team_id="
                                 + ((team_id.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&starredBy="
                                 + ((starredBy.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&private="
                                 + ((private'.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&is_private="
                                 + ((is_private.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&template="
                                 + ((template.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&archived="
                                 + ((archived.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&mode="
                                 + ((mode.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&exclusive="
                                 + ((exclusive.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&sort="
                                 + ((sort.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&order="
                                 + ((order.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return SearchResults.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGet (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDelete (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEdit
                (owner : string, repo : string, body : EditRepoOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetArchive
                (owner : string, repo : string, archive : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/archive/{archive}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{archive}", archive.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetAssignees (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/assignees"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListBranchProtection
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branch_protections"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> BranchProtection.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateBranchProtection
                (
                    owner : string,
                    repo : string,
                    body : CreateBranchProtectionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branch_protections"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateBranchProtectionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return BranchProtection.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetBranchProtection
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branch_protections/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return BranchProtection.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteBranchProtection
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branch_protections/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditBranchProtection
                (
                    owner : string,
                    repo : string,
                    name : string,
                    body : EditBranchProtectionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branch_protections/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditBranchProtectionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return BranchProtection.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListBranches
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/branches"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/branches".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Branch.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateBranch
                (
                    owner : string,
                    repo : string,
                    body : CreateBranchRepoOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branches"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateBranchRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Branch.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetBranch
                (owner : string, repo : string, branch : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branches/{branch}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{branch}", branch.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Branch.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteBranch
                (owner : string, repo : string, branch : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/branches/{branch}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{branch}", branch.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListCollaborators
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/collaborators"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/collaborators".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCheckCollaborator
                (owner : string, repo : string, collaborator : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/collaborators/{collaborator}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{collaborator}",
                                        collaborator.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteCollaborator
                (owner : string, repo : string, collaborator : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/collaborators/{collaborator}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{collaborator}",
                                        collaborator.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddCollaborator
                (
                    owner : string,
                    repo : string,
                    collaborator : string,
                    body : AddCollaboratorOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/collaborators/{collaborator}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{collaborator}",
                                        collaborator.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> AddCollaboratorOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRepoPermissions
                (owner : string, repo : string, collaborator : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/collaborators/{collaborator}/permission"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{collaborator}",
                                        collaborator.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return RepoCollaboratorPermission.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetAllCommits
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    path : string,
                    stat : bool,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/commits"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/commits".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "sha="
                                 + ((sha.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&path="
                                 + ((path.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&stat="
                                 + ((stat.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Commit.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetCombinedStatusByRef
                (
                    owner : string,
                    repo : string,
                    ref : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/commits/{ref}/status"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{ref}", ref.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/commits/{ref}/status".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return CombinedStatus.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListStatusesByRef
                (
                    owner : string,
                    repo : string,
                    ref : string,
                    sort : string,
                    state : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/commits/{ref}/statuses"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{ref}", ref.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/commits/{ref}/statuses".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "sort="
                                 + ((sort.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&state="
                                 + ((state.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> CommitStatus.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetContentsList
                (owner : string, repo : string, ref : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/contents"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/contents".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> ContentsResponse.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetContents
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/contents/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ContentsResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    body : CreateFileOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    body : DeleteFileOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> DeleteFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileDeleteResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUpdateFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    body : UpdateFileOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/contents/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> UpdateFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoApplyDiffPatch
                (owner : string, repo : string, body : UpdateFileOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/diffpatch"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> UpdateFileOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return FileResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetEditorConfig
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/editorconfig/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/editorconfig/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.ListForks
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/forks"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/forks".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateFork
                (owner : string, repo : string, body : CreateForkOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/forks"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateForkOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetBlob
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/blobs/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitBlobResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetSingleCommit
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/commits/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Commit.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDownloadCommitDiffOrPatch
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    diffType : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/commits/{sha}.{diffType}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{diffType}", diffType.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetNote
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/notes/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Note.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListAllGitRefs
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/refs"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Reference.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListGitRefs
                (owner : string, repo : string, ref : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/refs/{ref}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{ref}", ref.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Reference.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetAnnotatedTag
                (owner : string, repo : string, sha : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/git/tags/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return AnnotatedTag.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetTree
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    recursive : bool,
                    page : int,
                    per_page : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/git/trees/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/git/trees/{sha}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "recursive="
                                 + ((recursive.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&per_page="
                                 + ((per_page.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitTreeResponse.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListHooks
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/hooks"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/hooks".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Hook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateHook
                (owner : string, repo : string, body : CreateHookOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListGitHooks (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/git"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> GitHook.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetGitHook
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/git/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitHook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteGitHook
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/git/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditGitHook
                (
                    owner : string,
                    repo : string,
                    id : string,
                    body : EditGitHookOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/git/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditGitHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GitHook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetHook
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteHook
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditHook
                (
                    owner : string,
                    repo : string,
                    id : int,
                    body : EditHookOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/hooks/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditHookOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Hook.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoTestHook
                (owner : string, repo : string, id : int, ref : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/hooks/{id}/tests"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/hooks/{id}/tests".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetIssueTemplates
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issue_templates"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> IssueTemplate.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListIssues
                (
                    owner : string,
                    repo : string,
                    state : string,
                    labels : string,
                    q : string,
                    type' : string,
                    milestones : string,
                    since : string,
                    before : string,
                    created_by : string,
                    assigned_by : string,
                    mentioned_by : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&labels="
                                 + ((labels.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&type="
                                 + ((type'.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&milestones="
                                 + ((milestones.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&created_by="
                                 + ((created_by.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&assigned_by="
                                 + ((assigned_by.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&mentioned_by="
                                 + ((mentioned_by.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Issue.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateIssue
                (owner : string, repo : string, body : CreateIssueOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateIssueOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Issue.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetRepoComments
                (
                    owner : string,
                    repo : string,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues/comments".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Comment.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteComment
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListIssueCommentAttachments
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}/assets"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Attachment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssueCommentAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteIssueCommentAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssueCommentAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    body : EditAttachmentOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditAttachmentOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetCommentReactions
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Reaction.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteCommentReaction
                (
                    owner : string,
                    repo : string,
                    id : int,
                    content : EditReactionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/comments/{id}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            content
                            |> EditReactionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssue
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Issue.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDelete
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssue
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : EditIssueOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditIssueOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Issue.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListIssueAttachments
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/assets"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Attachment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssueAttachment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteIssueAttachment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssueAttachment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    attachment_id : int,
                    body : EditAttachmentOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditAttachmentOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetComments
                (
                    owner : string,
                    repo : string,
                    index : int,
                    since : string,
                    before : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues/{index}/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues/{index}/comments".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Comment.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateComment
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : CreateIssueCommentOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateIssueCommentOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Comment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteCommentDeprecated
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/comments/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditIssueDeadline
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : EditDeadlineOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/deadline"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditDeadlineOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return IssueDeadline.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetLabels
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueAddLabel
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : IssueLabelsOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> IssueLabelsOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueClearLabels
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueReplaceLabels
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : IssueLabelsOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> IssueLabelsOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueRemoveLabel
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetIssueReactions
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues/{index}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues/{index}/reactions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Reaction.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteIssueReaction
                (
                    owner : string,
                    repo : string,
                    index : int,
                    content : EditReactionOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/reactions"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            content
                            |> EditReactionOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteStopWatch
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/stopwatch/delete"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueStartStopWatch
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/stopwatch/start"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueStopStopWatch
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/stopwatch/stop"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueSubscriptions
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues/{index}/subscriptions"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues/{index}/subscriptions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCheckSubscription
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/subscriptions/check"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WatchInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetCommentsAndTimeline
                (
                    owner : string,
                    repo : string,
                    index : int,
                    since : string,
                    page : int,
                    limit : int,
                    before : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues/{index}/timeline"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues/{index}/timeline".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TimelineComment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueTrackedTimes
                (
                    owner : string,
                    repo : string,
                    index : int,
                    user : string,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/issues/{index}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/issues/{index}/times".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "user="
                                 + ((user.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueAddTime
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : AddTimeOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> AddTimeOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return TrackedTime.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueResetTime
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteTime
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/issues/{index}/times/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListKeys
                (
                    owner : string,
                    repo : string,
                    key_id : int,
                    fingerprint : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/keys"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/keys".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "key_id="
                                 + ((key_id.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&fingerprint="
                                 + ((fingerprint.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> DeployKey.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateKey
                (owner : string, repo : string, body : CreateKeyOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/keys"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateKeyOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return DeployKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetKey
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/keys/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return DeployKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteKey
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/keys/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueListLabels
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/labels".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Label.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateLabel
                (owner : string, repo : string, body : CreateLabelOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/labels"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetLabel
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteLabel
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditLabel
                (
                    owner : string,
                    repo : string,
                    id : int,
                    body : EditLabelOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/labels/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditLabelOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Label.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetLanguages (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/languages"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return LanguageStatistics.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRawFileOrLFS
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/media/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/media/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetMilestonesList
                (
                    owner : string,
                    repo : string,
                    state : string,
                    name : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/milestones"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/milestones".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&name="
                                 + ((name.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Milestone.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueCreateMilestone
                (
                    owner : string,
                    repo : string,
                    body : CreateMilestoneOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/milestones"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateMilestoneOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Milestone.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueGetMilestone
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/milestones/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Milestone.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueDeleteMilestone
                (owner : string, repo : string, id : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/milestones/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.IssueEditMilestone
                (
                    owner : string,
                    repo : string,
                    id : string,
                    body : EditMilestoneOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/milestones/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditMilestoneOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Milestone.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoMirrorSync (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/mirror-sync"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyGetRepoList
                (
                    owner : string,
                    repo : string,
                    all : bool,
                    status_types : string list,
                    subject_type : string list,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/notifications"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/notifications".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "all="
                                 + ((all.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&subject-type="
                                 + ((subject_type.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.NotifyReadRepoList
                (
                    owner : string,
                    repo : string,
                    all : string,
                    status_types : string list,
                    to_status : string,
                    last_read_at : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/notifications"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/notifications".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "all="
                                 + ((all.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&status-types="
                                 + ((status_types.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&to-status="
                                 + ((to_status.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&last_read_at="
                                 + ((last_read_at.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> NotificationThread.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListPullRequests
                (
                    owner : string,
                    repo : string,
                    state : string,
                    sort : string,
                    milestone : int,
                    labels : int list,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/pulls"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/pulls".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "state="
                                 + ((state.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&sort="
                                 + ((sort.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&milestone="
                                 + ((milestone.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&labels="
                                 + ((labels.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullRequest.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreatePullRequest
                (
                    owner : string,
                    repo : string,
                    body : CreatePullRequestOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreatePullRequestOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullRequest.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullRequest
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullRequest.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditPullRequest
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : EditPullRequestOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditPullRequestOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullRequest.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDownloadPullDiffOrPatch
                (
                    owner : string,
                    repo : string,
                    index : int,
                    diffType : string,
                    binary : bool,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/pulls/{index}.{diffType}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{diffType}", diffType.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/pulls/{index}.{diffType}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "binary="
                                 + ((binary.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullRequestCommits
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/pulls/{index}/commits"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/pulls/{index}/commits".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Commit.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullRequestFiles
                (
                    owner : string,
                    repo : string,
                    index : int,
                    skip_to : string,
                    whitespace : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/pulls/{index}/files"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/pulls/{index}/files".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "skip-to="
                                 + ((skip_to.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&whitespace="
                                 + ((whitespace.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> ChangedFile.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoPullRequestIsMerged
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/merge"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoMergePullRequest
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : MergePullRequestOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/merge"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> MergePullRequestOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCancelScheduledAutoMerge
                (owner : string, repo : string, index : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/merge"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreatePullReviewRequests
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : PullReviewRequestOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/requested_reviewers"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> PullReviewRequestOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullReview.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeletePullReviewRequests
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : PullReviewRequestOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/requested_reviewers"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> PullReviewRequestOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListPullReviews
                (
                    owner : string,
                    repo : string,
                    index : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/pulls/{index}/reviews"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/pulls/{index}/reviews".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullReview.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreatePullReview
                (
                    owner : string,
                    repo : string,
                    index : int,
                    body : CreatePullReviewOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreatePullReviewOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullReview
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoSubmitPullReview
                (
                    owner : string,
                    repo : string,
                    index : int,
                    id : int,
                    body : SubmitPullReviewOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> SubmitPullReviewOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeletePullReview
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPullReviewComments
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/comments"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PullReviewComment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDismissPullReview
                (
                    owner : string,
                    repo : string,
                    index : int,
                    id : int,
                    body : DismissPullReviewOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/dismissals"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> DismissPullReviewOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUnDismissPullReview
                (owner : string, repo : string, index : int, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/pulls/{index}/reviews/{id}/undismissals"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PullReview.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUpdatePullRequest
                (
                    owner : string,
                    repo : string,
                    index : int,
                    style : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/pulls/{index}/update"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{index}", index.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/pulls/{index}/update".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "style="
                                 + ((style.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListPushMirrors
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/push_mirrors"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/push_mirrors".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PushMirror.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddPushMirror
                (
                    owner : string,
                    repo : string,
                    body : CreatePushMirrorOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/push_mirrors"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreatePushMirrorOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PushMirror.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoPushMirrorSync
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/push_mirrors-sync"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetPushMirrorByRemoteName
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/push_mirrors/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PushMirror.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeletePushMirror
                (owner : string, repo : string, name : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/push_mirrors/{name}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{name}", name.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRawFile
                (
                    owner : string,
                    repo : string,
                    filepath : string,
                    ref : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/raw/{filepath}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{filepath}", filepath.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/raw/{filepath}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "ref="
                                 + ((ref.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListReleases
                (
                    owner : string,
                    repo : string,
                    draft : bool,
                    pre_release : bool,
                    per_page : int,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/releases"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/releases".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "draft="
                                 + ((draft.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&pre-release="
                                 + ((pre_release.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&per_page="
                                 + ((per_page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Release.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateRelease
                (
                    owner : string,
                    repo : string,
                    body : CreateReleaseOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateReleaseOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetLatestRelease
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/latest"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetReleaseByTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{tag}", tag.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteReleaseByTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{tag}", tag.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetRelease
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteRelease
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditRelease
                (
                    owner : string,
                    repo : string,
                    id : int,
                    body : EditReleaseOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditReleaseOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Release.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListReleaseAttachments
                (owner : string, repo : string, id : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}/assets"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Attachment.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetReleaseAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteReleaseAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditReleaseAttachment
                (
                    owner : string,
                    repo : string,
                    id : int,
                    attachment_id : int,
                    body : EditAttachmentOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/releases/{id}/assets/{attachment_id}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace (
                                        "{attachment_id}",
                                        attachment_id.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditAttachmentOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Attachment.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetReviewers (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/reviewers"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoSigningKey (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/signing-key.gpg"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListStargazers
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/stargazers"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/stargazers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListStatuses
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    sort : string,
                    state : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/statuses/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/statuses/{sha}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "sort="
                                 + ((sort.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&state="
                                 + ((state.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> CommitStatus.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateStatus
                (
                    owner : string,
                    repo : string,
                    sha : string,
                    body : CreateStatusOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/statuses/{sha}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{sha}", sha.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateStatusOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return CommitStatus.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListSubscribers
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/subscribers"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/subscribers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentCheckSubscription
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/subscription"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WatchInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteSubscription
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/subscription"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPutSubscription
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/subscription"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WatchInfo.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListTags
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/tags"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/tags".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Tag.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateTag
                (owner : string, repo : string, body : CreateTagOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/tags"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateTagOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Tag.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{tag}", tag.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Tag.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteTag
                (owner : string, repo : string, tag : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/tags/{tag}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{tag}", tag.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListTeams (owner : string, repo : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/teams"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCheckTeam
                (owner : string, repo : string, team : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/teams/{team}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{team}", team.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteTeam
                (owner : string, repo : string, team : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/teams/{team}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{team}", team.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddTeam
                (owner : string, repo : string, team : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/teams/{team}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{team}", team.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoTrackedTimes
                (
                    owner : string,
                    repo : string,
                    user : string,
                    since : string,
                    before : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/times"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/times".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "user="
                                 + ((user.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserTrackedTimes
                (owner : string, repo : string, user : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/times/{user}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{user}", user.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoListTopics
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/topics"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/topics".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return TopicName.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoUpdateTopics
                (owner : string, repo : string, body : RepoTopicOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/topics"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> RepoTopicOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteTopic
                (owner : string, repo : string, topic : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/topics/{topic}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{topic}", topic.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoAddTopic
                (owner : string, repo : string, topic : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/topics/{topic}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{topic}", topic.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoTransfer
                (
                    owner : string,
                    repo : string,
                    body : TransferRepoOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/transfer"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> TransferRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.AcceptRepoTransfer
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/transfer/accept"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RejectRepoTransfer
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/transfer/reject"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoCreateWikiPage
                (
                    owner : string,
                    repo : string,
                    body : CreateWikiPageOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/wiki/new"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateWikiPageOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiPage.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetWikiPage
                (owner : string, repo : string, pageName : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/wiki/page/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiPage.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoDeleteWikiPage
                (owner : string, repo : string, pageName : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/wiki/page/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoEditWikiPage
                (
                    owner : string,
                    repo : string,
                    pageName : string,
                    body : CreateWikiPageOptions,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{owner}/{repo}/wiki/page/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateWikiPageOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiPage.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetWikiPages
                (owner : string, repo : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/wiki/pages"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/wiki/pages".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> WikiPageMetaData.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetWikiPageRevisions
                (
                    owner : string,
                    repo : string,
                    pageName : string,
                    page : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/repos/{owner}/{repo}/wiki/revisions/{pageName}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{pageName}", pageName.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/repos/{owner}/{repo}/wiki/revisions/{pageName}".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return WikiCommitList.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GenerateRepo
                (
                    template_owner : string,
                    template_repo : string,
                    body : GenerateRepoOption,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repos/{template_owner}/{template_repo}/generate"
                                    .Replace(
                                        "{template_owner}",
                                        template_owner.ToString () |> System.Web.HttpUtility.UrlEncode
                                    )
                                    .Replace (
                                        "{template_repo}",
                                        template_repo.ToString () |> System.Web.HttpUtility.UrlEncode
                                    ),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> GenerateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.RepoGetByID (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/repositories/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralAPISettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/settings/api", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralAPISettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralAttachmentSettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/settings/attachment", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralAttachmentSettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralRepositorySettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/settings/repository", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralRepoSettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetGeneralUISettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/settings/ui", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return GeneralUISettings.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetSigningKey (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/signing-key.gpg", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetTeam (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgDeleteTeam (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgEditTeam (id : int, body : EditTeamOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> EditTeamOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Team.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamMembers
                (id : int, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/teams/{id}/members"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/teams/{id}/members".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamMember (id : int, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}/members/{username}"
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgRemoveTeamMember (id : int, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}/members/{username}"
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgAddTeamMember (id : int, username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}/members/{username}"
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamRepos
                (id : int, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/teams/{id}/repos"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/teams/{id}/repos".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListTeamRepo
                (id : int, org : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}/repos/{org}/{repo}"
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgRemoveTeamRepository
                (id : int, org : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}/repos/{org}/{repo}"
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgAddTeamRepository
                (id : int, org : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/teams/{id}/repos/{org}/{repo}"
                                    .Replace("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.TopicSearch (q : string, page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/topics/search"
                                 + (if "/topics/search".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TopicResponse.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetCurrent (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetOauth2Application
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/applications/oauth2"
                                 + (if "/user/applications/oauth2".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> OAuth2Application.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCreateOAuth2Application
                (body : CreateOAuth2ApplicationOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/applications/oauth2", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateOAuth2ApplicationOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OAuth2Application.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetOAuth2Application (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/applications/oauth2/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OAuth2Application.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserDeleteOAuth2Application (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/applications/oauth2/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserUpdateOAuth2Application
                (id : int, body : CreateOAuth2ApplicationOptions, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/applications/oauth2/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateOAuth2ApplicationOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OAuth2Application.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListEmails (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/emails", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Email.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserAddEmail (body : CreateEmailOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/emails", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateEmailOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Email.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserDeleteEmail (body : DeleteEmailOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/emails", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> DeleteEmailOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListFollowers
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/followers"
                                 + (if "/user/followers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListFollowing
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/following"
                                 + (if "/user/following".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentCheckFollowing (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/following/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteFollow (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/following/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPutFollow (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/following/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetVerificationToken (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/gpg_key_token", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseString = response.Content.ReadAsStringAsync ct |> Async.AwaitTask
                    return responseString
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteGPGKey (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/gpg_keys/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListKeys
                (fingerprint : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/keys"
                                 + (if "/user/keys".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "fingerprint="
                                 + ((fingerprint.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PublicKey.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPostKey (body : CreateKeyOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/keys", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateKeyOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PublicKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentGetKey (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/keys/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return PublicKey.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteKey (id : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/keys/{id}"
                                    .Replace ("{id}", id.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListCurrentUserOrgs (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/orgs"
                                 + (if "/user/orgs".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListRepos (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/repos"
                                 + (if "/user/repos".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.CreateCurrentUserRepo (body : CreateRepoOption, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/repos", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateRepoOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return Repository.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetUserSettings (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/settings", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> UserSettings.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UpdateUserSettings (body : UserSettingsOptions, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/user/settings", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> UserSettingsOptions.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> UserSettings.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListStarred (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/starred"
                                 + (if "/user/starred".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentCheckStarring
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/starred/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentDeleteStar
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/starred/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentPutStar
                (owner : string, repo : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/user/starred/{owner}/{repo}"
                                    .Replace("{owner}", owner.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{repo}", repo.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Put,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetStopWatches (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/stopwatches"
                                 + (if "/user/stopwatches".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> StopWatch.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentListSubscriptions
                (page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/subscriptions"
                                 + (if "/user/subscriptions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListTeams (page : int, limit : int, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/teams"
                                 + (if "/user/teams".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> Team.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCurrentTrackedTimes
                (
                    page : int,
                    limit : int,
                    since : string,
                    before : string,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/user/times"
                                 + (if "/user/times".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&since="
                                 + ((since.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&before="
                                 + ((before.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> TrackedTime.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserSearch
                (q : string, uid : int, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/search"
                                 + (if "/users/search".IndexOf (char 63) >= 0 then "&" else "?")
                                 + "q="
                                 + ((q.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&uid="
                                 + ((uid.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGet (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/users/{username}"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return User.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListFollowers
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/followers"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/followers".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListFollowing
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/following"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/following".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return jsonNode.AsArray () |> Seq.map (fun elt -> User.jsonParse elt) |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCheckFollowing
                (username : string, target : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/users/{username}/following/{target}"
                                    .Replace("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{target}", target.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetHeatmapData (username : string, ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/users/{username}/heatmap"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> UserHeatmapData.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListKeys
                (
                    username : string,
                    fingerprint : string,
                    page : int,
                    limit : int,
                    ct : System.Threading.CancellationToken option
                )
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/keys"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/keys".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "fingerprint="
                                 + ((fingerprint.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> PublicKey.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgListUserOrgs
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/orgs"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/orgs".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Organization.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.OrgGetUserPermissions
                (username : string, org : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/users/{username}/orgs/{org}/permissions"
                                    .Replace("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{org}", org.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return OrganizationPermissions.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListRepos
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/repos"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/repos".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListStarred
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/starred"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/starred".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserListSubscriptions
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/subscriptions"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/subscriptions".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> Repository.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserGetTokens
                (username : string, page : int, limit : int, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                ("/users/{username}/tokens"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                 + (if "/users/{username}/tokens".IndexOf (char 63) >= 0 then
                                        "&"
                                    else
                                        "?")
                                 + "page="
                                 + ((page.ToString ()) |> System.Web.HttpUtility.UrlEncode)
                                 + "&limit="
                                 + ((limit.ToString ()) |> System.Web.HttpUtility.UrlEncode)),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return
                        jsonNode.AsArray ()
                        |> Seq.map (fun elt -> AccessToken.jsonParse elt)
                        |> List.ofSeq
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserCreateToken
                (username : string, body : CreateAccessTokenOption, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/users/{username}/tokens"
                                    .Replace ("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Post,
                            RequestUri = uri
                        )

                    let queryParams =
                        new System.Net.Http.StringContent (
                            body
                            |> CreateAccessTokenOption.toJsonNode
                            |> (fun node -> if isNull node then "null" else node.ToJsonString ())
                        )

                    do httpMessage.Content <- queryParams
                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return AccessToken.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.UserDeleteAccessToken
                (username : string, token : string, ct : System.Threading.CancellationToken option)
                =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri (
                                "/users/{username}/tokens/{token}"
                                    .Replace("{username}", username.ToString () |> System.Web.HttpUtility.UrlEncode)
                                    .Replace ("{token}", token.ToString () |> System.Web.HttpUtility.UrlEncode),
                                System.UriKind.Relative
                            )
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Delete,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ()
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))

            member _.GetVersion (ct : System.Threading.CancellationToken option) =
                async {
                    let! ct = Async.CancellationToken

                    let uri =
                        System.Uri (
                            System.Uri (
                                (match client.BaseAddress with
                                 | null ->
                                     raise (
                                         System.ArgumentNullException (
                                             nameof (client.BaseAddress),
                                             "No base address was supplied on the type, and no BaseAddress was on the HttpClient."
                                         )
                                     )
                                 | v -> v),
                                System.Uri ("/api/v1/", System.UriKind.Relative)
                            ),
                            System.Uri ("/version", System.UriKind.Relative)
                        )

                    let httpMessage =
                        new System.Net.Http.HttpRequestMessage (
                            Method = System.Net.Http.HttpMethod.Get,
                            RequestUri = uri
                        )

                    let! response = client.SendAsync (httpMessage, ct) |> Async.AwaitTask
                    let response = response.EnsureSuccessStatusCode ()
                    let! responseStream = response.Content.ReadAsStreamAsync ct |> Async.AwaitTask

                    let! jsonNode =
                        System.Text.Json.Nodes.JsonNode.ParseAsync (responseStream, cancellationToken = ct)
                        |> Async.AwaitTask

                    return ServerVersion.jsonParse jsonNode
                }
                |> (fun a -> Async.StartAsTask (a, ?cancellationToken = ct))
        }
