//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------






namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type BasicNoPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module BasicNoPositionals =
    type private ParseState_BasicNoPositionals =
        | AwaitingKey
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : BasicNoPositionals =
        let ArgParser_errors = ResizeArray ()

        let helpText () =
            [
                (sprintf "--foo  int32%s%s" "" "")
                (sprintf "--bar  string%s%s" "" "")
                (sprintf "--baz  bool%s%s" "" "")
                (sprintf "--rest  int32%s%s" " (can be repeated)" "")
            ]
            |> String.concat "\n"

        let parser_LeftoverArgs : string ResizeArray = ResizeArray ()
        let mutable arg_0 : int option = None
        let mutable arg_1 : string option = None
        let mutable arg_2 : bool option = None
        let arg_3 : int ResizeArray = ResizeArray ()

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        let processKeyValue (key : string) (value : string) : Result<unit, string option> =
            if System.String.Equals (key, "--rest", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Int32.Parse x) |> arg_3.Add
                () |> Ok
            else if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--baz" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--bar", System.StringComparison.OrdinalIgnoreCase) then
                match arg_1 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--bar" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_1 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--foo", System.StringComparison.OrdinalIgnoreCase) then
                match arg_0 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--foo" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

        /// Returns false if we didn't set a value.
        let setFlagValue (key : string) : bool =
            if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--baz" |> ArgParser_errors.Add
                    true
                | None ->
                    arg_2 <- Some true
                    true
            else
                false

        let rec go (state : ParseState_BasicNoPositionals) (args : string list) =
            match args with
            | [] ->
                match state with
                | ParseState_BasicNoPositionals.AwaitingKey -> ()
                | ParseState_BasicNoPositionals.AwaitingValue key ->
                    if setFlagValue key then
                        ()
                    else
                        sprintf
                            "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                            key
                        |> ArgParser_errors.Add
            | "--" :: rest -> parser_LeftoverArgs.AddRange (rest |> Seq.map (fun x -> x))
            | arg :: args ->
                match state with
                | ParseState_BasicNoPositionals.AwaitingKey ->
                    if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                        if arg = "--help" then
                            helpText () |> failwithf "Help text requested.\n%s"
                        else
                            let equals = arg.IndexOf (char 61)

                            if equals < 0 then
                                args |> go (ParseState_BasicNoPositionals.AwaitingValue arg)
                            else
                                let key = arg.[0 .. equals - 1]
                                let value = arg.[equals + 1 ..]

                                match processKeyValue key value with
                                | Ok () -> go ParseState_BasicNoPositionals.AwaitingKey args
                                | Error None ->
                                    failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                | Error (Some msg) ->
                                    sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                    go ParseState_BasicNoPositionals.AwaitingKey args
                    else
                        arg |> (fun x -> x) |> parser_LeftoverArgs.Add
                        go ParseState_BasicNoPositionals.AwaitingKey args
                | ParseState_BasicNoPositionals.AwaitingValue key ->
                    match processKeyValue key arg with
                    | Ok () -> go ParseState_BasicNoPositionals.AwaitingKey args
                    | Error exc ->
                        if setFlagValue key then
                            go ParseState_BasicNoPositionals.AwaitingKey (arg :: args)
                        else
                            match exc with
                            | None ->
                                failwithf "Unable to process supplied arg %s. Help text follows.\n%s" key (helpText ())
                            | Some msg -> msg |> ArgParser_errors.Add

        go ParseState_BasicNoPositionals.AwaitingKey args

        let parser_LeftoverArgs =
            if 0 = parser_LeftoverArgs.Count then
                ()
            else
                parser_LeftoverArgs
                |> String.concat " "
                |> sprintf "There were leftover args: %s"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>

        let arg_0 =
            match arg_0 with
            | None ->
                sprintf "Required argument '%s' received no value" "--foo"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_1 =
            match arg_1 with
            | None ->
                sprintf "Required argument '%s' received no value" "--bar"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_2 =
            match arg_2 with
            | None ->
                sprintf "Required argument '%s' received no value" "--baz"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_3 = arg_3 |> Seq.toList

        if 0 = ArgParser_errors.Count then
            {
                Bar = arg_1
                Baz = arg_2
                Foo = arg_0
                Rest = arg_3
            }
        else
            ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

    let parse (args : string list) : BasicNoPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type Basic
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module Basic =
    type private ParseState_Basic =
        | AwaitingKey
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : Basic =
        let ArgParser_errors = ResizeArray ()

        let helpText () =
            [
                (sprintf "--foo  int32%s%s" "" (sprintf " : %s" ("This is a foo!")))
                (sprintf "--bar  string%s%s" "" "")
                (sprintf "--baz  bool%s%s" "" "")
                (sprintf
                    "--rest  string%s%s"
                    " (positional args) (can be repeated)"
                    (sprintf " : %s" ("Here's where the rest of the args go")))
            ]
            |> String.concat "\n"

        let arg_3 : string ResizeArray = ResizeArray ()
        let mutable arg_0 : int option = None
        let mutable arg_1 : string option = None
        let mutable arg_2 : bool option = None

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        let processKeyValue (key : string) (value : string) : Result<unit, string option> =
            if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--baz" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--bar", System.StringComparison.OrdinalIgnoreCase) then
                match arg_1 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--bar" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_1 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--foo", System.StringComparison.OrdinalIgnoreCase) then
                match arg_0 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--foo" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--rest", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> x) |> arg_3.Add
                () |> Ok
            else
                Error None

        /// Returns false if we didn't set a value.
        let setFlagValue (key : string) : bool =
            if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--baz" |> ArgParser_errors.Add
                    true
                | None ->
                    arg_2 <- Some true
                    true
            else
                false

        let rec go (state : ParseState_Basic) (args : string list) =
            match args with
            | [] ->
                match state with
                | ParseState_Basic.AwaitingKey -> ()
                | ParseState_Basic.AwaitingValue key ->
                    if setFlagValue key then
                        ()
                    else
                        sprintf
                            "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                            key
                        |> ArgParser_errors.Add
            | "--" :: rest -> arg_3.AddRange (rest |> Seq.map (fun x -> x))
            | arg :: args ->
                match state with
                | ParseState_Basic.AwaitingKey ->
                    if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                        if arg = "--help" then
                            helpText () |> failwithf "Help text requested.\n%s"
                        else
                            let equals = arg.IndexOf (char 61)

                            if equals < 0 then
                                args |> go (ParseState_Basic.AwaitingValue arg)
                            else
                                let key = arg.[0 .. equals - 1]
                                let value = arg.[equals + 1 ..]

                                match processKeyValue key value with
                                | Ok () -> go ParseState_Basic.AwaitingKey args
                                | Error None ->
                                    failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                | Error (Some msg) ->
                                    sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                    go ParseState_Basic.AwaitingKey args
                    else
                        arg |> (fun x -> x) |> arg_3.Add
                        go ParseState_Basic.AwaitingKey args
                | ParseState_Basic.AwaitingValue key ->
                    match processKeyValue key arg with
                    | Ok () -> go ParseState_Basic.AwaitingKey args
                    | Error exc ->
                        if setFlagValue key then
                            go ParseState_Basic.AwaitingKey (arg :: args)
                        else
                            match exc with
                            | None ->
                                failwithf "Unable to process supplied arg %s. Help text follows.\n%s" key (helpText ())
                            | Some msg -> msg |> ArgParser_errors.Add

        go ParseState_Basic.AwaitingKey args
        let arg_3 = arg_3 |> Seq.toList

        let arg_0 =
            match arg_0 with
            | None ->
                sprintf "Required argument '%s' received no value" "--foo"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_1 =
            match arg_1 with
            | None ->
                sprintf "Required argument '%s' received no value" "--bar"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_2 =
            match arg_2 with
            | None ->
                sprintf "Required argument '%s' received no value" "--baz"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        if 0 = ArgParser_errors.Count then
            {
                Bar = arg_1
                Baz = arg_2
                Foo = arg_0
                Rest = arg_3
            }
        else
            ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

    let parse (args : string list) : Basic =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type BasicWithIntPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module BasicWithIntPositionals =
    type private ParseState_BasicWithIntPositionals =
        | AwaitingKey
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : BasicWithIntPositionals =
        let ArgParser_errors = ResizeArray ()

        let helpText () =
            [
                (sprintf "--foo  int32%s%s" "" "")
                (sprintf "--bar  string%s%s" "" "")
                (sprintf "--baz  bool%s%s" "" "")
                (sprintf "--rest  int32%s%s" " (positional args) (can be repeated)" "")
            ]
            |> String.concat "\n"

        let arg_3 : int ResizeArray = ResizeArray ()
        let mutable arg_0 : int option = None
        let mutable arg_1 : string option = None
        let mutable arg_2 : bool option = None

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        let processKeyValue (key : string) (value : string) : Result<unit, string option> =
            if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--baz" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--bar", System.StringComparison.OrdinalIgnoreCase) then
                match arg_1 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--bar" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_1 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--foo", System.StringComparison.OrdinalIgnoreCase) then
                match arg_0 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--foo" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--rest", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Int32.Parse x) |> arg_3.Add
                () |> Ok
            else
                Error None

        /// Returns false if we didn't set a value.
        let setFlagValue (key : string) : bool =
            if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--baz" |> ArgParser_errors.Add
                    true
                | None ->
                    arg_2 <- Some true
                    true
            else
                false

        let rec go (state : ParseState_BasicWithIntPositionals) (args : string list) =
            match args with
            | [] ->
                match state with
                | ParseState_BasicWithIntPositionals.AwaitingKey -> ()
                | ParseState_BasicWithIntPositionals.AwaitingValue key ->
                    if setFlagValue key then
                        ()
                    else
                        sprintf
                            "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                            key
                        |> ArgParser_errors.Add
            | "--" :: rest -> arg_3.AddRange (rest |> Seq.map (fun x -> System.Int32.Parse x))
            | arg :: args ->
                match state with
                | ParseState_BasicWithIntPositionals.AwaitingKey ->
                    if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                        if arg = "--help" then
                            helpText () |> failwithf "Help text requested.\n%s"
                        else
                            let equals = arg.IndexOf (char 61)

                            if equals < 0 then
                                args |> go (ParseState_BasicWithIntPositionals.AwaitingValue arg)
                            else
                                let key = arg.[0 .. equals - 1]
                                let value = arg.[equals + 1 ..]

                                match processKeyValue key value with
                                | Ok () -> go ParseState_BasicWithIntPositionals.AwaitingKey args
                                | Error None ->
                                    failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                | Error (Some msg) ->
                                    sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                    go ParseState_BasicWithIntPositionals.AwaitingKey args
                    else
                        arg |> (fun x -> System.Int32.Parse x) |> arg_3.Add
                        go ParseState_BasicWithIntPositionals.AwaitingKey args
                | ParseState_BasicWithIntPositionals.AwaitingValue key ->
                    match processKeyValue key arg with
                    | Ok () -> go ParseState_BasicWithIntPositionals.AwaitingKey args
                    | Error exc ->
                        if setFlagValue key then
                            go ParseState_BasicWithIntPositionals.AwaitingKey (arg :: args)
                        else
                            match exc with
                            | None ->
                                failwithf "Unable to process supplied arg %s. Help text follows.\n%s" key (helpText ())
                            | Some msg -> msg |> ArgParser_errors.Add

        go ParseState_BasicWithIntPositionals.AwaitingKey args
        let arg_3 = arg_3 |> Seq.toList

        let arg_0 =
            match arg_0 with
            | None ->
                sprintf "Required argument '%s' received no value" "--foo"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_1 =
            match arg_1 with
            | None ->
                sprintf "Required argument '%s' received no value" "--bar"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_2 =
            match arg_2 with
            | None ->
                sprintf "Required argument '%s' received no value" "--baz"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        if 0 = ArgParser_errors.Count then
            {
                Bar = arg_1
                Baz = arg_2
                Foo = arg_0
                Rest = arg_3
            }
        else
            ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

    let parse (args : string list) : BasicWithIntPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type LoadsOfTypes
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module LoadsOfTypes =
    type private ParseState_LoadsOfTypes =
        | AwaitingKey
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : LoadsOfTypes =
        let ArgParser_errors = ResizeArray ()

        let helpText () =
            [
                (sprintf "--foo  int32%s%s" "" "")
                (sprintf "--bar  string%s%s" "" "")
                (sprintf "--baz  bool%s%s" "" "")
                (sprintf "--some-file  FileInfo%s%s" "" "")
                (sprintf "--some-directory  DirectoryInfo%s%s" "" "")
                (sprintf "--some-list  DirectoryInfo%s%s" " (can be repeated)" "")
                (sprintf "--optional-thing-with-no-default  int32%s%s" " (optional)" "")

                (sprintf
                    "--optional-thing  bool%s%s"
                    (LoadsOfTypes.DefaultOptionalThing () |> sprintf " (default value: %O)")
                    "")

                (sprintf
                    "--another-optional-thing  int32%s%s"
                    (LoadsOfTypes.DefaultAnotherOptionalThing () |> sprintf " (default value: %O)")
                    "")

                (sprintf
                    "--yet-another-optional-thing  string%s%s"
                    ("CONSUMEPLUGIN_THINGS" |> sprintf " (default value populated from env var %s)")
                    "")
                (sprintf "--positionals  int32%s%s" " (positional args) (can be repeated)" "")
            ]
            |> String.concat "\n"

        let arg_7 : int ResizeArray = ResizeArray ()
        let mutable arg_0 : int option = None
        let mutable arg_1 : string option = None
        let mutable arg_2 : bool option = None
        let mutable arg_3 : FileInfo option = None
        let mutable arg_4 : DirectoryInfo option = None
        let arg_5 : DirectoryInfo ResizeArray = ResizeArray ()
        let mutable arg_6 : int option = None
        let mutable arg_8 : bool option = None
        let mutable arg_9 : int option = None
        let mutable arg_10 : string option = None

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        let processKeyValue (key : string) (value : string) : Result<unit, string option> =
            if
                System.String.Equals (key, "--yet-another-optional-thing", System.StringComparison.OrdinalIgnoreCase)
            then
                match arg_10 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %O and %O"
                        "--yet-another-optional-thing"
                        x
                        value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_10 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, "--another-optional-thing", System.StringComparison.OrdinalIgnoreCase)
            then
                match arg_9 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--another-optional-thing" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_9 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--optional-thing", System.StringComparison.OrdinalIgnoreCase) then
                match arg_8 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--optional-thing" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_8 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (
                    key,
                    "--optional-thing-with-no-default",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match arg_6 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %O and %O"
                        "--optional-thing-with-no-default"
                        x
                        value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_6 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--some-list", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.IO.DirectoryInfo x) |> arg_5.Add
                () |> Ok
            else if System.String.Equals (key, "--some-directory", System.StringComparison.OrdinalIgnoreCase) then
                match arg_4 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--some-directory" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_4 <- value |> (fun x -> System.IO.DirectoryInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--some-file", System.StringComparison.OrdinalIgnoreCase) then
                match arg_3 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--some-file" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_3 <- value |> (fun x -> System.IO.FileInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--baz" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--bar", System.StringComparison.OrdinalIgnoreCase) then
                match arg_1 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--bar" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_1 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--foo", System.StringComparison.OrdinalIgnoreCase) then
                match arg_0 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--foo" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--positionals", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Int32.Parse x) |> arg_7.Add
                () |> Ok
            else
                Error None

        /// Returns false if we didn't set a value.
        let setFlagValue (key : string) : bool =
            if System.String.Equals (key, "--optional-thing", System.StringComparison.OrdinalIgnoreCase) then
                match arg_8 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--optional-thing"
                    |> ArgParser_errors.Add

                    true
                | None ->
                    arg_8 <- Some true
                    true
            else if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--baz" |> ArgParser_errors.Add
                    true
                | None ->
                    arg_2 <- Some true
                    true
            else
                false

        let rec go (state : ParseState_LoadsOfTypes) (args : string list) =
            match args with
            | [] ->
                match state with
                | ParseState_LoadsOfTypes.AwaitingKey -> ()
                | ParseState_LoadsOfTypes.AwaitingValue key ->
                    if setFlagValue key then
                        ()
                    else
                        sprintf
                            "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                            key
                        |> ArgParser_errors.Add
            | "--" :: rest -> arg_7.AddRange (rest |> Seq.map (fun x -> System.Int32.Parse x))
            | arg :: args ->
                match state with
                | ParseState_LoadsOfTypes.AwaitingKey ->
                    if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                        if arg = "--help" then
                            helpText () |> failwithf "Help text requested.\n%s"
                        else
                            let equals = arg.IndexOf (char 61)

                            if equals < 0 then
                                args |> go (ParseState_LoadsOfTypes.AwaitingValue arg)
                            else
                                let key = arg.[0 .. equals - 1]
                                let value = arg.[equals + 1 ..]

                                match processKeyValue key value with
                                | Ok () -> go ParseState_LoadsOfTypes.AwaitingKey args
                                | Error None ->
                                    failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                | Error (Some msg) ->
                                    sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                    go ParseState_LoadsOfTypes.AwaitingKey args
                    else
                        arg |> (fun x -> System.Int32.Parse x) |> arg_7.Add
                        go ParseState_LoadsOfTypes.AwaitingKey args
                | ParseState_LoadsOfTypes.AwaitingValue key ->
                    match processKeyValue key arg with
                    | Ok () -> go ParseState_LoadsOfTypes.AwaitingKey args
                    | Error exc ->
                        if setFlagValue key then
                            go ParseState_LoadsOfTypes.AwaitingKey (arg :: args)
                        else
                            match exc with
                            | None ->
                                failwithf "Unable to process supplied arg %s. Help text follows.\n%s" key (helpText ())
                            | Some msg -> msg |> ArgParser_errors.Add

        go ParseState_LoadsOfTypes.AwaitingKey args
        let arg_7 = arg_7 |> Seq.toList

        let arg_0 =
            match arg_0 with
            | None ->
                sprintf "Required argument '%s' received no value" "--foo"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_1 =
            match arg_1 with
            | None ->
                sprintf "Required argument '%s' received no value" "--bar"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_2 =
            match arg_2 with
            | None ->
                sprintf "Required argument '%s' received no value" "--baz"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_3 =
            match arg_3 with
            | None ->
                sprintf "Required argument '%s' received no value" "--some-file"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_4 =
            match arg_4 with
            | None ->
                sprintf "Required argument '%s' received no value" "--some-directory"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_5 = arg_5 |> Seq.toList
        let arg_6 = arg_6

        let arg_8 =
            match arg_8 with
            | None -> LoadsOfTypes.DefaultOptionalThing () |> Choice2Of2
            | Some x -> Choice1Of2 x

        let arg_9 =
            match arg_9 with
            | None -> LoadsOfTypes.DefaultAnotherOptionalThing () |> Choice2Of2
            | Some x -> Choice1Of2 x

        let arg_10 =
            match arg_10 with
            | None ->
                match "CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable with
                | null ->
                    sprintf
                        "No value was supplied for %s, nor was environment variable %s set"
                        "--yet-another-optional-thing"
                        "CONSUMEPLUGIN_THINGS"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | x -> x |> (fun x -> x)
                |> Choice2Of2
            | Some x -> Choice1Of2 x

        if 0 = ArgParser_errors.Count then
            {
                AnotherOptionalThing = arg_9
                Bar = arg_1
                Baz = arg_2
                Foo = arg_0
                OptionalThing = arg_8
                OptionalThingWithNoDefault = arg_6
                Positionals = arg_7
                SomeDirectory = arg_4
                SomeFile = arg_3
                SomeList = arg_5
                YetAnotherOptionalThing = arg_10
            }
        else
            ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

    let parse (args : string list) : LoadsOfTypes =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type LoadsOfTypesNoPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module LoadsOfTypesNoPositionals =
    type private ParseState_LoadsOfTypesNoPositionals =
        | AwaitingKey
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : LoadsOfTypesNoPositionals =
        let ArgParser_errors = ResizeArray ()

        let helpText () =
            [
                (sprintf "--foo  int32%s%s" "" "")
                (sprintf "--bar  string%s%s" "" "")
                (sprintf "--baz  bool%s%s" "" "")
                (sprintf "--some-file  FileInfo%s%s" "" "")
                (sprintf "--some-directory  DirectoryInfo%s%s" "" "")
                (sprintf "--some-list  DirectoryInfo%s%s" " (can be repeated)" "")
                (sprintf "--optional-thing-with-no-default  int32%s%s" " (optional)" "")

                (sprintf
                    "--optional-thing  bool%s%s"
                    (LoadsOfTypesNoPositionals.DefaultOptionalThing ()
                     |> sprintf " (default value: %O)")
                    "")

                (sprintf
                    "--another-optional-thing  int32%s%s"
                    (LoadsOfTypesNoPositionals.DefaultAnotherOptionalThing ()
                     |> sprintf " (default value: %O)")
                    "")
                (sprintf
                    "--yet-another-optional-thing  string%s%s"
                    ("CONSUMEPLUGIN_THINGS" |> sprintf " (default value populated from env var %s)")
                    "")
            ]
            |> String.concat "\n"

        let parser_LeftoverArgs : string ResizeArray = ResizeArray ()
        let mutable arg_0 : int option = None
        let mutable arg_1 : string option = None
        let mutable arg_2 : bool option = None
        let mutable arg_3 : FileInfo option = None
        let mutable arg_4 : DirectoryInfo option = None
        let arg_5 : DirectoryInfo ResizeArray = ResizeArray ()
        let mutable arg_6 : int option = None
        let mutable arg_7 : bool option = None
        let mutable arg_8 : int option = None
        let mutable arg_9 : string option = None

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        let processKeyValue (key : string) (value : string) : Result<unit, string option> =
            if
                System.String.Equals (key, "--yet-another-optional-thing", System.StringComparison.OrdinalIgnoreCase)
            then
                match arg_9 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %O and %O"
                        "--yet-another-optional-thing"
                        x
                        value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_9 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, "--another-optional-thing", System.StringComparison.OrdinalIgnoreCase)
            then
                match arg_8 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--another-optional-thing" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_8 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--optional-thing", System.StringComparison.OrdinalIgnoreCase) then
                match arg_7 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--optional-thing" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_7 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (
                    key,
                    "--optional-thing-with-no-default",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match arg_6 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %O and %O"
                        "--optional-thing-with-no-default"
                        x
                        value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_6 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--some-list", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.IO.DirectoryInfo x) |> arg_5.Add
                () |> Ok
            else if System.String.Equals (key, "--some-directory", System.StringComparison.OrdinalIgnoreCase) then
                match arg_4 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--some-directory" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_4 <- value |> (fun x -> System.IO.DirectoryInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--some-file", System.StringComparison.OrdinalIgnoreCase) then
                match arg_3 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--some-file" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_3 <- value |> (fun x -> System.IO.FileInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--baz" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--bar", System.StringComparison.OrdinalIgnoreCase) then
                match arg_1 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--bar" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_1 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, "--foo", System.StringComparison.OrdinalIgnoreCase) then
                match arg_0 with
                | Some x ->
                    sprintf "Argument '%s' was supplied multiple times: %O and %O" "--foo" x value
                    |> ArgParser_errors.Add

                    Ok ()
                | None ->
                    try
                        arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

        /// Returns false if we didn't set a value.
        let setFlagValue (key : string) : bool =
            if System.String.Equals (key, "--optional-thing", System.StringComparison.OrdinalIgnoreCase) then
                match arg_7 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--optional-thing"
                    |> ArgParser_errors.Add

                    true
                | None ->
                    arg_7 <- Some true
                    true
            else if System.String.Equals (key, "--baz", System.StringComparison.OrdinalIgnoreCase) then
                match arg_2 with
                | Some x ->
                    sprintf "Flag '%s' was supplied multiple times" "--baz" |> ArgParser_errors.Add
                    true
                | None ->
                    arg_2 <- Some true
                    true
            else
                false

        let rec go (state : ParseState_LoadsOfTypesNoPositionals) (args : string list) =
            match args with
            | [] ->
                match state with
                | ParseState_LoadsOfTypesNoPositionals.AwaitingKey -> ()
                | ParseState_LoadsOfTypesNoPositionals.AwaitingValue key ->
                    if setFlagValue key then
                        ()
                    else
                        sprintf
                            "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                            key
                        |> ArgParser_errors.Add
            | "--" :: rest -> parser_LeftoverArgs.AddRange (rest |> Seq.map (fun x -> x))
            | arg :: args ->
                match state with
                | ParseState_LoadsOfTypesNoPositionals.AwaitingKey ->
                    if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                        if arg = "--help" then
                            helpText () |> failwithf "Help text requested.\n%s"
                        else
                            let equals = arg.IndexOf (char 61)

                            if equals < 0 then
                                args |> go (ParseState_LoadsOfTypesNoPositionals.AwaitingValue arg)
                            else
                                let key = arg.[0 .. equals - 1]
                                let value = arg.[equals + 1 ..]

                                match processKeyValue key value with
                                | Ok () -> go ParseState_LoadsOfTypesNoPositionals.AwaitingKey args
                                | Error None ->
                                    failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                | Error (Some msg) ->
                                    sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                    go ParseState_LoadsOfTypesNoPositionals.AwaitingKey args
                    else
                        arg |> (fun x -> x) |> parser_LeftoverArgs.Add
                        go ParseState_LoadsOfTypesNoPositionals.AwaitingKey args
                | ParseState_LoadsOfTypesNoPositionals.AwaitingValue key ->
                    match processKeyValue key arg with
                    | Ok () -> go ParseState_LoadsOfTypesNoPositionals.AwaitingKey args
                    | Error exc ->
                        if setFlagValue key then
                            go ParseState_LoadsOfTypesNoPositionals.AwaitingKey (arg :: args)
                        else
                            match exc with
                            | None ->
                                failwithf "Unable to process supplied arg %s. Help text follows.\n%s" key (helpText ())
                            | Some msg -> msg |> ArgParser_errors.Add

        go ParseState_LoadsOfTypesNoPositionals.AwaitingKey args

        let parser_LeftoverArgs =
            if 0 = parser_LeftoverArgs.Count then
                ()
            else
                parser_LeftoverArgs
                |> String.concat " "
                |> sprintf "There were leftover args: %s"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>

        let arg_0 =
            match arg_0 with
            | None ->
                sprintf "Required argument '%s' received no value" "--foo"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_1 =
            match arg_1 with
            | None ->
                sprintf "Required argument '%s' received no value" "--bar"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_2 =
            match arg_2 with
            | None ->
                sprintf "Required argument '%s' received no value" "--baz"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_3 =
            match arg_3 with
            | None ->
                sprintf "Required argument '%s' received no value" "--some-file"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_4 =
            match arg_4 with
            | None ->
                sprintf "Required argument '%s' received no value" "--some-directory"
                |> ArgParser_errors.Add

                Unchecked.defaultof<_>
            | Some x -> x

        let arg_5 = arg_5 |> Seq.toList
        let arg_6 = arg_6

        let arg_7 =
            match arg_7 with
            | None -> LoadsOfTypesNoPositionals.DefaultOptionalThing () |> Choice2Of2
            | Some x -> Choice1Of2 x

        let arg_8 =
            match arg_8 with
            | None -> LoadsOfTypesNoPositionals.DefaultAnotherOptionalThing () |> Choice2Of2
            | Some x -> Choice1Of2 x

        let arg_9 =
            match arg_9 with
            | None ->
                match "CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable with
                | null ->
                    sprintf
                        "No value was supplied for %s, nor was environment variable %s set"
                        "--yet-another-optional-thing"
                        "CONSUMEPLUGIN_THINGS"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | x -> x |> (fun x -> x)
                |> Choice2Of2
            | Some x -> Choice1Of2 x

        if 0 = ArgParser_errors.Count then
            {
                AnotherOptionalThing = arg_8
                Bar = arg_1
                Baz = arg_2
                Foo = arg_0
                OptionalThing = arg_7
                OptionalThingWithNoDefault = arg_6
                SomeDirectory = arg_4
                SomeFile = arg_3
                SomeList = arg_5
                YetAnotherOptionalThing = arg_9
            }
        else
            ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

    let parse (args : string list) : LoadsOfTypesNoPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type DatesAndTimes
[<AutoOpen>]
module DatesAndTimesArgParse =
    type private ParseState_DatesAndTimes =
        | AwaitingKey
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type DatesAndTimes with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : DatesAndTimes =
            let ArgParser_errors = ResizeArray ()

            let helpText () =
                [
                    (sprintf "--plain  TimeSpan%s%s" "" "")
                    (sprintf "--invariant  TimeSpan%s%s" "" "")

                    (sprintf
                        "--exact  TimeSpan%s%s"
                        ""
                        (sprintf " : %s" (sprintf "%s [Parse format (.NET): %s]" "An exact time please" @"hh\:mm\:ss")))
                    (sprintf
                        "--invariant-exact  TimeSpan%s%s"
                        ""
                        (sprintf " : %s" (sprintf "[Parse format (.NET): %s]" @"hh\:mm\:ss")))
                ]
                |> String.concat "\n"

            let parser_LeftoverArgs : string ResizeArray = ResizeArray ()
            let mutable arg_0 : TimeSpan option = None
            let mutable arg_1 : TimeSpan option = None
            let mutable arg_2 : TimeSpan option = None
            let mutable arg_3 : TimeSpan option = None

            /// Processes the key-value pair, returning Error if no key was matched.
            /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
            /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
            let processKeyValue (key : string) (value : string) : Result<unit, string option> =
                if System.String.Equals (key, "--invariant-exact", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_3 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--invariant-exact" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_3 <-
                                value
                                |> (fun x ->
                                    System.TimeSpan.ParseExact (
                                        x,
                                        @"hh\:mm\:ss",
                                        System.Globalization.CultureInfo.InvariantCulture
                                    )
                                )
                                |> Some

                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--exact", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_2 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--exact" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_2 <-
                                value
                                |> (fun x ->
                                    System.TimeSpan.ParseExact (
                                        x,
                                        @"hh\:mm\:ss",
                                        System.Globalization.CultureInfo.CurrentCulture
                                    )
                                )
                                |> Some

                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--invariant", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_1 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--invariant" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_1 <-
                                value
                                |> (fun x ->
                                    System.TimeSpan.Parse (x, System.Globalization.CultureInfo.InvariantCulture)
                                )
                                |> Some

                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--plain", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_0 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--plain" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_0 <- value |> (fun x -> System.TimeSpan.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else
                    Error None

            /// Returns false if we didn't set a value.
            let setFlagValue (key : string) : bool = false

            let rec go (state : ParseState_DatesAndTimes) (args : string list) =
                match args with
                | [] ->
                    match state with
                    | ParseState_DatesAndTimes.AwaitingKey -> ()
                    | ParseState_DatesAndTimes.AwaitingValue key ->
                        if setFlagValue key then
                            ()
                        else
                            sprintf
                                "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                                key
                            |> ArgParser_errors.Add
                | "--" :: rest -> parser_LeftoverArgs.AddRange (rest |> Seq.map (fun x -> x))
                | arg :: args ->
                    match state with
                    | ParseState_DatesAndTimes.AwaitingKey ->
                        if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                            if arg = "--help" then
                                helpText () |> failwithf "Help text requested.\n%s"
                            else
                                let equals = arg.IndexOf (char 61)

                                if equals < 0 then
                                    args |> go (ParseState_DatesAndTimes.AwaitingValue arg)
                                else
                                    let key = arg.[0 .. equals - 1]
                                    let value = arg.[equals + 1 ..]

                                    match processKeyValue key value with
                                    | Ok () -> go ParseState_DatesAndTimes.AwaitingKey args
                                    | Error None ->
                                        failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                    | Error (Some msg) ->
                                        sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                        go ParseState_DatesAndTimes.AwaitingKey args
                        else
                            arg |> (fun x -> x) |> parser_LeftoverArgs.Add
                            go ParseState_DatesAndTimes.AwaitingKey args
                    | ParseState_DatesAndTimes.AwaitingValue key ->
                        match processKeyValue key arg with
                        | Ok () -> go ParseState_DatesAndTimes.AwaitingKey args
                        | Error exc ->
                            if setFlagValue key then
                                go ParseState_DatesAndTimes.AwaitingKey (arg :: args)
                            else
                                match exc with
                                | None ->
                                    failwithf
                                        "Unable to process supplied arg %s. Help text follows.\n%s"
                                        key
                                        (helpText ())
                                | Some msg -> msg |> ArgParser_errors.Add

            go ParseState_DatesAndTimes.AwaitingKey args

            let parser_LeftoverArgs =
                if 0 = parser_LeftoverArgs.Count then
                    ()
                else
                    parser_LeftoverArgs
                    |> String.concat " "
                    |> sprintf "There were leftover args: %s"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>

            let arg_0 =
                match arg_0 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--plain"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_1 =
                match arg_1 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--invariant"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_2 =
                match arg_2 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--exact"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_3 =
                match arg_3 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--invariant-exact"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            if 0 = ArgParser_errors.Count then
                {
                    Exact = arg_2
                    Invariant = arg_1
                    InvariantExact = arg_3
                    Plain = arg_0
                }
            else
                ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

        static member parse (args : string list) : DatesAndTimes =
            DatesAndTimes.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecord
[<AutoOpen>]
module ParentRecordArgParse =
    type private ParseState_ParentRecord =
        | AwaitingKey
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecord with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecord =
            let ArgParser_errors = ResizeArray ()

            let helpText () =
                [
                    (sprintf "--thing1  int32%s%s" "" "")
                    (sprintf "--thing2  string%s%s" "" "")
                    (sprintf "--and-another  bool%s%s" "" "")
                ]
                |> String.concat "\n"

            let parser_LeftoverArgs : string ResizeArray = ResizeArray ()
            let mutable arg_0 : int option = None
            let mutable arg_1 : string option = None
            let mutable arg_2 : bool option = None

            /// Processes the key-value pair, returning Error if no key was matched.
            /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
            /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
            let processKeyValue (key : string) (value : string) : Result<unit, string option> =
                if System.String.Equals (key, "--and-another", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_2 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--and-another" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--thing2", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_1 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--thing2" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_1 <- value |> (fun x -> x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--thing1", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_0 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--thing1" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else
                    Error None

            /// Returns false if we didn't set a value.
            let setFlagValue (key : string) : bool =
                if System.String.Equals (key, "--and-another", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_2 with
                    | Some x ->
                        sprintf "Flag '%s' was supplied multiple times" "--and-another"
                        |> ArgParser_errors.Add

                        true
                    | None ->
                        arg_2 <- Some true
                        true
                else
                    false

            let rec go (state : ParseState_ParentRecord) (args : string list) =
                match args with
                | [] ->
                    match state with
                    | ParseState_ParentRecord.AwaitingKey -> ()
                    | ParseState_ParentRecord.AwaitingValue key ->
                        if setFlagValue key then
                            ()
                        else
                            sprintf
                                "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                                key
                            |> ArgParser_errors.Add
                | "--" :: rest -> parser_LeftoverArgs.AddRange (rest |> Seq.map (fun x -> x))
                | arg :: args ->
                    match state with
                    | ParseState_ParentRecord.AwaitingKey ->
                        if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                            if arg = "--help" then
                                helpText () |> failwithf "Help text requested.\n%s"
                            else
                                let equals = arg.IndexOf (char 61)

                                if equals < 0 then
                                    args |> go (ParseState_ParentRecord.AwaitingValue arg)
                                else
                                    let key = arg.[0 .. equals - 1]
                                    let value = arg.[equals + 1 ..]

                                    match processKeyValue key value with
                                    | Ok () -> go ParseState_ParentRecord.AwaitingKey args
                                    | Error None ->
                                        failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                    | Error (Some msg) ->
                                        sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                        go ParseState_ParentRecord.AwaitingKey args
                        else
                            arg |> (fun x -> x) |> parser_LeftoverArgs.Add
                            go ParseState_ParentRecord.AwaitingKey args
                    | ParseState_ParentRecord.AwaitingValue key ->
                        match processKeyValue key arg with
                        | Ok () -> go ParseState_ParentRecord.AwaitingKey args
                        | Error exc ->
                            if setFlagValue key then
                                go ParseState_ParentRecord.AwaitingKey (arg :: args)
                            else
                                match exc with
                                | None ->
                                    failwithf
                                        "Unable to process supplied arg %s. Help text follows.\n%s"
                                        key
                                        (helpText ())
                                | Some msg -> msg |> ArgParser_errors.Add

            go ParseState_ParentRecord.AwaitingKey args

            let parser_LeftoverArgs =
                if 0 = parser_LeftoverArgs.Count then
                    ()
                else
                    parser_LeftoverArgs
                    |> String.concat " "
                    |> sprintf "There were leftover args: %s"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>

            let arg_0 =
                match arg_0 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--thing1"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_1 =
                match arg_1 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--thing2"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_2 =
                match arg_2 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--and-another"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            if 0 = ArgParser_errors.Count then
                {
                    AndAnother = arg_2
                    Child =
                        {
                            Thing1 = arg_0
                            Thing2 = arg_1
                        }
                }
            else
                ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

        static member parse (args : string list) : ParentRecord =
            ParentRecord.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecordChildPos
[<AutoOpen>]
module ParentRecordChildPosArgParse =
    type private ParseState_ParentRecordChildPos =
        | AwaitingKey
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecordChildPos with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecordChildPos =
            let ArgParser_errors = ResizeArray ()

            let helpText () =
                [
                    (sprintf "--and-another  bool%s%s" "" "")
                    (sprintf "--thing1  int32%s%s" "" "")
                    (sprintf "--thing2  URI%s%s" " (positional args) (can be repeated)" "")
                ]
                |> String.concat "\n"

            let arg_1 : Uri ResizeArray = ResizeArray ()
            let mutable arg_2 : bool option = None
            let mutable arg_0 : int option = None

            /// Processes the key-value pair, returning Error if no key was matched.
            /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
            /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
            let processKeyValue (key : string) (value : string) : Result<unit, string option> =
                if System.String.Equals (key, "--thing1", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_0 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--thing1" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--and-another", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_2 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--and-another" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_2 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--thing2", System.StringComparison.OrdinalIgnoreCase) then
                    value |> (fun x -> System.Uri x) |> arg_1.Add
                    () |> Ok
                else
                    Error None

            /// Returns false if we didn't set a value.
            let setFlagValue (key : string) : bool =
                if System.String.Equals (key, "--and-another", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_2 with
                    | Some x ->
                        sprintf "Flag '%s' was supplied multiple times" "--and-another"
                        |> ArgParser_errors.Add

                        true
                    | None ->
                        arg_2 <- Some true
                        true
                else
                    false

            let rec go (state : ParseState_ParentRecordChildPos) (args : string list) =
                match args with
                | [] ->
                    match state with
                    | ParseState_ParentRecordChildPos.AwaitingKey -> ()
                    | ParseState_ParentRecordChildPos.AwaitingValue key ->
                        if setFlagValue key then
                            ()
                        else
                            sprintf
                                "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                                key
                            |> ArgParser_errors.Add
                | "--" :: rest -> arg_1.AddRange (rest |> Seq.map (fun x -> System.Uri x))
                | arg :: args ->
                    match state with
                    | ParseState_ParentRecordChildPos.AwaitingKey ->
                        if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                            if arg = "--help" then
                                helpText () |> failwithf "Help text requested.\n%s"
                            else
                                let equals = arg.IndexOf (char 61)

                                if equals < 0 then
                                    args |> go (ParseState_ParentRecordChildPos.AwaitingValue arg)
                                else
                                    let key = arg.[0 .. equals - 1]
                                    let value = arg.[equals + 1 ..]

                                    match processKeyValue key value with
                                    | Ok () -> go ParseState_ParentRecordChildPos.AwaitingKey args
                                    | Error None ->
                                        failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                    | Error (Some msg) ->
                                        sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                        go ParseState_ParentRecordChildPos.AwaitingKey args
                        else
                            arg |> (fun x -> System.Uri x) |> arg_1.Add
                            go ParseState_ParentRecordChildPos.AwaitingKey args
                    | ParseState_ParentRecordChildPos.AwaitingValue key ->
                        match processKeyValue key arg with
                        | Ok () -> go ParseState_ParentRecordChildPos.AwaitingKey args
                        | Error exc ->
                            if setFlagValue key then
                                go ParseState_ParentRecordChildPos.AwaitingKey (arg :: args)
                            else
                                match exc with
                                | None ->
                                    failwithf
                                        "Unable to process supplied arg %s. Help text follows.\n%s"
                                        key
                                        (helpText ())
                                | Some msg -> msg |> ArgParser_errors.Add

            go ParseState_ParentRecordChildPos.AwaitingKey args
            let arg_1 = arg_1 |> Seq.toList

            let arg_2 =
                match arg_2 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--and-another"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_0 =
                match arg_0 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--thing1"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            if 0 = ArgParser_errors.Count then
                {
                    AndAnother = arg_2
                    Child =
                        {
                            Thing1 = arg_0
                            Thing2 = arg_1
                        }
                }
            else
                ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

        static member parse (args : string list) : ParentRecordChildPos =
            ParentRecordChildPos.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecordSelfPos
[<AutoOpen>]
module ParentRecordSelfPosArgParse =
    type private ParseState_ParentRecordSelfPos =
        | AwaitingKey
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecordSelfPos with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecordSelfPos =
            let ArgParser_errors = ResizeArray ()

            let helpText () =
                [
                    (sprintf "--thing1  int32%s%s" "" "")
                    (sprintf "--thing2  string%s%s" "" "")
                    (sprintf "--and-another  bool%s%s" " (positional args) (can be repeated)" "")
                ]
                |> String.concat "\n"

            let arg_2 : bool ResizeArray = ResizeArray ()
            let mutable arg_0 : int option = None
            let mutable arg_1 : string option = None

            /// Processes the key-value pair, returning Error if no key was matched.
            /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
            /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
            let processKeyValue (key : string) (value : string) : Result<unit, string option> =
                if System.String.Equals (key, "--thing2", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_1 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--thing2" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_1 <- value |> (fun x -> x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--thing1", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_0 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--thing1" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_0 <- value |> (fun x -> System.Int32.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else if System.String.Equals (key, "--and-another", System.StringComparison.OrdinalIgnoreCase) then
                    value |> (fun x -> System.Boolean.Parse x) |> arg_2.Add
                    () |> Ok
                else
                    Error None

            /// Returns false if we didn't set a value.
            let setFlagValue (key : string) : bool = false

            let rec go (state : ParseState_ParentRecordSelfPos) (args : string list) =
                match args with
                | [] ->
                    match state with
                    | ParseState_ParentRecordSelfPos.AwaitingKey -> ()
                    | ParseState_ParentRecordSelfPos.AwaitingValue key ->
                        if setFlagValue key then
                            ()
                        else
                            sprintf
                                "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                                key
                            |> ArgParser_errors.Add
                | "--" :: rest -> arg_2.AddRange (rest |> Seq.map (fun x -> System.Boolean.Parse x))
                | arg :: args ->
                    match state with
                    | ParseState_ParentRecordSelfPos.AwaitingKey ->
                        if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                            if arg = "--help" then
                                helpText () |> failwithf "Help text requested.\n%s"
                            else
                                let equals = arg.IndexOf (char 61)

                                if equals < 0 then
                                    args |> go (ParseState_ParentRecordSelfPos.AwaitingValue arg)
                                else
                                    let key = arg.[0 .. equals - 1]
                                    let value = arg.[equals + 1 ..]

                                    match processKeyValue key value with
                                    | Ok () -> go ParseState_ParentRecordSelfPos.AwaitingKey args
                                    | Error None ->
                                        failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                    | Error (Some msg) ->
                                        sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                        go ParseState_ParentRecordSelfPos.AwaitingKey args
                        else
                            arg |> (fun x -> System.Boolean.Parse x) |> arg_2.Add
                            go ParseState_ParentRecordSelfPos.AwaitingKey args
                    | ParseState_ParentRecordSelfPos.AwaitingValue key ->
                        match processKeyValue key arg with
                        | Ok () -> go ParseState_ParentRecordSelfPos.AwaitingKey args
                        | Error exc ->
                            if setFlagValue key then
                                go ParseState_ParentRecordSelfPos.AwaitingKey (arg :: args)
                            else
                                match exc with
                                | None ->
                                    failwithf
                                        "Unable to process supplied arg %s. Help text follows.\n%s"
                                        key
                                        (helpText ())
                                | Some msg -> msg |> ArgParser_errors.Add

            go ParseState_ParentRecordSelfPos.AwaitingKey args
            let arg_2 = arg_2 |> Seq.toList

            let arg_0 =
                match arg_0 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--thing1"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            let arg_1 =
                match arg_1 with
                | None ->
                    sprintf "Required argument '%s' received no value" "--thing2"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>
                | Some x -> x

            if 0 = ArgParser_errors.Count then
                {
                    AndAnother = arg_2
                    Child =
                        {
                            Thing1 = arg_0
                            Thing2 = arg_1
                        }
                }
            else
                ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

        static member parse (args : string list) : ParentRecordSelfPos =
            ParentRecordSelfPos.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ChoicePositionals
[<AutoOpen>]
module ChoicePositionalsArgParse =
    type private ParseState_ChoicePositionals =
        | AwaitingKey
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ChoicePositionals with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ChoicePositionals =
            let ArgParser_errors = ResizeArray ()

            let helpText () =
                [ (sprintf "--args  string%s%s" " (positional args) (can be repeated)" "") ]
                |> String.concat "\n"

            let arg_0 : Choice<string, string> ResizeArray = ResizeArray ()

            /// Processes the key-value pair, returning Error if no key was matched.
            /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
            /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
            let processKeyValue (key : string) (value : string) : Result<unit, string option> =
                if System.String.Equals (key, "--args", System.StringComparison.OrdinalIgnoreCase) then
                    value |> (fun x -> x) |> Choice1Of2 |> arg_0.Add
                    () |> Ok
                else
                    Error None

            /// Returns false if we didn't set a value.
            let setFlagValue (key : string) : bool = false

            let rec go (state : ParseState_ChoicePositionals) (args : string list) =
                match args with
                | [] ->
                    match state with
                    | ParseState_ChoicePositionals.AwaitingKey -> ()
                    | ParseState_ChoicePositionals.AwaitingValue key ->
                        if setFlagValue key then
                            ()
                        else
                            sprintf
                                "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                                key
                            |> ArgParser_errors.Add
                | "--" :: rest -> arg_0.AddRange (rest |> Seq.map (fun x -> x) |> Seq.map Choice2Of2)
                | arg :: args ->
                    match state with
                    | ParseState_ChoicePositionals.AwaitingKey ->
                        if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                            if arg = "--help" then
                                helpText () |> failwithf "Help text requested.\n%s"
                            else
                                let equals = arg.IndexOf (char 61)

                                if equals < 0 then
                                    args |> go (ParseState_ChoicePositionals.AwaitingValue arg)
                                else
                                    let key = arg.[0 .. equals - 1]
                                    let value = arg.[equals + 1 ..]

                                    match processKeyValue key value with
                                    | Ok () -> go ParseState_ChoicePositionals.AwaitingKey args
                                    | Error None ->
                                        failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                    | Error (Some msg) ->
                                        sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                        go ParseState_ChoicePositionals.AwaitingKey args
                        else
                            arg |> (fun x -> x) |> Choice1Of2 |> arg_0.Add
                            go ParseState_ChoicePositionals.AwaitingKey args
                    | ParseState_ChoicePositionals.AwaitingValue key ->
                        match processKeyValue key arg with
                        | Ok () -> go ParseState_ChoicePositionals.AwaitingKey args
                        | Error exc ->
                            if setFlagValue key then
                                go ParseState_ChoicePositionals.AwaitingKey (arg :: args)
                            else
                                match exc with
                                | None ->
                                    failwithf
                                        "Unable to process supplied arg %s. Help text follows.\n%s"
                                        key
                                        (helpText ())
                                | Some msg -> msg |> ArgParser_errors.Add

            go ParseState_ChoicePositionals.AwaitingKey args
            let arg_0 = arg_0 |> Seq.toList

            if 0 = ArgParser_errors.Count then
                {
                    Args = arg_0
                }
            else
                ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

        static member parse (args : string list) : ChoicePositionals =
            ChoicePositionals.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsBoolEnvVar
[<AutoOpen>]
module ContainsBoolEnvVarArgParse =
    type private ParseState_ContainsBoolEnvVar =
        | AwaitingKey
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsBoolEnvVar with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ContainsBoolEnvVar =
            let ArgParser_errors = ResizeArray ()

            let helpText () =
                [
                    (sprintf
                        "--bool-var  bool%s%s"
                        ("CONSUMEPLUGIN_THINGS" |> sprintf " (default value populated from env var %s)")
                        "")
                ]
                |> String.concat "\n"

            let parser_LeftoverArgs : string ResizeArray = ResizeArray ()
            let mutable arg_0 : bool option = None

            /// Processes the key-value pair, returning Error if no key was matched.
            /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
            /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
            let processKeyValue (key : string) (value : string) : Result<unit, string option> =
                if System.String.Equals (key, "--bool-var", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_0 with
                    | Some x ->
                        sprintf "Argument '%s' was supplied multiple times: %O and %O" "--bool-var" x value
                        |> ArgParser_errors.Add

                        Ok ()
                    | None ->
                        try
                            arg_0 <- value |> (fun x -> System.Boolean.Parse x) |> Some
                            Ok ()
                        with _ as exc ->
                            exc.Message |> Some |> Error
                else
                    Error None

            /// Returns false if we didn't set a value.
            let setFlagValue (key : string) : bool =
                if System.String.Equals (key, "--bool-var", System.StringComparison.OrdinalIgnoreCase) then
                    match arg_0 with
                    | Some x ->
                        sprintf "Flag '%s' was supplied multiple times" "--bool-var"
                        |> ArgParser_errors.Add

                        true
                    | None ->
                        arg_0 <- Some true
                        true
                else
                    false

            let rec go (state : ParseState_ContainsBoolEnvVar) (args : string list) =
                match args with
                | [] ->
                    match state with
                    | ParseState_ContainsBoolEnvVar.AwaitingKey -> ()
                    | ParseState_ContainsBoolEnvVar.AwaitingValue key ->
                        if setFlagValue key then
                            ()
                        else
                            sprintf
                                "Trailing argument %s had no value. Use a double-dash to separate positional args from key-value args."
                                key
                            |> ArgParser_errors.Add
                | "--" :: rest -> parser_LeftoverArgs.AddRange (rest |> Seq.map (fun x -> x))
                | arg :: args ->
                    match state with
                    | ParseState_ContainsBoolEnvVar.AwaitingKey ->
                        if arg.StartsWith ("--", System.StringComparison.Ordinal) then
                            if arg = "--help" then
                                helpText () |> failwithf "Help text requested.\n%s"
                            else
                                let equals = arg.IndexOf (char 61)

                                if equals < 0 then
                                    args |> go (ParseState_ContainsBoolEnvVar.AwaitingValue arg)
                                else
                                    let key = arg.[0 .. equals - 1]
                                    let value = arg.[equals + 1 ..]

                                    match processKeyValue key value with
                                    | Ok () -> go ParseState_ContainsBoolEnvVar.AwaitingKey args
                                    | Error None ->
                                        failwithf "Unable to process argument %s as key %s and value %s" arg key value
                                    | Error (Some msg) ->
                                        sprintf "%s (at arg %s)" msg arg |> ArgParser_errors.Add
                                        go ParseState_ContainsBoolEnvVar.AwaitingKey args
                        else
                            arg |> (fun x -> x) |> parser_LeftoverArgs.Add
                            go ParseState_ContainsBoolEnvVar.AwaitingKey args
                    | ParseState_ContainsBoolEnvVar.AwaitingValue key ->
                        match processKeyValue key arg with
                        | Ok () -> go ParseState_ContainsBoolEnvVar.AwaitingKey args
                        | Error exc ->
                            if setFlagValue key then
                                go ParseState_ContainsBoolEnvVar.AwaitingKey (arg :: args)
                            else
                                match exc with
                                | None ->
                                    failwithf
                                        "Unable to process supplied arg %s. Help text follows.\n%s"
                                        key
                                        (helpText ())
                                | Some msg -> msg |> ArgParser_errors.Add

            go ParseState_ContainsBoolEnvVar.AwaitingKey args

            let parser_LeftoverArgs =
                if 0 = parser_LeftoverArgs.Count then
                    ()
                else
                    parser_LeftoverArgs
                    |> String.concat " "
                    |> sprintf "There were leftover args: %s"
                    |> ArgParser_errors.Add

                    Unchecked.defaultof<_>

            let arg_0 =
                match arg_0 with
                | None ->
                    match "CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable with
                    | null ->
                        sprintf
                            "No value was supplied for %s, nor was environment variable %s set"
                            "--bool-var"
                            "CONSUMEPLUGIN_THINGS"
                        |> ArgParser_errors.Add

                        Unchecked.defaultof<_>
                    | x ->
                        if System.String.Equals (x, "1", System.StringComparison.OrdinalIgnoreCase) then
                            true
                        else if System.String.Equals (x, "0", System.StringComparison.OrdinalIgnoreCase) then
                            false
                        else
                            x |> (fun x -> System.Boolean.Parse x)
                    |> Choice2Of2
                | Some x -> Choice1Of2 x

            if 0 = ArgParser_errors.Count then
                {
                    BoolVar = arg_0
                }
            else
                ArgParser_errors |> String.concat "\n" |> failwithf "Errors during parse!\n%s"

        static member parse (args : string list) : ContainsBoolEnvVar =
            ContainsBoolEnvVar.parse' System.Environment.GetEnvironmentVariable args
