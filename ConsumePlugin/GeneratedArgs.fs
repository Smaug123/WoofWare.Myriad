//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------






namespace ArgParserHelpers

/// Helper types for arg parsing
module internal ArgParseHelpers_ConsumePlugin =
    open System
    open System.IO
    open WoofWare.Myriad.Plugins
    open ConsumePlugin

    /// A partially-parsed BasicNoPositionals.
    type internal BasicNoPositionals_InProgress =
        {
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable Rest : ResizeArray<int>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<BasicNoPositionals * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : int list = this.Rest |> Seq.toList

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Foo = arg0
                            Bar = arg1
                            Baz = arg2
                            Rest = arg3
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : BasicNoPositionals_InProgress =
            {
                Bar = None
                Baz = None
                Foo = None
                Rest = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "rest", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Int32.Parse x) |> this.Rest.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "foo", System.StringComparison.OrdinalIgnoreCase) then
                match this.Foo with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "foo")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Foo <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "baz", System.StringComparison.OrdinalIgnoreCase) then
                match this.Baz with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "baz")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Baz <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "bar", System.StringComparison.OrdinalIgnoreCase) then
                match this.Bar with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "bar")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Bar <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed Basic.
    type internal Basic_InProgress =
        {
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable Rest : ResizeArray<string>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<Basic * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : string list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Foo = arg0
                            Bar = arg1
                            Baz = arg2
                            Rest = arg3
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : Basic_InProgress =
            {
                Bar = None
                Baz = None
                Foo = None
                Rest = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "rest", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> x) |> this.Rest.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "foo", System.StringComparison.OrdinalIgnoreCase) then
                match this.Foo with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "foo")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Foo <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "baz", System.StringComparison.OrdinalIgnoreCase) then
                match this.Baz with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "baz")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Baz <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "bar", System.StringComparison.OrdinalIgnoreCase) then
                match this.Bar with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "bar")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Bar <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed BasicWithIntPositionals.
    type internal BasicWithIntPositionals_InProgress =
        {
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable Rest : ResizeArray<int>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<BasicWithIntPositionals * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : int list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Int32.Parse x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Foo = arg0
                            Bar = arg1
                            Baz = arg2
                            Rest = arg3
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : BasicWithIntPositionals_InProgress =
            {
                Bar = None
                Baz = None
                Foo = None
                Rest = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "rest", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Int32.Parse x) |> this.Rest.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "foo", System.StringComparison.OrdinalIgnoreCase) then
                match this.Foo with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "foo")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Foo <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "baz", System.StringComparison.OrdinalIgnoreCase) then
                match this.Baz with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "baz")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Baz <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "bar", System.StringComparison.OrdinalIgnoreCase) then
                match this.Bar with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "bar")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Bar <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed LoadsOfTypes.
    type internal LoadsOfTypes_InProgress =
        {
            mutable AnotherOptionalThing : int option
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable OptionalThing : bool option
            mutable OptionalThingWithNoDefault : int option
            mutable Positionals : ResizeArray<int>
            mutable SomeDirectory : DirectoryInfo option
            mutable SomeFile : FileInfo option
            mutable SomeList : ResizeArray<DirectoryInfo>
            mutable YetAnotherOptionalThing : string option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<LoadsOfTypes * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : FileInfo =
                match this.SomeFile with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeFile"
                    Unchecked.defaultof<_>

            let arg4 : DirectoryInfo =
                match this.SomeDirectory with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeDirectory"
                    Unchecked.defaultof<_>

            let arg5 : DirectoryInfo list = this.SomeList |> Seq.toList
            let arg6 : int option = this.OptionalThingWithNoDefault

            let arg7 : int list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Int32.Parse x)

            let arg8 : Choice<bool, bool> =
                match this.OptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypes.DefaultOptionalThing ())

            let arg9 : Choice<int, int> =
                match this.AnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypes.DefaultAnotherOptionalThing ())

            let arg10 : Choice<string, string> =
                match this.YetAnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 ("CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable |> (fun x -> x))

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Foo = arg0
                            Bar = arg1
                            Baz = arg2
                            SomeFile = arg3
                            SomeDirectory = arg4
                            SomeList = arg5
                            OptionalThingWithNoDefault = arg6
                            Positionals = arg7
                            OptionalThing = arg8
                            AnotherOptionalThing = arg9
                            YetAnotherOptionalThing = arg10
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : LoadsOfTypes_InProgress =
            {
                AnotherOptionalThing = None
                Bar = None
                Baz = None
                Foo = None
                OptionalThing = None
                OptionalThingWithNoDefault = None
                Positionals = ResizeArray ()
                SomeDirectory = None
                SomeFile = None
                SomeList = ResizeArray ()
                YetAnotherOptionalThing = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (
                    key,
                    sprintf "--%s" "yet-another-optional-thing",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.YetAnotherOptionalThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "yet-another-optional-thing")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.YetAnotherOptionalThing <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "some-list", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> System.IO.DirectoryInfo x) |> this.SomeList.Add
                () |> Ok
            else if
                System.String.Equals (key, sprintf "--%s" "some-file", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.SomeFile with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "some-file")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.SomeFile <- value |> (fun x -> System.IO.FileInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "some-directory", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.SomeDirectory with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "some-directory")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.SomeDirectory <- value |> (fun x -> System.IO.DirectoryInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "positionals", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> System.Int32.Parse x) |> this.Positionals.Add
                () |> Ok
            else if
                System.String.Equals (
                    key,
                    sprintf "--%s" "optional-thing-with-no-default",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.OptionalThingWithNoDefault with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "optional-thing-with-no-default")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.OptionalThingWithNoDefault <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "optional-thing", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.OptionalThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "optional-thing")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.OptionalThing <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "foo", System.StringComparison.OrdinalIgnoreCase) then
                match this.Foo with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "foo")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Foo <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "baz", System.StringComparison.OrdinalIgnoreCase) then
                match this.Baz with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "baz")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Baz <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "bar", System.StringComparison.OrdinalIgnoreCase) then
                match this.Bar with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "bar")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Bar <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (
                    key,
                    sprintf "--%s" "another-optional-thing",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.AnotherOptionalThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "another-optional-thing")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.AnotherOptionalThing <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed LoadsOfTypesNoPositionals.
    type internal LoadsOfTypesNoPositionals_InProgress =
        {
            mutable AnotherOptionalThing : int option
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable OptionalThing : bool option
            mutable OptionalThingWithNoDefault : int option
            mutable SomeDirectory : DirectoryInfo option
            mutable SomeFile : FileInfo option
            mutable SomeList : ResizeArray<DirectoryInfo>
            mutable YetAnotherOptionalThing : string option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<LoadsOfTypesNoPositionals * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : FileInfo =
                match this.SomeFile with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeFile"
                    Unchecked.defaultof<_>

            let arg4 : DirectoryInfo =
                match this.SomeDirectory with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeDirectory"
                    Unchecked.defaultof<_>

            let arg5 : DirectoryInfo list = this.SomeList |> Seq.toList
            let arg6 : int option = this.OptionalThingWithNoDefault

            let arg7 : Choice<bool, bool> =
                match this.OptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypesNoPositionals.DefaultOptionalThing ())

            let arg8 : Choice<int, int> =
                match this.AnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypesNoPositionals.DefaultAnotherOptionalThing ())

            let arg9 : Choice<string, string> =
                match this.YetAnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 ("CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable |> (fun x -> x))

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Foo = arg0
                            Bar = arg1
                            Baz = arg2
                            SomeFile = arg3
                            SomeDirectory = arg4
                            SomeList = arg5
                            OptionalThingWithNoDefault = arg6
                            OptionalThing = arg7
                            AnotherOptionalThing = arg8
                            YetAnotherOptionalThing = arg9
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : LoadsOfTypesNoPositionals_InProgress =
            {
                AnotherOptionalThing = None
                Bar = None
                Baz = None
                Foo = None
                OptionalThing = None
                OptionalThingWithNoDefault = None
                SomeDirectory = None
                SomeFile = None
                SomeList = ResizeArray ()
                YetAnotherOptionalThing = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (
                    key,
                    sprintf "--%s" "yet-another-optional-thing",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.YetAnotherOptionalThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "yet-another-optional-thing")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.YetAnotherOptionalThing <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "some-list", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> System.IO.DirectoryInfo x) |> this.SomeList.Add
                () |> Ok
            else if
                System.String.Equals (key, sprintf "--%s" "some-file", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.SomeFile with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "some-file")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.SomeFile <- value |> (fun x -> System.IO.FileInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "some-directory", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.SomeDirectory with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "some-directory")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.SomeDirectory <- value |> (fun x -> System.IO.DirectoryInfo x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (
                    key,
                    sprintf "--%s" "optional-thing-with-no-default",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.OptionalThingWithNoDefault with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "optional-thing-with-no-default")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.OptionalThingWithNoDefault <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "optional-thing", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.OptionalThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "optional-thing")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.OptionalThing <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "foo", System.StringComparison.OrdinalIgnoreCase) then
                match this.Foo with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "foo")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Foo <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "baz", System.StringComparison.OrdinalIgnoreCase) then
                match this.Baz with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "baz")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Baz <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "bar", System.StringComparison.OrdinalIgnoreCase) then
                match this.Bar with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "bar")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Bar <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (
                    key,
                    sprintf "--%s" "another-optional-thing",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.AnotherOptionalThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "another-optional-thing")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.AnotherOptionalThing <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed DatesAndTimes.
    type internal DatesAndTimes_InProgress =
        {
            mutable Exact : TimeSpan option
            mutable Invariant : TimeSpan option
            mutable InvariantExact : TimeSpan option
            mutable Plain : TimeSpan option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<DatesAndTimes * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : TimeSpan =
                match this.Plain with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Plain"
                    Unchecked.defaultof<_>

            let arg1 : TimeSpan =
                match this.Invariant with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Invariant"
                    Unchecked.defaultof<_>

            let arg2 : TimeSpan =
                match this.Exact with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Exact"
                    Unchecked.defaultof<_>

            let arg3 : TimeSpan =
                match this.InvariantExact with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for InvariantExact"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Plain = arg0
                            Invariant = arg1
                            Exact = arg2
                            InvariantExact = arg3
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : DatesAndTimes_InProgress =
            {
                Exact = None
                Invariant = None
                InvariantExact = None
                Plain = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "plain", System.StringComparison.OrdinalIgnoreCase) then
                match this.Plain with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "plain")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Plain <- value |> (fun x -> System.TimeSpan.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "invariant-exact", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.InvariantExact with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "invariant-exact")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.InvariantExact <-
                            value
                            |> (fun x ->
                                System.TimeSpan.ParseExact (
                                    x,
                                    @"hh\:mm\:ss",
                                    System.Globalization.CultureInfo.InvariantCulture
                                )
                            )
                            |> Some

                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "invariant", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.Invariant with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "invariant")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Invariant <-
                            value
                            |> (fun x -> System.TimeSpan.Parse (x, System.Globalization.CultureInfo.InvariantCulture))
                            |> Some

                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "exact", System.StringComparison.OrdinalIgnoreCase) then
                match this.Exact with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "exact")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Exact <-
                            value
                            |> (fun x ->
                                System.TimeSpan.ParseExact (
                                    x,
                                    @"hh\:mm\:ss",
                                    System.Globalization.CultureInfo.CurrentCulture
                                )
                            )
                            |> Some

                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ChildRecord.
    type internal ChildRecord_InProgress =
        {
            mutable Thing1 : int option
            mutable Thing2 : string option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ChildRecord * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Thing1 with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Thing1"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Thing2 with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Thing2"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Thing1 = arg0
                            Thing2 = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ChildRecord_InProgress =
            {
                Thing1 = None
                Thing2 = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "thing2", System.StringComparison.OrdinalIgnoreCase) then
                match this.Thing2 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "thing2")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Thing2 <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if System.String.Equals (key, sprintf "--%s" "thing1", System.StringComparison.OrdinalIgnoreCase) then
                match this.Thing1 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "thing1")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Thing1 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ParentRecord.
    type internal ParentRecord_InProgress =
        {
            mutable AndAnother : bool option
            mutable Child : ChildRecord_InProgress
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ParentRecord * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : ChildRecord =
                match this.Child.Assemble getEnvironmentVariable positionals with
                | Ok (result, consumedPositional) ->
                    match consumedPositional with
                    | None -> ()
                    | Some positionalConsumer -> positionalConsumers.Add positionalConsumer

                    result
                | Error err ->
                    errors.AddRange err
                    Unchecked.defaultof<_>

            let arg1 : bool =
                match this.AndAnother with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for AndAnother"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Child = arg0
                            AndAnother = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ParentRecord_InProgress =
            {
                AndAnother = None
                Child = ChildRecord_InProgress._Empty ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "and-another", System.StringComparison.OrdinalIgnoreCase) then
                match this.AndAnother with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "and-another")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.AndAnother <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ChildRecordWithPositional.
    type internal ChildRecordWithPositional_InProgress =
        {
            mutable Thing1 : int option
            mutable Thing2 : ResizeArray<Uri>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ChildRecordWithPositional * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : int =
                match this.Thing1 with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Thing1"
                    Unchecked.defaultof<_>

            let arg1 : Uri list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Uri x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Thing1 = arg0
                            Thing2 = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ChildRecordWithPositional_InProgress =
            {
                Thing1 = None
                Thing2 = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "thing2", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Uri x) |> this.Thing2.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "thing1", System.StringComparison.OrdinalIgnoreCase) then
                match this.Thing1 with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "thing1")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.Thing1 <- value |> (fun x -> System.Int32.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ParentRecordChildPos.
    type internal ParentRecordChildPos_InProgress =
        {
            mutable AndAnother : bool option
            mutable Child : ChildRecordWithPositional_InProgress
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ParentRecordChildPos * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : ChildRecordWithPositional =
                match this.Child.Assemble getEnvironmentVariable positionals with
                | Ok (result, consumedPositional) ->
                    match consumedPositional with
                    | None -> ()
                    | Some positionalConsumer -> positionalConsumers.Add positionalConsumer

                    result
                | Error err ->
                    errors.AddRange err
                    Unchecked.defaultof<_>

            let arg1 : bool =
                match this.AndAnother with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for AndAnother"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Child = arg0
                            AndAnother = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ParentRecordChildPos_InProgress =
            {
                AndAnother = None
                Child = ChildRecordWithPositional_InProgress._Empty ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "and-another", System.StringComparison.OrdinalIgnoreCase) then
                match this.AndAnother with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "and-another")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.AndAnother <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ParentRecordSelfPos.
    type internal ParentRecordSelfPos_InProgress =
        {
            mutable AndAnother : ResizeArray<bool>
            mutable Child : ChildRecord_InProgress
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ParentRecordSelfPos * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : ChildRecord =
                match this.Child.Assemble getEnvironmentVariable positionals with
                | Ok (result, consumedPositional) ->
                    match consumedPositional with
                    | None -> ()
                    | Some positionalConsumer -> positionalConsumers.Add positionalConsumer

                    result
                | Error err ->
                    errors.AddRange err
                    Unchecked.defaultof<_>

            let arg1 : bool list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Boolean.Parse x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Child = arg0
                            AndAnother = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ParentRecordSelfPos_InProgress =
            {
                AndAnother = ResizeArray ()
                Child = ChildRecord_InProgress._Empty ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "and-another", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> System.Boolean.Parse x) |> this.AndAnother.Add
                () |> Ok
            else
                Error None

    /// A partially-parsed ChoicePositionals.
    type internal ChoicePositionals_InProgress =
        {
            mutable Args : ResizeArray<string>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ChoicePositionals * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : Choice<string, string> list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> (fun x -> x) x |> Choice1Of2
                    | Choice2Of2 x -> (fun x -> x) x |> Choice2Of2
                )

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            Args = arg0
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ChoicePositionals_InProgress =
            {
                Args = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "args", System.StringComparison.OrdinalIgnoreCase) then
                value |> (fun x -> x) |> this.Args.Add
                () |> Ok
            else
                Error None

    /// A partially-parsed ContainsBoolEnvVar.
    type internal ContainsBoolEnvVar_InProgress =
        {
            mutable BoolVar : bool option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ContainsBoolEnvVar * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : Choice<bool, bool> =
                match this.BoolVar with
                | Some result -> Choice1Of2 result
                | None ->
                    Choice2Of2 (
                        "CONSUMEPLUGIN_THINGS"
                        |> getEnvironmentVariable
                        |> (fun x -> System.Boolean.Parse x)
                    )

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            BoolVar = arg0
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ContainsBoolEnvVar_InProgress =
            {
                BoolVar = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "bool-var", System.StringComparison.OrdinalIgnoreCase) then
                match this.BoolVar with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "bool-var")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.BoolVar <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed WithFlagDu.
    type internal WithFlagDu_InProgress =
        {
            mutable DryRun : DryRunMode option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<WithFlagDu * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : DryRunMode =
                match this.DryRun with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for DryRun"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            DryRun = arg0
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : WithFlagDu_InProgress =
            {
                DryRun = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "dry-run", System.StringComparison.OrdinalIgnoreCase) then
                match this.DryRun with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "dry-run")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.DryRun <-
                            value
                            |> (fun x ->
                                if System.Boolean.Parse x = Consts.FALSE then
                                    DryRunMode.Wet
                                else
                                    DryRunMode.Dry
                            )
                            |> Some

                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ContainsFlagEnvVar.
    type internal ContainsFlagEnvVar_InProgress =
        {
            mutable DryRun : DryRunMode option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ContainsFlagEnvVar * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : Choice<DryRunMode, DryRunMode> =
                match this.DryRun with
                | Some result -> Choice1Of2 result
                | None ->
                    Choice2Of2 (
                        "CONSUMEPLUGIN_THINGS"
                        |> getEnvironmentVariable
                        |> (fun x ->
                            if System.Boolean.Parse x = Consts.FALSE then
                                DryRunMode.Wet
                            else
                                DryRunMode.Dry
                        )
                    )

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            DryRun = arg0
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ContainsFlagEnvVar_InProgress =
            {
                DryRun = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "dry-run", System.StringComparison.OrdinalIgnoreCase) then
                match this.DryRun with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "dry-run")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.DryRun <-
                            value
                            |> (fun x ->
                                if System.Boolean.Parse x = Consts.FALSE then
                                    DryRunMode.Wet
                                else
                                    DryRunMode.Dry
                            )
                            |> Some

                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ContainsFlagDefaultValue.
    type internal ContainsFlagDefaultValue_InProgress =
        {
            mutable DryRun : DryRunMode option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ContainsFlagDefaultValue * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : Choice<DryRunMode, DryRunMode> =
                match this.DryRun with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (ContainsFlagDefaultValue.DefaultDryRun ())

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            DryRun = arg0
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ContainsFlagDefaultValue_InProgress =
            {
                DryRun = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if System.String.Equals (key, sprintf "--%s" "dry-run", System.StringComparison.OrdinalIgnoreCase) then
                match this.DryRun with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "dry-run")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.DryRun <-
                            value
                            |> (fun x ->
                                if System.Boolean.Parse x = Consts.FALSE then
                                    DryRunMode.Wet
                                else
                                    DryRunMode.Dry
                            )
                            |> Some

                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed ManyLongForms.
    type internal ManyLongForms_InProgress =
        {
            mutable DoTheThing : string option
            mutable SomeFlag : bool option
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ManyLongForms * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : string =
                match this.DoTheThing with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for DoTheThing"
                    Unchecked.defaultof<_>

            let arg1 : bool =
                match this.SomeFlag with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeFlag"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            DoTheThing = arg0
                            SomeFlag = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : ManyLongForms_InProgress =
            {
                DoTheThing = None
                SomeFlag = None
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (key, sprintf "--%s" "dont-turn-it-off", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.SomeFlag with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s / --%s" "turn-it-on" "dont-turn-it-off")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.SomeFlag <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "turn-it-on", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.SomeFlag with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s / --%s" "turn-it-on" "dont-turn-it-off")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.SomeFlag <- value |> (fun x -> System.Boolean.Parse x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (key, sprintf "--%s" "anotherarg", System.StringComparison.OrdinalIgnoreCase)
            then
                match this.DoTheThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s / --%s" "do-something-else" "anotherarg")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.DoTheThing <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else if
                System.String.Equals (
                    key,
                    sprintf "--%s" "do-something-else",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                match this.DoTheThing with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s / --%s" "do-something-else" "anotherarg")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.DoTheThing <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed FlagsIntoPositionalArgs.
    type internal FlagsIntoPositionalArgs_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<string>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgs * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : string list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            A = arg0
                            GrabEverything = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : FlagsIntoPositionalArgs_InProgress =
            {
                A = None
                GrabEverything = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (key, sprintf "--%s" "grab-everything", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> x) |> this.GrabEverything.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "a", System.StringComparison.OrdinalIgnoreCase) then
                match this.A with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "a")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.A <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed FlagsIntoPositionalArgsChoice.
    type internal FlagsIntoPositionalArgsChoice_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<string>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgsChoice * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : Choice<string, string> list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> (fun x -> x) x |> Choice1Of2
                    | Choice2Of2 x -> (fun x -> x) x |> Choice2Of2
                )

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            A = arg0
                            GrabEverything = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : FlagsIntoPositionalArgsChoice_InProgress =
            {
                A = None
                GrabEverything = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (key, sprintf "--%s" "grab-everything", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> x) |> this.GrabEverything.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "a", System.StringComparison.OrdinalIgnoreCase) then
                match this.A with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "a")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.A <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed FlagsIntoPositionalArgsInt.
    type internal FlagsIntoPositionalArgsInt_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<int>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgsInt * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : int list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Int32.Parse x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            A = arg0
                            GrabEverything = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : FlagsIntoPositionalArgsInt_InProgress =
            {
                A = None
                GrabEverything = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (key, sprintf "--%s" "grab-everything", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> System.Int32.Parse x) |> this.GrabEverything.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "a", System.StringComparison.OrdinalIgnoreCase) then
                match this.A with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "a")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.A <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed FlagsIntoPositionalArgsIntChoice.
    type internal FlagsIntoPositionalArgsIntChoice_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<int>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgsIntChoice * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : Choice<int, int> list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> (fun x -> System.Int32.Parse x) x |> Choice1Of2
                    | Choice2Of2 x -> (fun x -> System.Int32.Parse x) x |> Choice2Of2
                )

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            A = arg0
                            GrabEverything = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : FlagsIntoPositionalArgsIntChoice_InProgress =
            {
                A = None
                GrabEverything = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (key, sprintf "--%s" "grab-everything", System.StringComparison.OrdinalIgnoreCase)
            then
                value |> (fun x -> System.Int32.Parse x) |> this.GrabEverything.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "a", System.StringComparison.OrdinalIgnoreCase) then
                match this.A with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "a")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.A <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None

    /// A partially-parsed FlagsIntoPositionalArgs'.
    type internal FlagsIntoPositionalArgs'_InProgress =
        {
            mutable A : string option
            mutable DontGrabEverything : ResizeArray<string>
        }

        /// Freeze this in-progress type. On success, returns the frozen type and the arg (if any) which consumed the input positional args.
        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgs' * string option, string list>
            =
            let errors = ResizeArray<string> ()
            let positionalConsumers = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : string list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> x)

            if errors.Count = 0 then
                if positionalConsumers.Count <= 1 then
                    Ok (
                        {
                            A = arg0
                            DontGrabEverything = arg1
                        },
                        Seq.tryExactlyOne positionalConsumers
                    )
                else
                    ("Multiple parsers consumed positional args: "
                     + String.concat ", " positionalConsumers)
                    |> List.singleton
                    |> Error
            else
                errors |> Seq.toList |> Error

        static member _Empty () : FlagsIntoPositionalArgs'_InProgress =
            {
                A = None
                DontGrabEverything = ResizeArray ()
            }

        /// Processes the key-value pair, returning Error if no key was matched.
        /// If the key is an arg which can have arity 1, but throws when consuming that arg, we return Error(<the message>).
        /// This can nevertheless be a successful parse, e.g. when the key may have arity 0.
        member this.ProcessKeyValue
            (errors_ : ResizeArray<string>)
            (key : string)
            (value : string)
            : Result<unit, string option>
            =
            if
                System.String.Equals (
                    key,
                    sprintf "--%s" "dont-grab-everything",
                    System.StringComparison.OrdinalIgnoreCase
                )
            then
                value |> (fun x -> x) |> this.DontGrabEverything.Add
                () |> Ok
            else if System.String.Equals (key, sprintf "--%s" "a", System.StringComparison.OrdinalIgnoreCase) then
                match this.A with
                | Some x ->
                    sprintf
                        "Argument '%s' was supplied multiple times: %s and %s"
                        (sprintf "--%s" "a")
                        (x.ToString ())
                        (value.ToString ())
                    |> errors_.Add

                    Ok ()
                | None ->
                    try
                        this.A <- value |> (fun x -> x) |> Some
                        Ok ()
                    with _ as exc ->
                        exc.Message |> Some |> Error
            else
                Error None
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgs'
[<AutoOpen>]
module FlagsIntoPositionalArgs'ArgParse =
    type internal ParseState_FlagsIntoPositionalArgs' =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgs' with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgs'
            =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.FlagsIntoPositionalArgs'_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : FlagsIntoPositionalArgs' =
            FlagsIntoPositionalArgs'.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgsIntChoice
[<AutoOpen>]
module FlagsIntoPositionalArgsIntChoiceArgParse =
    type internal ParseState_FlagsIntoPositionalArgsIntChoice =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgsIntChoice with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgsIntChoice
            =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.FlagsIntoPositionalArgsIntChoice_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : FlagsIntoPositionalArgsIntChoice =
            FlagsIntoPositionalArgsIntChoice.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgsInt
[<AutoOpen>]
module FlagsIntoPositionalArgsIntArgParse =
    type internal ParseState_FlagsIntoPositionalArgsInt =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgsInt with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgsInt
            =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.FlagsIntoPositionalArgsInt_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : FlagsIntoPositionalArgsInt =
            FlagsIntoPositionalArgsInt.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgsChoice
[<AutoOpen>]
module FlagsIntoPositionalArgsChoiceArgParse =
    type internal ParseState_FlagsIntoPositionalArgsChoice =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgsChoice with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgsChoice
            =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.FlagsIntoPositionalArgsChoice_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : FlagsIntoPositionalArgsChoice =
            FlagsIntoPositionalArgsChoice.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgs
[<AutoOpen>]
module FlagsIntoPositionalArgsArgParse =
    type internal ParseState_FlagsIntoPositionalArgs =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgs with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgs
            =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.FlagsIntoPositionalArgs_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : FlagsIntoPositionalArgs =
            FlagsIntoPositionalArgs.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ManyLongForms
[<AutoOpen>]
module ManyLongFormsArgParse =
    type internal ParseState_ManyLongForms =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ManyLongForms with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ManyLongForms =
            let inProgress = ArgParseHelpers_ConsumePlugin.ManyLongForms_InProgress._Empty ()
            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ManyLongForms =
            ManyLongForms.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsFlagDefaultValue
[<AutoOpen>]
module ContainsFlagDefaultValueArgParse =
    type internal ParseState_ContainsFlagDefaultValue =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsFlagDefaultValue with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : ContainsFlagDefaultValue
            =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.ContainsFlagDefaultValue_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ContainsFlagDefaultValue =
            ContainsFlagDefaultValue.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsFlagEnvVar
[<AutoOpen>]
module ContainsFlagEnvVarArgParse =
    type internal ParseState_ContainsFlagEnvVar =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsFlagEnvVar with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ContainsFlagEnvVar =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.ContainsFlagEnvVar_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ContainsFlagEnvVar =
            ContainsFlagEnvVar.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type WithFlagDu
[<AutoOpen>]
module WithFlagDuArgParse =
    type internal ParseState_WithFlagDu =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type WithFlagDu with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : WithFlagDu =
            let inProgress = ArgParseHelpers_ConsumePlugin.WithFlagDu_InProgress._Empty ()
            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : WithFlagDu =
            WithFlagDu.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsBoolEnvVar
[<AutoOpen>]
module ContainsBoolEnvVarArgParse =
    type internal ParseState_ContainsBoolEnvVar =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsBoolEnvVar with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ContainsBoolEnvVar =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.ContainsBoolEnvVar_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ContainsBoolEnvVar =
            ContainsBoolEnvVar.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ChoicePositionals
[<AutoOpen>]
module ChoicePositionalsArgParse =
    type internal ParseState_ChoicePositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ChoicePositionals with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ChoicePositionals =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.ChoicePositionals_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ChoicePositionals =
            ChoicePositionals.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecordSelfPos
[<AutoOpen>]
module ParentRecordSelfPosArgParse =
    type internal ParseState_ParentRecordSelfPos =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecordSelfPos with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecordSelfPos =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.ParentRecordSelfPos_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ParentRecordSelfPos =
            ParentRecordSelfPos.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecordChildPos
[<AutoOpen>]
module ParentRecordChildPosArgParse =
    type internal ParseState_ParentRecordChildPos =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecordChildPos with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecordChildPos =
            let inProgress =
                ArgParseHelpers_ConsumePlugin.ParentRecordChildPos_InProgress._Empty ()

            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ParentRecordChildPos =
            ParentRecordChildPos.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecord
[<AutoOpen>]
module ParentRecordArgParse =
    type internal ParseState_ParentRecord =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecord with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecord =
            let inProgress = ArgParseHelpers_ConsumePlugin.ParentRecord_InProgress._Empty ()
            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : ParentRecord =
            ParentRecord.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type DatesAndTimes
[<AutoOpen>]
module DatesAndTimesArgParse =
    type internal ParseState_DatesAndTimes =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type DatesAndTimes with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : DatesAndTimes =
            let inProgress = ArgParseHelpers_ConsumePlugin.DatesAndTimes_InProgress._Empty ()
            let positionals : ResizeArray<string> = ResizeArray ()
            let parseAttempt = failwith "TODO"

            match parseAttempt with
            | Ok result -> result
            | Error e -> e |> String.concat System.Environment.NewLine |> failwith

        static member parse (args : string list) : DatesAndTimes =
            DatesAndTimes.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type LoadsOfTypesNoPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module LoadsOfTypesNoPositionals =
    type internal ParseState_LoadsOfTypesNoPositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : LoadsOfTypesNoPositionals =
        let inProgress =
            ArgParseHelpers_ConsumePlugin.LoadsOfTypesNoPositionals_InProgress._Empty ()

        let positionals : ResizeArray<string> = ResizeArray ()
        let parseAttempt = failwith "TODO"

        match parseAttempt with
        | Ok result -> result
        | Error e -> e |> String.concat System.Environment.NewLine |> failwith

    let parse (args : string list) : LoadsOfTypesNoPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type LoadsOfTypes
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module LoadsOfTypes =
    type internal ParseState_LoadsOfTypes =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : LoadsOfTypes =
        let inProgress = ArgParseHelpers_ConsumePlugin.LoadsOfTypes_InProgress._Empty ()
        let positionals : ResizeArray<string> = ResizeArray ()
        let parseAttempt = failwith "TODO"

        match parseAttempt with
        | Ok result -> result
        | Error e -> e |> String.concat System.Environment.NewLine |> failwith

    let parse (args : string list) : LoadsOfTypes =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type BasicWithIntPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module BasicWithIntPositionals =
    type internal ParseState_BasicWithIntPositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : BasicWithIntPositionals =
        let inProgress =
            ArgParseHelpers_ConsumePlugin.BasicWithIntPositionals_InProgress._Empty ()

        let positionals : ResizeArray<string> = ResizeArray ()
        let parseAttempt = failwith "TODO"

        match parseAttempt with
        | Ok result -> result
        | Error e -> e |> String.concat System.Environment.NewLine |> failwith

    let parse (args : string list) : BasicWithIntPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type Basic
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module Basic =
    type internal ParseState_Basic =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : Basic =
        let inProgress = ArgParseHelpers_ConsumePlugin.Basic_InProgress._Empty ()
        let positionals : ResizeArray<string> = ResizeArray ()
        let parseAttempt = failwith "TODO"

        match parseAttempt with
        | Ok result -> result
        | Error e -> e |> String.concat System.Environment.NewLine |> failwith

    let parse (args : string list) : Basic =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open ArgParserHelpers
open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type BasicNoPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module BasicNoPositionals =
    type internal ParseState_BasicNoPositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : BasicNoPositionals =
        let inProgress =
            ArgParseHelpers_ConsumePlugin.BasicNoPositionals_InProgress._Empty ()

        let positionals : ResizeArray<string> = ResizeArray ()
        let parseAttempt = failwith "TODO"

        match parseAttempt with
        | Ok result -> result
        | Error e -> e |> String.concat System.Environment.NewLine |> failwith

    let parse (args : string list) : BasicNoPositionals =
        parse' System.Environment.GetEnvironmentVariable args
