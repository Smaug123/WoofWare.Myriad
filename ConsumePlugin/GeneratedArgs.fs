//------------------------------------------------------------------------------
//        This code was generated by myriad.
//        Changes to this file will be lost when the code is regenerated.
//------------------------------------------------------------------------------






namespace ArgParserHelpers

/// Helper types for arg parsing
module private ArgParseHelpers_ConsumePlugin =
    open System
    open System.IO
    open WoofWare.Myriad.Plugins
    open ConsumePlugin

    /// A partially-parsed BasicNoPositionals.
    type private BasicNoPositionals_InProgress =
        {
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable Rest : ResizeArray<int>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<BasicNoPositionals, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : int list = this.Rest |> Seq.toList

            if errors.Count = 0 then
                Ok
                    {
                        Foo = arg0
                        Bar = arg1
                        Baz = arg2
                        Rest = arg3
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed Basic.
    type private Basic_InProgress =
        {
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable Rest : ResizeArray<string>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<Basic, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : string list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> x)

            if errors.Count = 0 then
                Ok
                    {
                        Foo = arg0
                        Bar = arg1
                        Baz = arg2
                        Rest = arg3
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed BasicWithIntPositionals.
    type private BasicWithIntPositionals_InProgress =
        {
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable Rest : ResizeArray<int>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<BasicWithIntPositionals, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : int list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Int32.Parse x)

            if errors.Count = 0 then
                Ok
                    {
                        Foo = arg0
                        Bar = arg1
                        Baz = arg2
                        Rest = arg3
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed LoadsOfTypes.
    type private LoadsOfTypes_InProgress =
        {
            mutable AnotherOptionalThing : int option
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable OptionalThing : bool option
            mutable OptionalThingWithNoDefault : int option
            mutable Positionals : ResizeArray<int>
            mutable SomeDirectory : DirectoryInfo option
            mutable SomeFile : FileInfo option
            mutable SomeList : ResizeArray<DirectoryInfo>
            mutable YetAnotherOptionalThing : string option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<LoadsOfTypes, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : FileInfo =
                match this.SomeFile with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeFile"
                    Unchecked.defaultof<_>

            let arg4 : DirectoryInfo =
                match this.SomeDirectory with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeDirectory"
                    Unchecked.defaultof<_>

            let arg5 : DirectoryInfo list = this.SomeList |> Seq.toList
            let arg6 : int option = this.OptionalThingWithNoDefault

            let arg7 : int list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Int32.Parse x)

            let arg8 : Choice<bool, bool> =
                match this.OptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypes.DefaultOptionalThing ())

            let arg9 : Choice<int, int> =
                match this.AnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypes.DefaultAnotherOptionalThing ())

            let arg10 : Choice<string, string> =
                match this.YetAnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 ("CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable |> (fun x -> x))

            if errors.Count = 0 then
                Ok
                    {
                        Foo = arg0
                        Bar = arg1
                        Baz = arg2
                        SomeFile = arg3
                        SomeDirectory = arg4
                        SomeList = arg5
                        OptionalThingWithNoDefault = arg6
                        Positionals = arg7
                        OptionalThing = arg8
                        AnotherOptionalThing = arg9
                        YetAnotherOptionalThing = arg10
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed LoadsOfTypesNoPositionals.
    type private LoadsOfTypesNoPositionals_InProgress =
        {
            mutable AnotherOptionalThing : int option
            mutable Bar : string option
            mutable Baz : bool option
            mutable Foo : int option
            mutable OptionalThing : bool option
            mutable OptionalThingWithNoDefault : int option
            mutable SomeDirectory : DirectoryInfo option
            mutable SomeFile : FileInfo option
            mutable SomeList : ResizeArray<DirectoryInfo>
            mutable YetAnotherOptionalThing : string option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<LoadsOfTypesNoPositionals, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Foo with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Foo"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Bar with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Bar"
                    Unchecked.defaultof<_>

            let arg2 : bool =
                match this.Baz with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Baz"
                    Unchecked.defaultof<_>

            let arg3 : FileInfo =
                match this.SomeFile with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeFile"
                    Unchecked.defaultof<_>

            let arg4 : DirectoryInfo =
                match this.SomeDirectory with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeDirectory"
                    Unchecked.defaultof<_>

            let arg5 : DirectoryInfo list = this.SomeList |> Seq.toList
            let arg6 : int option = this.OptionalThingWithNoDefault

            let arg7 : Choice<bool, bool> =
                match this.OptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypesNoPositionals.DefaultOptionalThing ())

            let arg8 : Choice<int, int> =
                match this.AnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (LoadsOfTypesNoPositionals.DefaultAnotherOptionalThing ())

            let arg9 : Choice<string, string> =
                match this.YetAnotherOptionalThing with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 ("CONSUMEPLUGIN_THINGS" |> getEnvironmentVariable |> (fun x -> x))

            if errors.Count = 0 then
                Ok
                    {
                        Foo = arg0
                        Bar = arg1
                        Baz = arg2
                        SomeFile = arg3
                        SomeDirectory = arg4
                        SomeList = arg5
                        OptionalThingWithNoDefault = arg6
                        OptionalThing = arg7
                        AnotherOptionalThing = arg8
                        YetAnotherOptionalThing = arg9
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed DatesAndTimes.
    type private DatesAndTimes_InProgress =
        {
            mutable Exact : TimeSpan option
            mutable Invariant : TimeSpan option
            mutable InvariantExact : TimeSpan option
            mutable Plain : TimeSpan option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<DatesAndTimes, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : TimeSpan =
                match this.Plain with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Plain"
                    Unchecked.defaultof<_>

            let arg1 : TimeSpan =
                match this.Invariant with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Invariant"
                    Unchecked.defaultof<_>

            let arg2 : TimeSpan =
                match this.Exact with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Exact"
                    Unchecked.defaultof<_>

            let arg3 : TimeSpan =
                match this.InvariantExact with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for InvariantExact"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                Ok
                    {
                        Plain = arg0
                        Invariant = arg1
                        Exact = arg2
                        InvariantExact = arg3
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ChildRecord.
    type private ChildRecord_InProgress =
        {
            mutable Thing1 : int option
            mutable Thing2 : string option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ChildRecord, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Thing1 with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Thing1"
                    Unchecked.defaultof<_>

            let arg1 : string =
                match this.Thing2 with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Thing2"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                Ok
                    {
                        Thing1 = arg0
                        Thing2 = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ParentRecord.
    type private ParentRecord_InProgress =
        {
            mutable AndAnother : bool option
            mutable Child : ChildRecord_InProgress
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ParentRecord, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : ChildRecord =
                match this.Child.Assemble getEnvironmentVariable positionals with
                | Ok result -> result
                | Error err ->
                    errors.AddRange err
                    Unchecked.defaultof<_>

            let arg1 : bool =
                match this.AndAnother with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for AndAnother"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                Ok
                    {
                        Child = arg0
                        AndAnother = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ChildRecordWithPositional.
    type private ChildRecordWithPositional_InProgress =
        {
            mutable Thing1 : int option
            mutable Thing2 : ResizeArray<Uri>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ChildRecordWithPositional, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : int =
                match this.Thing1 with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for Thing1"
                    Unchecked.defaultof<_>

            let arg1 : Uri list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Uri x)

            if errors.Count = 0 then
                Ok
                    {
                        Thing1 = arg0
                        Thing2 = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ParentRecordChildPos.
    type private ParentRecordChildPos_InProgress =
        {
            mutable AndAnother : bool option
            mutable Child : ChildRecordWithPositional_InProgress
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ParentRecordChildPos, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : ChildRecordWithPositional =
                match this.Child.Assemble getEnvironmentVariable positionals with
                | Ok result -> result
                | Error err ->
                    errors.AddRange err
                    Unchecked.defaultof<_>

            let arg1 : bool =
                match this.AndAnother with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for AndAnother"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                Ok
                    {
                        Child = arg0
                        AndAnother = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ParentRecordSelfPos.
    type private ParentRecordSelfPos_InProgress =
        {
            mutable AndAnother : ResizeArray<bool>
            mutable Child : ChildRecord_InProgress
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ParentRecordSelfPos, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : ChildRecord =
                match this.Child.Assemble getEnvironmentVariable positionals with
                | Ok result -> result
                | Error err ->
                    errors.AddRange err
                    Unchecked.defaultof<_>

            let arg1 : bool list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Boolean.Parse x)

            if errors.Count = 0 then
                Ok
                    {
                        Child = arg0
                        AndAnother = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ChoicePositionals.
    type private ChoicePositionals_InProgress =
        {
            mutable Args : ResizeArray<string>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ChoicePositionals, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : Choice<string, string> list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> (fun x -> x) x |> Choice1Of2
                    | Choice2Of2 x -> (fun x -> x) x |> Choice2Of2
                )

            if errors.Count = 0 then
                Ok
                    {
                        Args = arg0
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ContainsBoolEnvVar.
    type private ContainsBoolEnvVar_InProgress =
        {
            mutable BoolVar : bool option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ContainsBoolEnvVar, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : Choice<bool, bool> =
                match this.BoolVar with
                | Some result -> Choice1Of2 result
                | None ->
                    Choice2Of2 (
                        "CONSUMEPLUGIN_THINGS"
                        |> getEnvironmentVariable
                        |> (fun x -> System.Boolean.Parse x)
                    )

            if errors.Count = 0 then
                Ok
                    {
                        BoolVar = arg0
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed WithFlagDu.
    type private WithFlagDu_InProgress =
        {
            mutable DryRun : DryRunMode option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<WithFlagDu, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : DryRunMode =
                match this.DryRun with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for DryRun"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                Ok
                    {
                        DryRun = arg0
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ContainsFlagEnvVar.
    type private ContainsFlagEnvVar_InProgress =
        {
            mutable DryRun : DryRunMode option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ContainsFlagEnvVar, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : Choice<DryRunMode, DryRunMode> =
                match this.DryRun with
                | Some result -> Choice1Of2 result
                | None ->
                    Choice2Of2 (
                        "CONSUMEPLUGIN_THINGS"
                        |> getEnvironmentVariable
                        |> (fun x ->
                            if System.Boolean.Parse x = Consts.FALSE then
                                DryRunMode.Wet
                            else
                                DryRunMode.Dry
                        )
                    )

            if errors.Count = 0 then
                Ok
                    {
                        DryRun = arg0
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ContainsFlagDefaultValue.
    type private ContainsFlagDefaultValue_InProgress =
        {
            mutable DryRun : DryRunMode option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ContainsFlagDefaultValue, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : Choice<DryRunMode, DryRunMode> =
                match this.DryRun with
                | Some result -> Choice1Of2 result
                | None -> Choice2Of2 (ContainsFlagDefaultValue.DefaultDryRun ())

            if errors.Count = 0 then
                Ok
                    {
                        DryRun = arg0
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed ManyLongForms.
    type private ManyLongForms_InProgress =
        {
            mutable DoTheThing : string option
            mutable SomeFlag : bool option
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<ManyLongForms, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : string =
                match this.DoTheThing with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for DoTheThing"
                    Unchecked.defaultof<_>

            let arg1 : bool =
                match this.SomeFlag with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for SomeFlag"
                    Unchecked.defaultof<_>

            if errors.Count = 0 then
                Ok
                    {
                        DoTheThing = arg0
                        SomeFlag = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed FlagsIntoPositionalArgs.
    type private FlagsIntoPositionalArgs_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<string>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgs, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : string list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> x)

            if errors.Count = 0 then
                Ok
                    {
                        A = arg0
                        GrabEverything = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed FlagsIntoPositionalArgsChoice.
    type private FlagsIntoPositionalArgsChoice_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<string>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgsChoice, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : Choice<string, string> list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> (fun x -> x) x |> Choice1Of2
                    | Choice2Of2 x -> (fun x -> x) x |> Choice2Of2
                )

            if errors.Count = 0 then
                Ok
                    {
                        A = arg0
                        GrabEverything = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed FlagsIntoPositionalArgsInt.
    type private FlagsIntoPositionalArgsInt_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<int>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgsInt, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : int list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> System.Int32.Parse x)

            if errors.Count = 0 then
                Ok
                    {
                        A = arg0
                        GrabEverything = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed FlagsIntoPositionalArgsIntChoice.
    type private FlagsIntoPositionalArgsIntChoice_InProgress =
        {
            mutable A : string option
            mutable GrabEverything : ResizeArray<int>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgsIntChoice, string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : Choice<int, int> list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> (fun x -> System.Int32.Parse x) x |> Choice1Of2
                    | Choice2Of2 x -> (fun x -> System.Int32.Parse x) x |> Choice2Of2
                )

            if errors.Count = 0 then
                Ok
                    {
                        A = arg0
                        GrabEverything = arg1
                    }
            else
                errors |> Seq.toList |> Error

    /// A partially-parsed FlagsIntoPositionalArgs'.
    type private FlagsIntoPositionalArgs'_InProgress =
        {
            mutable A : string option
            mutable DontGrabEverything : ResizeArray<string>
        }

        member this.Assemble
            (getEnvironmentVariable : string -> string)
            (positionals : Choice<string, string> list)
            : Result<FlagsIntoPositionalArgs', string list>
            =
            let errors = ResizeArray<string> ()

            let arg0 : string =
                match this.A with
                | Some result -> result
                | None ->
                    errors.Add "no value provided for A"
                    Unchecked.defaultof<_>

            let arg1 : string list =
                positionals
                |> List.map (fun x ->
                    match x with
                    | Choice1Of2 x -> x
                    | Choice2Of2 x -> x
                )
                |> List.map (fun x -> x)

            if errors.Count = 0 then
                Ok
                    {
                        A = arg0
                        DontGrabEverything = arg1
                    }
            else
                errors |> Seq.toList |> Error
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgs'
[<AutoOpen>]
module FlagsIntoPositionalArgs'ArgParse =
    type private ParseState_FlagsIntoPositionalArgs' =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgs' with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgs'
            =
            failwith "todo"

        static member parse (args : string list) : FlagsIntoPositionalArgs' =
            FlagsIntoPositionalArgs'.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgsIntChoice
[<AutoOpen>]
module FlagsIntoPositionalArgsIntChoiceArgParse =
    type private ParseState_FlagsIntoPositionalArgsIntChoice =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgsIntChoice with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgsIntChoice
            =
            failwith "todo"

        static member parse (args : string list) : FlagsIntoPositionalArgsIntChoice =
            FlagsIntoPositionalArgsIntChoice.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgsInt
[<AutoOpen>]
module FlagsIntoPositionalArgsIntArgParse =
    type private ParseState_FlagsIntoPositionalArgsInt =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgsInt with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgsInt
            =
            failwith "todo"

        static member parse (args : string list) : FlagsIntoPositionalArgsInt =
            FlagsIntoPositionalArgsInt.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgsChoice
[<AutoOpen>]
module FlagsIntoPositionalArgsChoiceArgParse =
    type private ParseState_FlagsIntoPositionalArgsChoice =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgsChoice with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgsChoice
            =
            failwith "todo"

        static member parse (args : string list) : FlagsIntoPositionalArgsChoice =
            FlagsIntoPositionalArgsChoice.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type FlagsIntoPositionalArgs
[<AutoOpen>]
module FlagsIntoPositionalArgsArgParse =
    type private ParseState_FlagsIntoPositionalArgs =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type FlagsIntoPositionalArgs with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : FlagsIntoPositionalArgs
            =
            failwith "todo"

        static member parse (args : string list) : FlagsIntoPositionalArgs =
            FlagsIntoPositionalArgs.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ManyLongForms
[<AutoOpen>]
module ManyLongFormsArgParse =
    type private ParseState_ManyLongForms =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ManyLongForms with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ManyLongForms =
            failwith "todo"

        static member parse (args : string list) : ManyLongForms =
            ManyLongForms.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsFlagDefaultValue
[<AutoOpen>]
module ContainsFlagDefaultValueArgParse =
    type private ParseState_ContainsFlagDefaultValue =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsFlagDefaultValue with

        static member parse'
            (getEnvironmentVariable : string -> string)
            (args : string list)
            : ContainsFlagDefaultValue
            =
            failwith "todo"

        static member parse (args : string list) : ContainsFlagDefaultValue =
            ContainsFlagDefaultValue.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsFlagEnvVar
[<AutoOpen>]
module ContainsFlagEnvVarArgParse =
    type private ParseState_ContainsFlagEnvVar =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsFlagEnvVar with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ContainsFlagEnvVar =
            failwith "todo"

        static member parse (args : string list) : ContainsFlagEnvVar =
            ContainsFlagEnvVar.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type WithFlagDu
[<AutoOpen>]
module WithFlagDuArgParse =
    type private ParseState_WithFlagDu =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type WithFlagDu with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : WithFlagDu =
            failwith "todo"

        static member parse (args : string list) : WithFlagDu =
            WithFlagDu.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ContainsBoolEnvVar
[<AutoOpen>]
module ContainsBoolEnvVarArgParse =
    type private ParseState_ContainsBoolEnvVar =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ContainsBoolEnvVar with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ContainsBoolEnvVar =
            failwith "todo"

        static member parse (args : string list) : ContainsBoolEnvVar =
            ContainsBoolEnvVar.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ChoicePositionals
[<AutoOpen>]
module ChoicePositionalsArgParse =
    type private ParseState_ChoicePositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ChoicePositionals with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ChoicePositionals =
            failwith "todo"

        static member parse (args : string list) : ChoicePositionals =
            ChoicePositionals.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecordSelfPos
[<AutoOpen>]
module ParentRecordSelfPosArgParse =
    type private ParseState_ParentRecordSelfPos =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecordSelfPos with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecordSelfPos =
            failwith "todo"

        static member parse (args : string list) : ParentRecordSelfPos =
            ParentRecordSelfPos.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecordChildPos
[<AutoOpen>]
module ParentRecordChildPosArgParse =
    type private ParseState_ParentRecordChildPos =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecordChildPos with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecordChildPos =
            failwith "todo"

        static member parse (args : string list) : ParentRecordChildPos =
            ParentRecordChildPos.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type ParentRecord
[<AutoOpen>]
module ParentRecordArgParse =
    type private ParseState_ParentRecord =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type ParentRecord with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : ParentRecord =
            failwith "todo"

        static member parse (args : string list) : ParentRecord =
            ParentRecord.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type DatesAndTimes
[<AutoOpen>]
module DatesAndTimesArgParse =
    type private ParseState_DatesAndTimes =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    /// Extension methods for argument parsing
    type DatesAndTimes with

        static member parse' (getEnvironmentVariable : string -> string) (args : string list) : DatesAndTimes =
            failwith "todo"

        static member parse (args : string list) : DatesAndTimes =
            DatesAndTimes.parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type LoadsOfTypesNoPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module LoadsOfTypesNoPositionals =
    type private ParseState_LoadsOfTypesNoPositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : LoadsOfTypesNoPositionals =
        failwith "todo"

    let parse (args : string list) : LoadsOfTypesNoPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type LoadsOfTypes
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module LoadsOfTypes =
    type private ParseState_LoadsOfTypes =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : LoadsOfTypes = failwith "todo"

    let parse (args : string list) : LoadsOfTypes =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type BasicWithIntPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module BasicWithIntPositionals =
    type private ParseState_BasicWithIntPositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : BasicWithIntPositionals =
        failwith "todo"

    let parse (args : string list) : BasicWithIntPositionals =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type Basic
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module Basic =
    type private ParseState_Basic =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : Basic = failwith "todo"

    let parse (args : string list) : Basic =
        parse' System.Environment.GetEnvironmentVariable args
namespace ConsumePlugin

open System
open System.IO
open WoofWare.Myriad.Plugins

/// Methods to parse arguments for the type BasicNoPositionals
[<RequireQualifiedAccess ; CompilationRepresentation(CompilationRepresentationFlags.ModuleSuffix)>]
module BasicNoPositionals =
    type private ParseState_BasicNoPositionals =
        /// Ready to consume a key or positional arg
        | AwaitingKey
        /// Waiting to receive a value for the key we've already consumed
        | AwaitingValue of key : string

    let parse' (getEnvironmentVariable : string -> string) (args : string list) : BasicNoPositionals = failwith "todo"

    let parse (args : string list) : BasicNoPositionals =
        parse' System.Environment.GetEnvironmentVariable args
